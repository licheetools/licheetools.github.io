<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="编程思录，记录思考">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://licheetools.github.io">
    <!--SEO-->

    <meta name="keywords" content="java基础">


    <meta name="description" content="今天乘着还有一些时间，把上次拖欠的面向对象编程三大特性中遗留的继承和多态给简单说明一下。这一部分还是非常重要的，需要仔细思考。
继承继承：它是一种类与类之间的关系，通过使用已存在的类作为基础来建...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>关于JAVA你必须知道的那些事（三）：继承和访问修饰符 | 编程思录，记录思考</title>


    <link rel="alternate" href="/atom.xml" title="编程思录，记录思考" type="application/atom+xml">


    <link rel="icon" href="./favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header" style="background-image:url(https://upload-images.jianshu.io/upload_images/8964398-b1ba9582ea8b69ba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)">
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="Envy">
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 点滴进步，都是收获 </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://licheetools.github.io">编程思录，记录思考</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/font/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/java/"><i class="fa "></i>Java</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/django/"><i class="fa "></i>Django</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/flask/"><i class="fa "></i>Flask</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/spider/"><i class="fa "></i>爬虫</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/data/"><i class="fa "></i>数据分析</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/money/"><i class="fa "></i>付费教程</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/life/"><i class="fa "></i>生活记录</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives"><i class="fa "></i>时间轴</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/about/"><i class="fa "></i>关于博主</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/liuyan/"><i class="fa "></i>留言板</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="关于JAVA你必须知道的那些事（三）：继承和访问修饰符">
            
	            关于JAVA你必须知道的那些事（三）：继承和访问修饰符
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/java/">java</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/java基础/">java基础</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2018/08/02</span>
        </span>
        
            <span class="fa-wrap">
                <i class="fa fa-eye"></i>
                <span id="busuanzi_value_page_pv"></span>
            </span>
        
    
</div>
            
            
    </div>
    
    <div class="post-body post-content">
        <p>今天乘着还有一些时间，把上次拖欠的面向对象编程三大特性中遗留的继承和多态给简单说明一下。这一部分还是非常重要的，需要仔细思考。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承：它是一种类与类之间的关系，通过使用已存在的类作为基础来建立新类。其中已存在的类称为父类(或基类); 建立的新类称为子类(或派生类)。简单的就是子类继承父类的非私有属性和方法。</p>
<p>需要注意的是，新定义的类可以选择继续使用父类的功能或者自己增加新的数据或新的功能，但<strong>不能选择性地继承父类</strong>。（要么继承所有（前提是非私有），要么就不继承）</p>
<p>只要能满足 “A is a B”的关系就可以形成继承关系，代码中是通过 extends 关键字来实现继承的。</p>
<p>特别注意：在java中只能继承一个父类(也就是单继承)，而且子类可以访问父类的非私有成员。这个和Python不一样，Python的继承可就灵活了。</p>
<p>我们知道子类继承了父类之后，可以访问父类的非私有成员；但是父类的私有成员，子类还是无法直接访问。如果我们想访问呢？可以通过父类暴露的公有方法来实现间接访问。</p>
<p>父类对象不可以访问到子类特有的方法或属性，同时父类不可以访问子类特有成员（那怕是公有的成员）</p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>方法重载必须同时满足以下条件: </p>
<ol>
<li>同一个类中;；</li>
<li>方法名相同，参数列表不同(参数顺序、个数、类型)；</li>
<li>方法返回值、访问修饰符任意；</li>
<li>与方法的参数名无关。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void printinfo() &#123;</span><br><span class="line">	System.out.println(&quot;方法重载1&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">public void printinfo(String name) &#123;</span><br><span class="line"></span><br><span class="line">	System.out.println(&quot;方法重载2&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">public String printinfo(String name, int age) &#123;</span><br><span class="line">	return &quot;方法重载3&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">public String printinfo(String age, String name) &#123;</span><br><span class="line">	return &quot;方法重载4&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">public String printinfo(int age, String name) &#123;</span><br><span class="line">	return &quot;方法重载5&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> // 与方法的参数名无关,加上下面的代码会和上面的 printinfo(int age, String name)造成重复而报错：</span><br><span class="line">public String printinfo(int size, String name) &#123;</span><br><span class="line">	return &quot;方法重载5&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>方法重写也必须同时满足以下条件:<br>1、在满足继承关系的子类中；<br>2、方法名相同，参数列表相同(参数顺序、个数、类型)；<br>3、方法返回值相同或者是子类类型（但不允许是Object类型，可以向下兼容，向上是不可以的）；<br>4、访问修饰符的限定范围大于等于父类方法。</p>
<p>注意：在子类中是可以定义与父类重名的属性的，但这并不说明属性是可以重写的。</p>
<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>在Java里面一共包含4种访问修饰符，分别是：<br>1、private：私有的；<br>2、默认；<br>3、protected：受保护的；<br>4、public：公共的。</p>
<p>其中，<strong>private</strong>:只允许在本类范围中进行访问，离开了当前类就不允许访问；</p>
<p><strong>默认</strong>: 允许在当前类，同包子类/非子类都可调用，跨包子类/非子类都不允许；</p>
<p><strong>protected</strong>:允许在当前类，同包中的子类/非子类都可以以及跨包子类调用。跨包的非子类不允许调用。</p>
<p><strong>public</strong>:允许在任意位置访问。</p>
<p>按照前面的顺序，自上而下，访问范围越来越大；自下而上，限制能力越来越强：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-4bd5c8b69ee574fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>（同包包括同包子类与非子类；子类包括同包子类和跨包子类）</p>
<h2 id="访问修饰符对方法重写的影响"><a href="#访问修饰符对方法重写的影响" class="headerlink" title="访问修饰符对方法重写的影响"></a>访问修饰符对方法重写的影响</h2><p>子类重写父类方法时，访问修饰符是允许改变的，要求是: 子类的访问范围必须大于等于父类的访问范围。也就是说如果父类访问修饰符是public，那么子类的访问修饰符也必须是public，其他的类似。</p>
<h2 id="继承的初始化顺序"><a href="#继承的初始化顺序" class="headerlink" title="继承的初始化顺序"></a>继承的初始化顺序</h2><p>继承后的初始化顺序如下：</p>
<p>父类静态成员 -&gt; 子类静态成员 -&gt; 父类对象的构造 -&gt; 子类对象的构造</p>
<p><strong>一个问题:</strong> 访问修饰符影响成员加载顺序?静态成员优先于静态代码块执行?</p>
<p>访问修饰符不影响成员加载顺序,跟书写位置有关。如果把静态代码块写在静态变量的前面，那么先执行静态代码块。</p>
<h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><p>如果子类继承并重写了父类的方法，那么我们通常调用的就是重写后的子类方法。如果需要调用父类的方法，我们可以使用<code>super.方法</code>来达到这个目的。</p>
<p>当然也可以使用<code>super.属性</code>来达到访问父类的非私有属性的目的。</p>
<p><strong>尽管父类的构造方法的访问修饰符是public，但是它却不可以被子类继承和重写的。</strong></p>
<p>虽然它两个不可以，但是它的存在却是非常必要的，因为子类对象的实例化要依赖于父类对象的构造方法(默认，无参或有参的构造方法)。</p>
<p>如果子类调用了自己有参的构造方法，而父类定义了有参和无参的构造方法，程序依然是调用父类无参的构造方法。也就是说，我们在子类的构造方法中没有显式标注的情况下，默认调用父类的无参构造方法，因此父类的无参构造方法很重要，一定要写，否则会影响子类的对象实例化。</p>
<p>如果子类构造方法中既没有显式标注,且父类中没有无参的构造方法,则引发编译错误。</p>
<p>我们可以使用<code>super(参数)</code>这种形式来调用父类允许被访问的其他构造方法，但是此时super()必须放在子类构造方法有效代码的第一行（必须是子类的构造方法（其他方法不行）的第一行（其他行不行））。</p>
<p>也就是说父类在实例化的时候会默认调用无参的构造方法（此时你不定义无参的构造方法是可以的），但是如果子类在实例化对象的时候没有显示标志（也就是会默认调用父类无参的构造方法），而此时父类其实是不存在无参的构造方法，所以会引发编译错误。</p>
<h2 id="this和super的对比"><a href="#this和super的对比" class="headerlink" title="this和super的对比"></a>this和super的对比</h2><p><strong>this:</strong>当前类对象的引用：<br>1、访问当前类的成员方法；<br>2、访问当前类的成员属性；<br>3、访问当前类的构造方法；<br>4、不能在静态方法中使用；</p>
<hr>
<p><strong>super:</strong>父类对象的引用：<br>1、访问父类的成员方法；<br>2、访问父类的成员属性；<br>3、访问父类的构造方法；<br>4、不能在静态方法中使用；</p>
<hr>
<p><strong>注意：在调用构造方法时，this和super不能同时存在（前面说过两者都要求在第一行）。</strong></p>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>Object类是所有类的父类，这个其实和Python中差不多，在Python里面也是所有的类都继承于object这个基类。点这直接查看api：<a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">javase8api</a></p>
<p>一个类没有使用extends关键字明确标识继承关系,则默认继承Object类(包括数组)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class Object is the root of the class hierarchy.</span><br><span class="line">Every class has Object as a superclass. </span><br><span class="line">All objects, including arrays, implement the methods of this class.</span><br></pre></td></tr></table></figure></p>
<p>Object类存放于java.lang包中，这个包系统默认会为我们直接加载。</p>
<h3 id="equals用法"><a href="#equals用法" class="headerlink" title="equals用法"></a>equals用法</h3><p>如果子类没有重写Object类的equals方法，那么比较的是两个引用是否指向同一个地址；而String类则重写了Object类的equals方法，所以比较的是字符串的值是否相等。（言外之意，子类可以通过重写equals方法的形式，改变比较的内容）</p>
<p>因此我们不能这样说equals比较的两个对象的值，或者引用地址，但是我们却可以说”==”比较的却一定是两个对象的引用地址。</p>
<h3 id="toString用法"><a href="#toString用法" class="headerlink" title="toString用法"></a>toString用法</h3><p>api告诉我们，toString最后返回的是下面这种形式：（包名.类名@内存中的哈希码）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getClass().getName() + &apos;@&apos; + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure></p>
<p>同样的，子类如果没有重写Object类的toString方法，那么则会打印输出其在内存中的哈希码；而String类则重写了Object类的toString方法，所以打印输出其真实值。（言外之意，子类可以通过重写toString方法的形式，改变输出的内容）</p>
<p>还要说明的一点就是输出<code>对象</code>和<code>对象.toString</code>的效果是一样的，因为直接输出对象的时候其实是调用了对象.toString方法。</p>
<h2 id="Final关键字"><a href="#Final关键字" class="headerlink" title="Final关键字"></a>Final关键字</h2><p>当我们不希望某些类被继承，某些方法被重写或者某些数据被修改时，可以使用final关键字来实现这个目的。</p>
<p>如果某个类被final修饰，则表明该类不可以被继承，该类没有子类，public final class/final public class都可以，只要是放在class的前面就可以；</p>
<p>如果某个方法被final修饰，则表明该方法不可以被重写，但是并不影响子类去继承调用它（final不可以修饰构造方法）。</p>
<p>如果某个局部变量被final修饰，那么我们可以不用在声明的同时立马进行赋值，但是必须在使用之前进行赋值，一旦赋值就不能被修改；</p>
<p>（方法内的局部变量的作用范围，从该行开始到所在大括号结束；而类的成员变量的作用范围取决于它前面的访问修饰符）；</p>
<p>如果某个成员变量被final修饰，我们同样不需要声明的同时进行立马赋值，但是必须在使用之前进行赋值，而且只能在构造方法或者类代码块(构造代码块)中进行赋值，一旦赋值就不能被修改；也就是说类中成员属性的赋值可以有三种方式： 1. 定义是直接初始化； 2. 构造方法; 3. 构造代码块（类代码块）。</p>
<p><strong>注意: 当具有多个构造方法时，final关键字修饰的成员变量如果选择了在构造方法里面进行赋值，那么就需要在所有的构造方法里面进行赋值，但是不同构造方法是可以赋不同值的</strong></p>
<h2 id="final对数据类型的影响"><a href="#final对数据类型的影响" class="headerlink" title="final对数据类型的影响"></a>final对数据类型的影响</h2><p>我们知道java 数据类型分为基本数据类型（byte,short,int,long,float,double,char,boolean） 和 引用数据类型(array,String,interface,自定义的类…)</p>
<p>基本数据类型是可以直接进行赋值的，而引用类型需要实例化该类的对象，然后才能给其对象进行赋值（String这个比较特殊，两种形式都是可以的）</p>
<p>我们知道基本数据类型在内存中存放的是数据本身，而引用数据类型在内存中存放的则是对象的引用地址。</p>
<p>下面的例子告诉我们，被final修饰的对象不可以修改它的引用地址，但是属性却是可以的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final Test test=new Test(&quot;hello&quot;);	</span><br><span class="line">//		test=new Test ();</span><br><span class="line">		Test.key=&quot;world&quot;;</span><br></pre></td></tr></table></figure></p>
<p>总结一下就是：基本数据类型的变量其一旦被赋初值，就无法进行修改；而引用类型的变量只是在初始化之后不能再指向另一个对象，但是对象的内容却是可变的。</p>
<p>因此final可配合static使用，用来修饰方法和变量。通常是用于修饰配置信息等(因为这类信息只需要加载一次，而且后面不需要被修改)。言外之意，使用final修饰可以提高性能，但会降低可扩展性。</p>
<h3 id="普通代码块，类代码块，构造代码块，静态代码块区别"><a href="#普通代码块，类代码块，构造代码块，静态代码块区别" class="headerlink" title="普通代码块，类代码块，构造代码块，静态代码块区别"></a>普通代码块，类代码块，构造代码块，静态代码块区别</h3><p>代码块都是一对大括号{}所括起来的内容。</p>
<p>普通代码块就是一对大括号{}所括起来的内容，只存在于类的方法之中；</p>
<p>类代码块和构造代码块是一个东西，就是直接在类中进行定义的，前面没有static进行修饰。构造代码块在创建对象时被调用，每次创建对象都会被调用，并且构造代码块的执行次序优先于类的构造方法。</p>
<p>静态代码块前面有static关键字进行修饰，它不能存在于任何方法体内，也不能直接访问实例变量和实例方法，需要通过类的实例对象来访问。</p>
<p>通常我们new一个对象，JVM要经过这样的初始化顺序：父类静态块&gt;子类静态块&gt;父类属性&gt;父类构造器&gt;子类属性&gt;子类构造器，这一系列的工作会消耗大量的内存和cpu。 </p>
<p>具体的研究可以参看这里：<a href="https://www.jb51.net/article/129990.htm" target="_blank" rel="noopener">详解java中的四种代码块</a>。</p>
<h2 id="java中的注解"><a href="#java中的注解" class="headerlink" title="java中的注解"></a>java中的注解</h2><p>注解是JDK1.5版本引入的一个特性, 它可以声明在包、类、属性、方法、局部变量、方法参数等前面，作用就是对这些元素进行说明、注释。</p>
<h3 id="按照运行机制来分类"><a href="#按照运行机制来分类" class="headerlink" title="按照运行机制来分类"></a>按照运行机制来分类</h3><p>注解按照<strong>运行机制</strong>来进行划分，可以分为3部分:<strong>源码注解，编译时注解，运行时注解。</strong></p>
<p>源码注解：只在源码.java文件中存在，编译成.class字节码文件就不存在了；</p>
<p>编译时注解：在源码.java文件和字节码.class文件中都存在；</p>
<p>运行时注解：在运行阶段还起作用,甚至会影响运行逻辑的注解。（spring框架中的@Autowired依赖注入的这种注解，它实现的就是在程序运行的过程当中自动的将外部传入的信息加载进去,它就是一种可以影响程序运行逻辑的运行时注解。）</p>
<h3 id="按照来源来分"><a href="#按照来源来分" class="headerlink" title="按照来源来分"></a>按照来源来分</h3><p>注解按照<strong>来源</strong>来进行划分，可以分为3部分:<strong>JDK注解，第三方注解，自定义注解。</strong></p>
<p>还有一种元注解，它是对注解进行注解的。</p>
<p>不行了，写着写着字数又超了，快4000字了，面向对象最后一个特性：多态，我还没说呢，下次吧，今天得滚去运动了。。。感谢你的赏阅。</p>

    </div>
    
        <div class="reward" ontouchstart>
    <div class="reward-wrap">赏
        <div class="reward-box">
            
            
                <span class="reward-type">
                    <img class="wechat" src="https://upload-images.jianshu.io/upload_images/8964398-58d04ffa926103d9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><b>微信打赏</b>
                </span>
            
        </div>
    </div>
    <p class="reward-tip">觉得不错，赏包辣条吃呗！</p>
</div>


    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href target="_blank">编程思录</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2018/08/02/关于JAVA你必须知道的那些事（四）：单例模式和多态/" class="pre-post btn btn-default" title="关于JAVA你必须知道的那些事（四）：单例模式和多态">
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">关于JAVA你必须知道的那些事（四）：单例模式和多态</span>
        </a>
    
    
        <a href="/2018/08/01/关于JAVA你必须知道的那些事（二）：封装/" class="next-post btn btn-default" title="关于JAVA你必须知道的那些事（二）：封装">
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">关于JAVA你必须知道的那些事（二）：封装</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: '8zvHFFu5l2ah8lh0DEPH393B-gzGzoHsz',
            appKey: 'UNmB24200qMtyyrun5z99nOE',
            placeholder: '听说长得好看的，都已经留言了！',
            notify: false,
            verify: false,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重载"><span class="toc-text">重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重写"><span class="toc-text">重写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问修饰符"><span class="toc-text">访问修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问修饰符对方法重写的影响"><span class="toc-text">访问修饰符对方法重写的影响</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承的初始化顺序"><span class="toc-text">继承的初始化顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super关键字"><span class="toc-text">super关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this和super的对比"><span class="toc-text">this和super的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object类"><span class="toc-text">Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#equals用法"><span class="toc-text">equals用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString用法"><span class="toc-text">toString用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Final关键字"><span class="toc-text">Final关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final对数据类型的影响"><span class="toc-text">final对数据类型的影响</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#普通代码块，类代码块，构造代码块，静态代码块区别"><span class="toc-text">普通代码块，类代码块，构造代码块，静态代码块区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java中的注解"><span class="toc-text">java中的注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#按照运行机制来分类"><span class="toc-text">按照运行机制来分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#按照来源来分"><span class="toc-text">按照来源来分</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <span>Copyright &copy; 2017-2019
                </span> |
                <span>
				编程思录,保留所有权利
                    <!--Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>-->
                </span> |
                <span>
				<a style="color: #black" href="http://www.miitbeian.gov.cn">赣ICP备18013455号-5</a>
                    <!--Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>-->
                </span>
            </div>
			
			<div class="col-sm-12">
                <div class="busuanzi">
    
        访问量:
        <strong id="busuanzi_value_site_pv">
            <i class="fa fa-spinner fa-spin"></i>
        </strong>
        &nbsp; | &nbsp;
        访客数:
        <strong id="busuanzi_value_site_uv">
            <i class="fa fa-spinner fa-spin"></i>
        </strong>
    
</div>

            </div>
			
			<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1277113902'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s96.cnzz.com/z_stat.php%3Fid%3D1277113902%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));</script>
        </div>
    </div>
</div>




    <script src="/assets/tagcanvas.min.js?rev=2.9"></script>
    <script>
        var tagOption = {
            textColour: 'red', // 字体颜色
            outlineMethod: 'block', // 选中模式
            outlineColour: '#FFDAB9', // 选中模式的颜色
            interval: 30 || 30, // 动画帧之间的时间间隔，值越大，转动幅度越大
            textHeight: 13,
            outlineRadius: 3,
            freezeActive: true || '', // 选中的标签是否继续滚动
            frontSelect: true || '', // 不选标签云后部的标签
            initial: [0.1, -0.1],
            depth: 0.5,
            decel: 0.95,
            maxSpeed: 0.03,
            reverse: true || '', // 是否反向触发
            fadeIn: 500, // 进入动画时间
            wheelZoom: false || '' // 是否启用鼠标滚轮
        }
        TagCanvas.Start('tag-cloud-3d','',tagOption);
    </script>



    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>