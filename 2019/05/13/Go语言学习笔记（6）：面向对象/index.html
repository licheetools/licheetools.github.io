<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="编程思录，记录思考">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://blog.licheetools.top">
    <!--SEO-->

    <meta name="keywords" content="golang">


    <meta name="description" content="写在前面Go语言中的面向”对象”和其他语言非常不同，仅仅支持封装，不支持继承和多态。那么你可能要问了，仅仅依靠封装能实现一些较为复杂的事情么？Go语言通过接口和封装来实现较为复杂的事，所以更多的...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>Go语言学习笔记（6）：面向对象 | 编程思录，记录思考</title>


    <link rel="alternate" href="/atom.xml" title="编程思录，记录思考" type="application/atom+xml">


    <link rel="icon" href="./favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header" style="background-image:url(https://upload-images.jianshu.io/upload_images/8964398-b1ba9582ea8b69ba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)">
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="Envy">
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 点滴进步，都是收获 </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://blog.licheetools.top">编程思录，记录思考</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/font/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/java/"><i class="fa "></i>Java</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/python/"><i class="fa "></i>Python</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/go/"><i class="fa "></i>Go</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/spider/"><i class="fa "></i>爬虫</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/data/"><i class="fa "></i>数据分析</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/money/"><i class="fa "></i>付费教程</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/life/"><i class="fa "></i>生活记录</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives"><i class="fa "></i>时间轴</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/about/"><i class="fa "></i>关于博主</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/liuyan/"><i class="fa "></i>留言板</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Go语言学习笔记（6）：面向对象">
            
	            Go语言学习笔记（6）：面向对象
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/go/">go</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/golang/">golang</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2019/05/13</span>
        </span>
        
            <span class="fa-wrap">
                <i class="fa fa-eye"></i>
                <span id="busuanzi_value_page_pv"></span>
            </span>
        
    
</div>
            
            
    </div>
    
    <div class="post-body post-content">
        <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p><strong>Go语言中的面向”对象”和其他语言非常不同，仅仅支持封装，不支持继承和多态。</strong>那么你可能要问了，仅仅依靠封装能实现一些较为复杂的事情么？Go语言通过接口和封装来实现较为复杂的事，所以更多的是成为接口编程。</p>
<p><strong>既然只有封装，就没有class(类)，只有struct(结构体)。</strong></p>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>结构体是用户定义的类型，表示若干个字段的集合。当需要将多个数据分组到一个整体，而不是将每个数据作为单独的类型进行维护时，可以使用结构体。是不是有点类的概念？</p>
<h1 id="二分搜索树例子理解结构体知识"><a href="#二分搜索树例子理解结构体知识" class="headerlink" title="二分搜索树例子理解结构体知识"></a>二分搜索树例子理解结构体知识</h1><p>下面尝试通过一个二分搜索树的例子来介绍关于结构体的知识。二分搜索树分为3部分，某个节点的值，节点的左子树，节点的右子树。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-2974a54dcd88fcca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>其实结构体的声明和面向对象中类的声明非常类似：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义一个二分搜索树</span><br><span class="line">type treeNode struct&#123;</span><br><span class="line">	value int   //节点值为int类型</span><br><span class="line">	left, right *treeNode  //左右子树为指针类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在声明好结构体后，接下来就是定义它了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	var root treeNode                                       //定义一个二分搜索树对象</span><br><span class="line">	root = treeNode&#123;value: 2&#125;                               //二分搜索树root节点初始化</span><br><span class="line">	root.left = &amp;treeNode&#123;&#125;                                 //二分搜索树root节点左子树初始化</span><br><span class="line">	root.right = &amp;treeNode&#123;value: 6, left: nil, right: nil&#125; //二分搜索树root节点右子树初始化</span><br><span class="line">	//	root.right = &amp;treeNode&#123;6,nil, nil&#125;   </span><br><span class="line">    root.left.left =new(treeNode)   //给二分搜索树root节点的左子树的左侧创建一个节点</span><br><span class="line"></span><br><span class="line">    nodes :=[]treeNode&#123;</span><br><span class="line">    	&#123;value:3&#125;,</span><br><span class="line">    	&#123;&#125;,</span><br><span class="line">		&#123;5,nil,nil&#125;,</span><br><span class="line">		&#123;8,nil,&amp;root&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">    fmt.Println(nodes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">[&#123;3 &lt;nil&gt; &lt;nil&gt;&#125; &#123;0 &lt;nil&gt; &lt;nil&gt;&#125; &#123;5 &lt;nil&gt; &lt;nil&gt;&#125; &#123;8 &lt;nil&gt; 0xc000048420&#125;]</span><br></pre></td></tr></table></figure></p>
<p>你发现了么，声明结构体就相当于Java中的创建一个类，然后实例化这个结构体就是Java中类的实例化过程。<strong>在Go语言中，不论是地址还是结构体本身，一律使用<code>.</code>来访问成员。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var root treeNode                                       //定义一个二分搜索树对象</span><br><span class="line">root = treeNode&#123;value: 2&#125;                               //二分搜索树root节点初始化</span><br><span class="line">root.left = &amp;treeNode&#123;&#125;                                 //二分搜索树root节点左子树初始化</span><br><span class="line">root.right = &amp;treeNode&#123;value: 6, left: nil, right: nil&#125; //二分搜索树root节点右子树初始化</span><br><span class="line">	//	root.right = &amp;treeNode&#123;6,nil, nil&#125;   </span><br><span class="line">root.left.left =new(treeNode)   //给二分搜索树root节点的左子树的左侧创建一个节点</span><br></pre></td></tr></table></figure>
<p><strong>Go语言提供了很多实例化结构体的方法，因此结构体是没有构造方法的。</strong>当然如果你可以创建一个工厂方法用于实例化构造体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//用于创建一个结构体对象</span><br><span class="line">func createTreeNode(value int) *treeNode&#123;</span><br><span class="line">	return &amp;treeNode&#123;value:value&#125;  //这是一个局部变量的地址，但是Go语言允许返回局部变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相信聪明的你发现这个<code>createTreeNode</code>函数返回了一个局部对象的地址，这在C++中是不允许的，但是Go语言支持允许返回局部变量地址。然后使用该方法创建一个结构体对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> root.left.right = createTreeNode(9)</span><br><span class="line">//运行结果：</span><br><span class="line">&amp;&#123;9 &lt;nil&gt; &lt;nil&gt;&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到这里你可能会问，返回的局部对象是存在于堆上还是栈上呢？像C++，它的局部变量是分配在栈中，函数一旦退出，则局部变量会被销毁，只有定义在堆上的变量才能传递出去，不过这样就有一个麻烦，这个变量就需要你手动释放。而在Java中，通过New关键词生成的对象一般都在堆上，然后等到不使用的时候由垃圾回收机制回收。在Go语言中，你不需要知道它具体分配在何处，因为它是由Go语言编译器和运行环境决定的。</p>
<p>例如下面的<code>treeNode</code>没有取地址且不用返回出去，则这个<code>treeNode</code>可以在栈上分配它；当这个<code>treeNode</code>取了地址且返回出去给其他使用时，这个<code>treeNode</code>就可以在堆上分配，然后这个<code>treeNode</code>就会参与垃圾回收，当这个<code>treeNode</code>的指针不再使用的时候就会被回收。因此不能说函数退出这个局部变量就销毁了，这个在Go语言中是不一定的。既然能返回局部变量，那就不用考虑对象到底在哪里分配了，程序相对来说就好写一些：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func createTreeNode(value int) &#123;</span><br><span class="line">	return treeNode&#123;value:value&#125;  //这是一个局部变量的地址，但是Go语言允许返回局部变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来猜猜这段代码，创建了一个怎样的二分搜索树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var root treeNode                                       </span><br><span class="line">root = treeNode&#123;value: 2&#125;                               </span><br><span class="line">root.left = &amp;treeNode&#123;&#125;                                </span><br><span class="line">root.right = &amp;treeNode&#123;6, nil, nil&#125; </span><br><span class="line">root.right.left =new(treeNode)  </span><br><span class="line">root.left.right = createTreeNode(9)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-872a61e4f0ea48f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>接下来介绍如何遍历这个二分搜索树，但在此之前先介绍如何为结构体定义方法。注意结构体方法并不是写在结构体中的，而是写在结构体外面的，它有一个接收者，其他和普通函数差别不大：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//定义结构体方法，用于输出二分搜索树的信息</span><br><span class="line">func (tnode treeNode)print()&#123;</span><br><span class="line">	fmt.Println(tnode.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意到这个<code>func (tnode treeNode)print(){}</code>没有？普通的方法都是<code>func print(){}</code>，这里多了由小括号包含的<code>(tnode treeNode)</code>，我们称之为接收者。其实也就是告诉我们这个函数就是<code>treeNode</code>对象使用的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.print()</span><br></pre></td></tr></table></figure></p>
<p>当然如果你理解不了这个意思，可以使用普通函数的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func uprint(tnode treeNode)&#123;</span><br><span class="line">	fmt.Println(tnode.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprint(root)</span><br></pre></td></tr></table></figure></p>
<p>看到没有，这个就是区别，使用前者指定了接收者，故无需再次输入参数，使用后者则需传入指定参数。<strong>Go语言中只有值传递。</strong>我们尝试修改一下之前创建的那个空子树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.right.left =new(treeNode)   //给二分搜索树root节点的左子树的左侧创建一个节点</span><br></pre></td></tr></table></figure></p>
<p>就是上面那个，我们定义一个方法，看看能不能将其结点的值修改为8:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (tnode treeNode)setValue(value int)&#123;</span><br><span class="line">	tnode.value=value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root.right.left.setValue(8)</span><br><span class="line">root.right.left.print()</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<p><strong>再次强调一点Go语言中只有值传递。</strong>因此这样做是无法修改<code>root.right.left</code>节点的值的，此时可以借助于指针来完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (tnode *treeNode)setValueByPointer(value int)&#123;</span><br><span class="line">	tnode.value=value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root.right.left.setValue(8)</span><br><span class="line">root.right.left.print()</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">8</span><br></pre></td></tr></table></figure></p>
<p>通过指针传入对象（其实就是原来对象的地址，最后结果反映到原来对象上）就能修改其值。</p>
<p>总结一下为结构体定义方法，如下所示，注意就是将普通的函数返回到方法名称之前罢了，其实是普通方法没有什么区别？不过这样写能让大家一眼就能找到哪些是结构体方法，增强了辨识度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (tnode treeNode)print()&#123;</span><br><span class="line">	fmt.Println(tnode.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>结构体定义方法显示定义和命名方法接收者，只有使用指针作为方法接收者时才能修改结构的内容。nil指针其实也是可以调用方法的</strong></p>
<p>怎么理解nil指针也可以调用方法呢？我们尝试进行一个判断，并输出后测试一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func (tnode *treeNode)setValueByPointer(value int)&#123;</span><br><span class="line">	if tnode == nil&#123;</span><br><span class="line">		fmt.Println(&quot;你传入的是空指针&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	tnode.value=value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var testnil *treeNode</span><br><span class="line">testnil.setValueByPointer(99999)</span><br><span class="line">testnil = &amp;root</span><br><span class="line">testnil.setValueByPointer(2345)</span><br><span class="line">testnil.print()</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">你传入的是空指针</span><br><span class="line">panic: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">[signal 0xc0000005 code=0x1 addr=0x0 pc=0x49122d]</span><br></pre></td></tr></table></figure></p>
<p>出错是意料之中的事，因为第一次传进去的<code>testnil</code>是一个空指针<code>nil</code>，而<code>setValueByPointer</code>函数是需要有返回值的，而空指针<code>nil</code>是没有值的，因此会报错，其实你只需要在里面添加一个<code>return</code>就可以的解决这个问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func (tnode *treeNode)setValueByPointer(value int)&#123;</span><br><span class="line">	if tnode == nil&#123;</span><br><span class="line">		fmt.Println(&quot;你传入的是空指针&quot;)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	tnode.value=value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">你传入的是空指针</span><br><span class="line">2345</span><br></pre></td></tr></table></figure></p>
<p>不过需要说明的是并不是每次都需要判断传入的对象是不是nil，然后才进行后续操作，这个需要结合具体场景来的。</p>
<p>接下来介绍如何遍历这个二分搜索树：（学过二分搜索树的人肯定知道中序遍历结果是0 9 2 0 6)：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-872a61e4f0ea48f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>采用中序遍历的方式（遍历方式的名称是由该节点的遍历顺序来决定的，节点在最前面是前序，中间是中序，最后是后序）因此这里的中序就是先遍历左子树，再遍历节点，最后遍历右子树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//二分搜索树的中序遍历,其实采用了递归的思想</span><br><span class="line">func (tnode *treeNode)reverse()&#123;</span><br><span class="line">	if tnode ==nil&#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	tnode.left.reverse()</span><br><span class="line">	tnode.print()</span><br><span class="line">	tnode.right.reverse()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">0</span><br><span class="line">9</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p>
<p>结果和我们的预期完全吻合，但是你有没有我们只是判断了<code>tnode</code>节点是否是nil，但是对于其左右子树没有判断，事实上在JavaScript和Java中这个是不用判断的，但是C++中可能需要判断。</p>
<p>接下来谈谈<code>值接收者</code>和<code>指针接收者</code>的区别：<br>1、需要修改结构体内容的必须使用<code>指针接收者</code>；<br>2、当结果过大时，也必须使用<code>指针接收者</code>；<br>3、在具有<code>指针接收者</code>的情况下，建议都采用<code>指针接收者</code>；<br>4、<code>值接收者</code>是Go语言独有的；很多语言都有<code>指针接收者</code>如Python中的self，Java中的引用等；</p>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>接下来介绍封装，在Java中就是使用一些关键词如<code>private</code>、<code>default</code>、<code>protected</code>、<code>public</code>，按照前面的顺序，自上而下，访问范围越来越大；自下而上，限制能力越来越强，它们所控制的范围如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-4bd5c8b69ee574fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>但是在Go语言中就不一样了，Go语言通过函数的名字来进行范围控制的，名字一般使用CamelCase。<strong>首字母大写表示public，首字母小写表示private，这两个都是针对包而言的</strong></p>
<p><strong>包<code>package main</code>这个就是一个main包，默认使用的就是这个<code>main</code>包，<code>main</code>包包含了可执行入口。在Go语言中，每个目录都只能有一个包，包名不一定要和目录名一致。为结构体定义的方法必须放在同一个包内。</strong></p>
<p>尝试将之前的关于二分搜索树的代码拆分成不同的文件，然后进行导包操作：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-719ad9cd28616aee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>tree包里面包含一个包entry和文件node.go，而entry包中又包含entry.go文件。其中entry.go中只含有main方法，定义前面package为main包，当然也可以定义为entry包（每个目录都只能有一个包，包名不一定要和目录名一致。），但是我们只是让他运行main方法，因此定义package为main包。既然这样设置，那么以后包entry所有的go文件的package都必须是mian，否则会出错。同样外面的node.go文件中的package定义为tree包，因此以后tree文件里面所有go文件的package都必须定义为tree！</p>
<h3 id="扩展已有类型"><a href="#扩展已有类型" class="headerlink" title="扩展已有类型"></a>扩展已有类型</h3><p>现在有一个问题，就是你在开发过程中需要使用别人的包，那应该怎样使用呢？也就是如何扩展系统类型或别人的类型呢？你可以使用<strong>别名</strong>或者<strong>组合</strong>来解决这个问题。</p>
<p>这个需要配置GoPATH环境变量的，默认情况unix和linux是在<code>，~/go</code>下，Windows是在<code>%USERPROFILE%\go</code>。官方建议所有项目和第三方库都放在同一个GoPATH下面，但也可以将每个项目放在不同的GoPATH下面。Go语言会在编译时去各个GoPATH中找到不同的包。</p>
<h3 id="Go语言导包正确操作"><a href="#Go语言导包正确操作" class="headerlink" title="Go语言导包正确操作"></a>Go语言导包正确操作</h3><p>那么如何保证自己的go语言程序能正常运行呢？下面教大家如何设置(假设我准备所有go项目存放在<code>I:\Go\GoTest</code>文件夹下面，而我的Go语言安装在<code>G:\Applications\Go</code>文件夹下面):</p>
<p><strong>第一步：</strong>在<code>I:\Go\GoTest</code>文件夹下面新建<code>src</code>文件夹，注意必须是这个名字，不能随意修改；</p>
<p><strong>第二步：</strong>设置环境变量<code>GOROOT=G:\Applications\Go</code>（其实就是Go语言安装路径）和<code>Path=G:\Applications\Go\bin;</code>及<code>GOPATH=I:\Go\GoTest</code>（项目存放的地址，注意不能写成<code>I:\Go\GoTest\src</code>，仅仅写到<code>GoTest</code>文件夹为止）。</p>
<p><strong>第三步：</strong>配置GoLand参数，File–&gt;Settings–&gt;Go，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-8b210fdd66eac33e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-362b3448eb005a17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>之后点击确认，可能需要重启GoLand，然后使用Alt+Enter键就能实现自动导包了！</p>
<h3 id="获取第三方库"><a href="#获取第三方库" class="headerlink" title="获取第三方库"></a>获取第三方库</h3><p>接下来介绍如何获取Go语言的第三方库。在Python中你可以使用<code>pip install +库名</code>的方式，而在Go语言中可以使用<code>go get +库名</code>的办法。但是直接从谷歌服务器上下载库在国内似乎不行，这时推荐使用<code>gopm +库名</code>的方式:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-054ed1ac1c14ff9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>需要说明的是<code>go get</code>是内置的命令，而<code>gopm</code>是第三方工具，因此在使用前需要使用<code>go get</code>来安装<code>gopm</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/gpmgo/gopm</span><br></pre></td></tr></table></figure></p>
<p>之后会在你的src文件夹里面多了两个新的文件夹<code>bin</code>和<code>github.com</code>：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-1201ffa9f4355823.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>还记得前面设置的<code>Path=G:\Applications\Go\bin;</code>这个环境变量么，打开该文件夹发现里面都是可执行的exe文件：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-b002fa43a92841e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>而我们刚才生成的bin目录下有一个<code>gopm.exe</code>，因此需要将这个gopm.exe复制到<br><code>G:\Applications\Go\bin</code>文件夹下面才能保证其正常运行。如果你觉得这种操作很麻烦可以直接修改path参数为<code>Path=%GOPATH%\bin;</code>这样就不需要导入了，那这样我们GOROOT下面的bin目录中的go、godoc、gofmt就无法正常运行了，那没事因为我们用到它的时候不多，手动使用他们也是可以接受的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-b002fa43a92841e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>这个src文件夹里面会存有你的项目和你下载的第三方库。关于Go内置的一些其他命令可以查看这里<a href="https://www.bookstack.cn/books/go_command_tutorial" target="_blank" rel="noopener">GO 命令教程</a>。</p>
<p>下面介绍gopm的使用。其实也是使用<code>gopm get+库名</code>的方式，当然还可以使用<code>gopm help</code>查看各种参数实现自定义下载位置配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">NAME:</span><br><span class="line">   Gopm - Go Package Manager</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   Gopm [global options] command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">VERSION:</span><br><span class="line">   0.8.8.0307 Beta</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">   list         list all dependencies of current project</span><br><span class="line">   gen          generate a gopmfile for current Go project</span><br><span class="line">   get          fetch remote package(s) and dependencies</span><br><span class="line">   bin          download and link dependencies and build binary</span><br><span class="line">   config       configure gopm settings</span><br><span class="line">   run          link dependencies and go run</span><br><span class="line">   test         link dependencies and go test</span><br><span class="line">   build        link dependencies and go build</span><br><span class="line">   install      link dependencies and go install</span><br><span class="line">   clean        clean all temporary files</span><br><span class="line">   update       check and update gopm resources including itself</span><br><span class="line">   help, h      Shows a list of commands or help for one command</span><br><span class="line"></span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line">   --noterm, -n         disable color output</span><br><span class="line">   --strict, -s         strict mode</span><br><span class="line">   --debug, -d          debug mode</span><br><span class="line">   --help, -h           show help</span><br><span class="line">   --version, -v        print the version</span><br></pre></td></tr></table></figure></p>
<p>还可以使用<code>go build</code>来编译，使用<code>go install</code>会产生pkg文件和可执行文件；使用<code>go run</code>会直接编译且运行。</p>
<p>其实看到这里有一个非常大的问题，就是有些文件夹里面有多个main方法的入口，这是不允许的，特别是在<code>go build</code>时候，因此建议一个文件夹下面就仅仅只有一个go程序。</p>

    </div>
    
        <div class="reward" ontouchstart>
    <div class="reward-wrap">赏
        <div class="reward-box">
            
            
                <span class="reward-type">
                    <img class="wechat" src="https://upload-images.jianshu.io/upload_images/8964398-58d04ffa926103d9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><b>微信打赏</b>
                </span>
            
        </div>
    </div>
    <p class="reward-tip">觉得不错，赏包辣条吃呗！</p>
</div>


    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href target="_blank">编程思录</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2019/05/15/Go语言学习笔记（7）：面向接口/" class="pre-post btn btn-default" title="Go语言学习笔记（7）：面向接口">
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">Go语言学习笔记（7）：面向接口</span>
        </a>
    
    
        <a href="/2019/05/12/Go语言学习笔记（4）：内建容器之数组、切片/" class="next-post btn btn-default" title="Go语言学习笔记（4）：内建容器之数组、切片">
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">Go语言学习笔记（4）：内建容器之数组、切片</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: '8zvHFFu5l2ah8lh0DEPH393B-gzGzoHsz',
            appKey: 'UNmB24200qMtyyrun5z99nOE',
            placeholder: '听说长得好看的，都已经留言了！',
            notify: false,
            verify: false,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#写在前面"><span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结构体"><span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二分搜索树例子理解结构体知识"><span class="toc-text">二分搜索树例子理解结构体知识</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#封装"><span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展已有类型"><span class="toc-text">扩展已有类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go语言导包正确操作"><span class="toc-text">Go语言导包正确操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取第三方库"><span class="toc-text">获取第三方库</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <span>Copyright &copy; 2017-2019
                </span> |
                <span>
				编程思录,保留所有权利
                    <!--Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>-->
                </span> |
                <span>
				<a style="color: #black" href="http://www.miitbeian.gov.cn">赣ICP备18013455号-5</a>
                    <!--Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>-->
                </span>
            </div>
			
			<div class="col-sm-12">
                <div class="busuanzi">
    
        访问量:
        <strong id="busuanzi_value_site_pv">
            <i class="fa fa-spinner fa-spin"></i>
        </strong>
        &nbsp; | &nbsp;
        访客数:
        <strong id="busuanzi_value_site_uv">
            <i class="fa fa-spinner fa-spin"></i>
        </strong>
    
</div>

            </div>
			
			<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1277113902'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s96.cnzz.com/z_stat.php%3Fid%3D1277113902%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));</script>
        </div>
    </div>
</div>




    <script src="/assets/tagcanvas.min.js?rev=2.9"></script>
    <script>
        var tagOption = {
            textColour: 'red', // 字体颜色
            outlineMethod: 'block', // 选中模式
            outlineColour: '#FFDAB9', // 选中模式的颜色
            interval: 30 || 30, // 动画帧之间的时间间隔，值越大，转动幅度越大
            textHeight: 13,
            outlineRadius: 3,
            freezeActive: true || '', // 选中的标签是否继续滚动
            frontSelect: true || '', // 不选标签云后部的标签
            initial: [0.1, -0.1],
            depth: 0.5,
            decel: 0.95,
            maxSpeed: 0.03,
            reverse: true || '', // 是否反向触发
            fadeIn: 500, // 进入动画时间
            wheelZoom: false || '' // 是否启用鼠标滚轮
        }
        TagCanvas.Start('tag-cloud-3d','',tagOption);
    </script>



    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>