<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>编程思录，记录思考</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.licheetools.top/"/>
  <updated>2019-11-04T14:06:38.967Z</updated>
  <id>http://blog.licheetools.top/</id>
  
  <author>
    <name>Envy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go语言学习笔记（8）：函数式编程</title>
    <link href="http://blog.licheetools.top/2019/05/16/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://blog.licheetools.top/2019/05/16/Go语言学习笔记（8）：函数式编程/</id>
    <published>2019-05-16T04:45:09.000Z</published>
    <updated>2019-11-04T14:06:38.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>本篇来学习Go语言的函数式编程，函数式编程不是Go语言独有的，像Python也是支持函数式编程的，不过Go语言支持函数式编程主要体现在闭包上。</p><p>Go语言闭包应用：1）不需要修饰如何访问自由变量；2）没有Lambda表达式，但是有匿名函数  （其实两者差不多）。</p><p>接下来谈一谈函数式编程和函数指针的区别，其实我个人更倾向于函数式编程，因为在函数式编程（如Python）中，函数是一等公民，因此参数，变量及返回值都可以是函数；而像函数指针（如C++、Java）函数只是一个名字，其实就是指针。</p><p>在函数式编程中，有一个高阶函数的概念，也就是说一个函数可以作为参数传给另外一个函数，或者一个函数的返回值为另外一个函数（若返回值为该函数本身，则为递归），满足其一则为高阶函数，如python中的map，reduce，filter等。还有就是闭包这个概念。</p><p>当然可能有人要拿出”正统”函数式编程来说话了，需要满足两点：1）不可变性：不能有状态，只有常量和函数；2）函数只能有一个参数。</p><p>这个”正统”函数式编程要求里面不能有变量，只有常量和函数这两种，甚至连选择、循环语句都不能使用；更过分的要求是参数只能有一个参数，之前的参数列表都不能用了，太特么变态了吧。由于Go语言设计时要求按照了这个规定，但是实际上灵活性很大，可以不按照上面”正统”函数式编程的要求来。</p><p>下面结合一个例子说明Go语言的函数式编程：计算1+2+3+…+9=?我们先用普通的方法，接着使用函数式编程，然后试着体会两者的不同之处。</p><p>普通方法实现的代码如下，这个其实非常简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">//定义求和函数，测试函数式编程</span><br><span class="line">func test(n int)int&#123;</span><br><span class="line">sum:=0</span><br><span class="line">for i:=0;i&lt;n;i++&#123;</span><br><span class="line">sum+=i</span><br><span class="line">&#125;</span><br><span class="line">return sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(test(10))</span><br><span class="line">&#125;</span><br><span class="line">//运行结果：</span><br><span class="line">45</span><br></pre></td></tr></table></figure></p><p>接下来看一下如何使用函数式编程来实现这个功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">//定义求和函数，测试函数式编程</span><br><span class="line">func functionaltest()func(int)int&#123;</span><br><span class="line">sum:=0</span><br><span class="line">return func(v int) int &#123;</span><br><span class="line">sum+=v</span><br><span class="line">return sum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">a:=functionaltest()</span><br><span class="line">for i:=0;i&lt;10;i++&#123;</span><br><span class="line">fmt.Printf(&quot;0+1+...+%d=%d\n&quot;,i,a(i))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//运行结果：</span><br><span class="line">0+1+...+0=0</span><br><span class="line">0+1+...+1=1</span><br><span class="line">0+1+...+2=3</span><br><span class="line">0+1+...+3=6</span><br><span class="line">0+1+...+4=10</span><br><span class="line">0+1+...+5=15</span><br><span class="line">0+1+...+6=21</span><br><span class="line">0+1+...+7=28</span><br><span class="line">0+1+...+8=36</span><br><span class="line">0+1+...+9=45</span><br></pre></td></tr></table></figure></p><p>其实上面就是闭包，在函数体中包含自由变量和局部变量，这里的sum就是自由变量，v是局部变量。</p><p>下面是我从网上找的其他语言如何通过闭包来实现相应的功能：<br>1）Python中的闭包：python原生支持闭包、使用<code>_closure_</code>来查看闭包内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def test():</span><br><span class="line">      sum = 0</span><br><span class="line">      def  f(value):</span><br><span class="line">            nonlocal sum</span><br><span class="line">            sum += value</span><br><span class="line">            return sum </span><br><span class="line">      return f</span><br></pre></td></tr></table></figure></p><p>2)C++中的闭包：过去stl或者boost带有类似库；C++11及以后：支持闭包，以下是C++14下编译通过的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">auto test()&#123;</span><br><span class="line">　　auto sum = 0;</span><br><span class="line">   return [-] (int value) mutable &#123;</span><br><span class="line">　　　　sum += value;</span><br><span class="line">　　　　return sum;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3)Java中的闭包：1.8以后使用Function接口和Lambda表达式来创建函数对象，函数本身不能作为参数和返回值的；1.8以前匿名类或Lambda表达式均支持闭包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer,Integer&gt; test() &#123;</span><br><span class="line">　　final Holder&lt;Integer&gt; sum = new Holder&lt;&gt;(0);</span><br><span class="line">   return (Integer value) -&gt; &#123;</span><br><span class="line">　　　　sum.value += value;</span><br><span class="line">　　　　return sum.value;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-71600d42ade23a9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>还有一个问题就是前面说的”正统”函数式编程要求：1）不可变性：不能有状态，只有常量和函数；2）函数只能有一个参数。我们尝试使用代码来实现这个要求，但是实现正统函数式编程不能有状态，那么应该将状态（函数执行结果）放在另一个函数中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//使用正统函数式编程,只有常量和函数，没有变量</span><br><span class="line">type itest func(int)(int,itest)</span><br><span class="line">func ftest(base int)itest&#123;</span><br><span class="line">return func(v int) (int, itest) &#123;</span><br><span class="line">return base+v,ftest(base+v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">a:=ftest(0)</span><br><span class="line">for i:=0;i&lt;10;i++&#123;</span><br><span class="line">var s int</span><br><span class="line">s,a =a(i)</span><br><span class="line">fmt.Printf(&quot;0+1+...+%d=%d\n&quot;,i,s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">0+1+...+0=0</span><br><span class="line">0+1+...+1=1</span><br><span class="line">0+1+...+2=3</span><br><span class="line">0+1+...+3=6</span><br><span class="line">0+1+...+4=10</span><br><span class="line">0+1+...+5=15</span><br><span class="line">0+1+...+6=21</span><br><span class="line">0+1+...+7=28</span><br><span class="line">0+1+...+8=36</span><br><span class="line">0+1+...+9=45</span><br></pre></td></tr></table></figure></p><p>不过这种正统函数式编程理解起来非常困难，写起来也不容易理解。</p><h3 id="斐波那契数列理解闭包"><a href="#斐波那契数列理解闭包" class="headerlink" title="斐波那契数列理解闭包"></a>斐波那契数列理解闭包</h3><p>接下来通过斐波那契数列来加深自己对于闭包的理解，同样先使用普通方法，然后使用闭包的方式实现。</p><p>普通方法实现输出斐波那契数列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//chapter06/fibonaqitest/fibonaqi.go文件</span><br><span class="line">package fibonaqi</span><br><span class="line"></span><br><span class="line">//1,1,2,3,5,8,13,21...</span><br><span class="line">func FBtest(n int)int&#123;</span><br><span class="line">a,b:=0,1</span><br><span class="line">for i:=0;i&lt;n;i++&#123;</span><br><span class="line">a,b = b,a+b</span><br><span class="line">&#125;</span><br><span class="line">return a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//chapter06/fibonaqitest/main.go文件：</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;chapter06/fibonaqitest/fibonaqi&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(fibonaqi.FBtest(5))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p><p>再来试试闭包的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//chapter06/fibonaqitest/fibonaqi.go文件</span><br><span class="line">//闭包</span><br><span class="line">func FPtest()func()int&#123;</span><br><span class="line">a, b:=0,1</span><br><span class="line">return func() int &#123;</span><br><span class="line">a,b=b,a+b</span><br><span class="line">return a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是这边有一个问题，就是这个函数内无法判断何时输出。其实这种和生成器非常相似，因此每次调用会执行一次该函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">f:=fibonaqi.FPtest()</span><br><span class="line">fmt.Println(f())  //闭包函数测试</span><br><span class="line">fmt.Println(f())  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><p>但是这个闭包其实变成了生成器，如果我们想输出斐波那契数列中小于10000的元素，我们需要多次调用这个生成器，直到输出的元素小于10000才停止运行，那么有没有简单的方法呢？我们可以让这个斐波那契函数实现一个输出内容的接口就行了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//闭包</span><br><span class="line">func FPtest()func()int&#123;</span><br><span class="line">a, b:=0,1</span><br><span class="line">return func() int &#123;</span><br><span class="line">a,b = b,a+b</span><br><span class="line">return a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type IntGenerator func() int</span><br><span class="line"></span><br><span class="line">func (g IntGenerator)Read(p[]byte)(n int,err error)&#123;</span><br><span class="line">next:=g()  //获取下一个元素</span><br><span class="line">if next &gt;10000&#123;  //达到10000以上结束</span><br><span class="line">return 0, io.EOF</span><br><span class="line">&#125;</span><br><span class="line">s:=fmt.Sprintf(&quot;%d\n&quot;,next)  //转换成字符串</span><br><span class="line"></span><br><span class="line">// TODO: incorrect if p is too small!</span><br><span class="line">return strings.NewReader(s).Read(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//之前用于从文件中输出内容的函数</span><br><span class="line">func PrintFileContent(reader io.Reader)&#123;</span><br><span class="line">scanner:=bufio.NewScanner(reader)</span><br><span class="line">for scanner.Scan()&#123;</span><br><span class="line">fmt.Println(scanner.Text())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var ft fibonaqi.IntGenerator =fibonaqi.FPtest()</span><br><span class="line">fibonaqi.PrintFileContent(ft)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line">21</span><br><span class="line">34</span><br><span class="line">55</span><br><span class="line">89</span><br><span class="line">144</span><br><span class="line">233</span><br><span class="line">377</span><br><span class="line">610</span><br><span class="line">987</span><br><span class="line">1597</span><br><span class="line">2584</span><br><span class="line">4181</span><br><span class="line">6765</span><br></pre></td></tr></table></figure></p><p>不过这个代码有一个瑕疵就是这个p对象不能太小，太小就无法输出信息，后续会对这段代码进行修改。</p><h1 id="二分搜索树遍历理解闭包"><a href="#二分搜索树遍历理解闭包" class="headerlink" title="二分搜索树遍历理解闭包"></a>二分搜索树遍历理解闭包</h1><p>接下来使用之前介绍的二分搜索树遍历的例子来加深对闭包的理解。学过二分搜索树的人肯定知道中序遍历结果是0 9 2 0 6：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-872a61e4f0ea48f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>但是之前的遍历函数只能实现遍历的功能，接下来让函数实现接口，那它就能干很多事了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//函数闭包，演示二分搜索树的遍历</span><br><span class="line">func (node *treeNode)Traverse()&#123;</span><br><span class="line">node.TraverseFunc(func(n *treeNode) &#123;</span><br><span class="line">n.Print()</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">func (node *treeNode)TraverseFunc(f func(*treeNode))&#123;</span><br><span class="line">if node==nil&#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">node.left.TraverseFunc(f)</span><br><span class="line">f(node)</span><br><span class="line">node.right.TraverseFunc(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var root treeNode   //声明一个二分搜索树对象</span><br><span class="line">root = treeNode&#123;value: 2&#125;    //二分搜索树root节点初始化</span><br><span class="line">root.left = &amp;treeNode&#123;&#125;     //二分搜索树root节点左子树初始化</span><br><span class="line">root.right = &amp;treeNode&#123;6, nil, nil&#125; //二分搜索树root节点右子树初始化,其本质也是一个treeNode对象</span><br><span class="line">    root.right.left =new(treeNode)   //给二分搜索树root节点的左子树的左侧创建一个节点</span><br><span class="line">    root.left.right = createTreeNode(9)</span><br><span class="line">    root.reverse()</span><br><span class="line">    fmt.Println(&quot;********************&quot;)</span><br><span class="line">    root.Traverse()</span><br><span class="line"></span><br><span class="line">    //数一下二分搜索树中元素的个数</span><br><span class="line">    nodeCount:=0</span><br><span class="line">    root.TraverseFunc(func(node *treeNode) &#123;</span><br><span class="line">nodeCount++</span><br><span class="line">&#125;)</span><br><span class="line">    fmt.Println(&quot;********************&quot;)</span><br><span class="line">    fmt.Println(&quot;节点总数为：&quot;,nodeCount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">0</span><br><span class="line">9</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">节点总数为： 5</span><br></pre></td></tr></table></figure></p><p>看到没，我们后实现的<code>TraverseFunc</code>函数的功能非常强大，不仅仅限于遍历。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;函数式编程&quot;&gt;&lt;a href=&quot;#函数式编程&quot; class=&quot;headerlink&quot; title=&quot;函数式编程&quot;&gt;&lt;/a&gt;函数式编程&lt;/h1&gt;&lt;p&gt;本篇来学习Go语言的函数式编程，函数式编程不是Go语言独有的，像Python也是支持函数式编程的，不过Go语言支持函
      
    
    </summary>
    
      <category term="go" scheme="http://blog.licheetools.top/categories/go/"/>
    
    
      <category term="golang" scheme="http://blog.licheetools.top/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记（7）：面向接口</title>
    <link href="http://blog.licheetools.top/2019/05/15/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89%EF%BC%9A%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/"/>
    <id>http://blog.licheetools.top/2019/05/15/Go语言学习笔记（7）：面向接口/</id>
    <published>2019-05-15T12:57:31.000Z</published>
    <updated>2019-11-04T14:06:07.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>本篇主要介绍Go语言中的特色功能面向接口，由于Go语言的面向对象只支持封装，因此需要借助于接口来实现类似于继承和多态的功能。</p><h1 id="Duck-Typing简介"><a href="#Duck-Typing简介" class="headerlink" title="Duck Typing简介"></a>Duck Typing简介</h1><p>在介绍接口之前，有必要介绍Duck Typing（鸭子类型），学过Python的应该就知道这个。”当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子，”这就是所谓的鸭子类型。</p><p>对于一门强类型的静态语言来说，要想通过运行时多态来隔离变化，多个实现类就必须属于同一类型体系，必须通过继承的方式与同一抽象类型建立is-a关系。而Duck Typing则是一种基于特征，而不是基于类型的多态方式。Duck Typing仍然关心is-a，只不过is-a关系是以对方是否具备相关的特征来确定的。是否满足is-a关系可以使用所谓的鸭子测试（Duck Test）进行判断。</p><p>当初提Duck Typing的前提是需要动态绑定，但是Go语言是在编译时就绑定的，因此从这个角度看其实Go语言并不是Duck Typing。但是我们假如只是关注描述事物的外部行为而非内部结构时，可以说Go语言是Duck Typing。</p><h3 id="Python中的Duck-Typing"><a href="#Python中的Duck-Typing" class="headerlink" title="Python中的Duck Typing"></a>Python中的Duck Typing</h3><p>来看看Python中的Duck Typing:（图片来自于互联网）</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0e21ba791a403d06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>我们发现Python中的Duck Typing其实是非常灵活的，无需关注retriever到底是哪个，只需要它里面具有get方法就能作为参数传入download函数。不过只有在运行的时候才知道传入的retriever是否包含get，因此想要提前知道必须借助于注释来说明这个问题。</p><h3 id="C-中的Duck-Typing"><a href="#C-中的Duck-Typing" class="headerlink" title="C++中的Duck Typing"></a>C++中的Duck Typing</h3><p>再来看一下C++中的Duck Typing：（C++原生支持Duck Typing，图片来自于互联网）</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-87688c2caae0367f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>C++通过使用模板继承来实现Duck Typing，同样这个retriever也是只需要具有get方法时，就能作为参数传入download函数。不过只有在编译的时候（敲代码的时候不知道）才知道传入的retriever是否包含get，因此想要提前知道还是必须借助于注释来说明这个问题。</p><p>总的来说Python和C++差不多，只是Python没有编译器，而C++有而已。</p><h3 id="Java中没有Duck-Typing"><a href="#Java中没有Duck-Typing" class="headerlink" title="Java中没有Duck Typing"></a>Java中没有Duck Typing</h3><p>Java没有Duck Typing，只有实现该功能的类似代码：（图片来自于互联网）</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4143fc286934e450.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>我们发现首先其实也是使用了模板R，然后实现了Retriever接口，因此download方法的参数必须是实现了Retriever接口的对象，不过这样做的好处就是不需要判断对象是否具有get方法了，因为你已经强制每个对象都必须包含get方法了。但是这个并不是Duck Typing，因为它强调了必须要实现Retriever接口，你传入的对象仅仅包含get方法还不行，必须实现Retriever接口方可。Java这样做的好处就是不在需要借助于注释来说明接口。</p><p>Java那种方式尽管不错，但是当download方法需要传入的R对象必须实现多个接口时，这就显得非常麻烦了。如同时需要Readable、Appendable怎么办？（可以使用apache polygene，但是依旧非常麻烦）。</p><p>我们希望Go语言中的Duck Typing能解决Java中的接口组装问题，具有Python、C++中的灵活性，还具有Java中的类型检查（在敲代码的时候提示），Go语言的设计者就真的做到了这一点。</p><h3 id="Go语言中的Duck-Typing"><a href="#Go语言中的Duck-Typing" class="headerlink" title="Go语言中的Duck Typing"></a>Go语言中的Duck Typing</h3><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4143fc286934e450.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e58f5871da0cfcb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>注意Go语言的接口是由使用者来定义的，这与传统的接口不同，传统的接口是由实现者定义的，你只要实现了我这个接口就能干什么事情。</p><p>接下来通过代码来理解<strong>Go语言的接口是由使用者来定义的</strong>这句话。</p><p>第一步，先创建retriever文件夹，再在里面创建一个envy文件夹，里面新建一个envyretriever.go文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package envy</span><br><span class="line"></span><br><span class="line">//envy来实现这个接口的Get方法</span><br><span class="line">type Retriever struct &#123;</span><br><span class="line">Contents string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r Retriever)Get(url string)string&#123;</span><br><span class="line">return r.Contents</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二步，在retriever文件夹里面再创建一个real文件夹，里面新建一个realretriever.go文件（一个简易的爬虫）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package real</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/http/httputil&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//创建一个真实的retriever</span><br><span class="line">type Retriever struct &#123;</span><br><span class="line">UserAgent string</span><br><span class="line">Timeout time.Duration  //时间段</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r Retriever) Get(url string) string &#123;</span><br><span class="line">    //这个Get方法说Caller should close resp.Body when done reading from it.</span><br><span class="line">response ,err:= http.Get(url)  </span><br><span class="line">if err !=nil&#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line">    //一个参数是response，另一个是否把response作为body</span><br><span class="line">result, err:= httputil.DumpResponse(response,true)   </span><br><span class="line"></span><br><span class="line">//因此需要读完这个response需要关闭这个response.Body</span><br><span class="line">_ = response.Body.Close()</span><br><span class="line">if err !=nil&#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line">return string(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第三步，在retriever文件夹里面再次创建一个main.go文件作为程序的入口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;chapter05/retriever/envy&quot;</span><br><span class="line">real2 &quot;chapter05/retriever/real&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Retriever interface &#123;</span><br><span class="line">Get(url string) string  //Get方法是接口中的方法，不过不需要使用func关键词定义，因为它本身就是函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func download(r Retriever)string&#123;   //Retriever是接口</span><br><span class="line">return r.Get(&quot;http://www.baidu.com&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var r Retriever  //此时运行会出错，因为引发空指针异常</span><br><span class="line">r = envy.Retriever&#123;&quot;这是envy创建的Retriever对象&quot;&#125;</span><br><span class="line">//fmt.Println(download(envy.Retriever&#123;&quot;这是envy创建的Retriever对象&quot;&#125;))</span><br><span class="line">r = real2.Retriever&#123;&#125;</span><br><span class="line">fmt.Println(download(r))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line"></span><br><span class="line">这是envy创建的Retriever对象</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt;</span><br><span class="line">&lt;meta content=&quot;always&quot; name=&quot;referrer&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;theme-color&quot; content=&quot;#2932e1&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;shortcut icon&quot; href=&quot;/favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt;</span><br><span class="line">    &lt;link rel=&quot;search&quot; type=&quot;application&quot; href=&quot;/content-search.xml&quot; title=&quot;百度搜索&quot; /&gt;</span><br><span class="line">    &lt;link rel=&quot;icon&quot; sizes=&quot;any&quot; mask href=&quot;//www.baidu.com/img/baidu_&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//s1.bdstatic.com&quot;/&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t1.baidu.com&quot;/&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t2.baidu.com&quot;/&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t3.baidu.com&quot;/&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t10.baidu.com&quot;/&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t11.baidu.com&quot;/&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t12.baidu.com&quot;/&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//b1.bdstatic.com&quot;/&gt;</span><br><span class="line">      ......................................</span><br></pre></td></tr></table></figure></p><p>通过上面三个步骤，相信大家现在一定对<strong>Go语言的接口是由使用者来定义的</strong>这句话有了更深刻的理解。我们知道Go语言中只有值传递，因此上面的对象r都不是指针，都是实际存在的东西，那我们输出打印看看它们到底是什么：（%T输出类型，%v输出值）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var r Retriever  //此时运行会出错，因为引发空指针异常</span><br><span class="line">r = envy.Retriever&#123;&quot;这是envy创建的Retriever对象&quot;&#125;</span><br><span class="line">//fmt.Println(download(envy.Retriever&#123;&quot;这是envy创建的Retriever对象&quot;&#125;))</span><br><span class="line">fmt.Printf(&quot;%T,%v\n&quot;,r,r)</span><br><span class="line">r = real2.Retriever&#123;</span><br><span class="line">UserAgent:&quot;Chrome/70.0.3538.110&quot;,</span><br><span class="line">Timeout: time.Minute,</span><br><span class="line">&#125;</span><br><span class="line">//fmt.Println(download(r))</span><br><span class="line">fmt.Printf(&quot;%T,%v\n&quot;,r,r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">envy.Retriever,&#123;这是envy创建的Retriever对象&#125;</span><br><span class="line">real.Retriever,&#123;Chrome/70.0.3538.110 1m0s&#125;</span><br></pre></td></tr></table></figure></p><p>我们尝试修改<code>real2.Retriever</code>的参数，使之传入指针参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func (r *Retriever) Get(url string) string &#123;&#125;</span><br><span class="line"></span><br><span class="line">r = &amp;real2.Retriever&#123;</span><br><span class="line">UserAgent:&quot;Chrome/70.0.3538.110&quot;,</span><br><span class="line">Timeout: time.Minute,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">envy.Retriever,&#123;这是envy创建的Retriever对象&#125;</span><br><span class="line">*real.Retriever,&amp;&#123;Chrome/70.0.3538.110 1m0s&#125;</span><br></pre></td></tr></table></figure></p><p>看到没最后输出的其实都是类型和值，不过我们一般都不会使用到接口的指针。</p><p>我们其实可以根据r对象的类型不同让它输出不同的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var r Retriever  //此时运行会出错，因为引发空指针异常</span><br><span class="line">r = envy.Retriever&#123;&quot;这是envy创建的Retriever对象&quot;&#125;</span><br><span class="line">inspect(r)</span><br><span class="line">r = real2.Retriever&#123;</span><br><span class="line">UserAgent:&quot;Chrome/70.0.3538.110&quot;,</span><br><span class="line">Timeout: time.Minute,</span><br><span class="line">&#125;</span><br><span class="line">inspect(r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func inspect(r Retriever)&#123;</span><br><span class="line">fmt.Printf(&quot;%T,%v\n&quot;,r,r)</span><br><span class="line">switch v:=r.(type)&#123;</span><br><span class="line">case envy.Retriever:</span><br><span class="line">fmt.Println(&quot;内容是：&quot;,v.Contents)</span><br><span class="line">case real2.Retriever:</span><br><span class="line">fmt.Println(&quot;内容是：&quot;,v.UserAgent)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">envy.Retriever,&#123;这是envy创建的Retriever对象&#125;</span><br><span class="line">内容是： 这是envy创建的Retriever对象</span><br><span class="line">real.Retriever,&#123;Chrome/70.0.3538.110 1m0s&#125;</span><br><span class="line">内容是： Chrome/70.0.3538.110</span><br></pre></td></tr></table></figure></p><p><code>r.(type)</code>是Go语言中的断言（Type Assertion），检查r的动态类型是否是type，在本篇的后续会介绍Go语言中的断言。</p><p>如果我们尝试将<code>real.Retriever</code>对象当做<code>envy.Retriever</code>来使用，那么程序会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">r = real2.Retriever&#123;</span><br><span class="line">UserAgent:&quot;Chrome/70.0.3538.110&quot;,</span><br><span class="line">Timeout: time.Minute,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">envyRetriever :=r.(envy.Retriever)</span><br><span class="line">fmt.Println(envyRetriever.Contents)</span><br><span class="line"></span><br><span class="line">//运行会报错</span><br><span class="line">panic: interface conversion: main.Retriever is real.Retriever, not envy.Retriever</span><br></pre></td></tr></table></figure></p><p>你还可以借助于返回值状态进行判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//通过断言判断</span><br><span class="line">if envyretriever,ok :=r.(envy.Retriever);ok&#123;</span><br><span class="line">fmt.Println(envyretriever.Contents)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">fmt.Println(&quot;该对象不是envy.Retriever&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//运行结果：</span><br><span class="line">该对象不是envy.Retriever</span><br></pre></td></tr></table></figure></p><p>那么接口变量中到底包含什么呢？其实它包含实现者的类型和实现者的值这两部分：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-751ef3ab26d25d46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>或者说是实现者和实现者指针指向实现者：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-d9dabb753d828184.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><strong>也就是说接口变量其实是自带指针的，接口变量同样采用值传递，因此几乎不需要接口的指针。指针接收者只能以指针方式使用；值接收者传递地址和指针两种方式都可以。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//envyretriever.go文件中：</span><br><span class="line">func (r Retriever)Get(url string)string&#123;&#125;  //值传递</span><br><span class="line"></span><br><span class="line">//realretriever.go文件中：</span><br><span class="line">func (r *Retriever) Get(url string) string &#123;&#125; //指针传递</span><br><span class="line"></span><br><span class="line">//main.go文件中：</span><br><span class="line">func main() &#123;</span><br><span class="line">var r Retriever  //此时运行会出错，因为引发空指针异常</span><br><span class="line">r = &amp;envy.Retriever&#123;&quot;这是envy创建的Retriever对象&quot;&#125;   //使用地址</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%T,%v\n&quot;,r,r)</span><br><span class="line">r = &amp;real2.Retriever&#123;    //使用地址</span><br><span class="line">UserAgent:&quot;Chrome/70.0.3538.110&quot;,</span><br><span class="line">Timeout: time.Minute,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;%T,%v\n&quot;,r,r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">*envy.Retriever,&amp;&#123;这是envy创建的Retriever对象&#125;</span><br><span class="line">*real.Retriever,&amp;&#123;Chrome/70.0.3538.110 1m0s&#125;</span><br></pre></td></tr></table></figure></p><p>看到没有，值接收者对于参数是没有要求的，而指针接收者要求必须传入指针参数。</p><p>如何查看接口变量呢？表示任何类型可以使用<code>interface{}</code>，Type Assertion（断言），Type Switch(类型判断)。</p><p>接下来通过常见的数据结构队列来演示如何用<code>interface{}</code>表示任何类型。不过一开始还是定义一个只是int类型的队列：(Queue包/Queue.go文件)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package Queue</span><br><span class="line"></span><br><span class="line">type Queue [] int   //定义int切片类型的Queue</span><br><span class="line"></span><br><span class="line">func (q Queue)Push(v int)&#123;</span><br><span class="line">q = append(q,v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (q Queue)Pop()int&#123;</span><br><span class="line">head:=q[0]</span><br><span class="line">return head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (q Queue)IsEmpty()bool&#123;</span><br><span class="line">return len(q)==0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再来看一下(main包/main.go文件)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;chapter05/Queue&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">q :=Queue.Queue&#123;1&#125;</span><br><span class="line">q.Push(2)</span><br><span class="line">q.Push(3)</span><br><span class="line">fmt.Println(q.Pop())</span><br><span class="line">fmt.Println(q.Pop())</span><br><span class="line">fmt.Println(q.IsEmpty())</span><br><span class="line">fmt.Println(q.Pop())</span><br><span class="line">fmt.Println(q.IsEmpty())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">false</span><br><span class="line">1</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p><p>因为Go语言是值传递，因此这个代码写的其实有问题，需要借助于指针才能修改队列信息，只需要修改：(Queue包/Queue.go文件)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package Queue</span><br><span class="line"></span><br><span class="line">type Queue [] int   //定义int切片类型的Queue</span><br><span class="line"></span><br><span class="line">func (q *Queue)Push(v int)&#123;</span><br><span class="line">*q = append(*q,v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (q *Queue)Pop()int&#123;</span><br><span class="line">head:=(*q)[0]</span><br><span class="line">*q = (*q)[1:]</span><br><span class="line">return head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (q *Queue)IsEmpty()bool&#123;</span><br><span class="line">return len(*q)==0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后点击运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">false</span><br><span class="line">3</span><br><span class="line">true</span><br></pre></td></tr></table></figure></p><p>这样就能修改队列数据了，但是只能传入int类型，一旦我们将Queue包/Queue.go文件中的<code>type Queue [] int</code>修改为<code>type Queue [] interface{}</code>,修改后的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package Queue</span><br><span class="line"></span><br><span class="line">//type Queue [] int   //定义int切片类型的Queue</span><br><span class="line">type Queue [] interface&#123;&#125;   //定义Queue</span><br><span class="line"></span><br><span class="line">func (q *Queue)Push(v interface&#123;&#125; )&#123;</span><br><span class="line">*q = append(*q,v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (q *Queue)Pop()interface&#123;&#125; &#123;</span><br><span class="line">head:=(*q)[0]</span><br><span class="line">*q = (*q)[1:]</span><br><span class="line">return head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (q *Queue)IsEmpty()bool&#123;</span><br><span class="line">return len(*q)==0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在mian.go中添加以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">q.Push(&quot;test&quot;)</span><br><span class="line">fmt.Println(q)</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">[test]</span><br></pre></td></tr></table></figure></p><p>这样我们的队列就支持插入不同的数据类型了。</p><h3 id="接口的组合"><a href="#接口的组合" class="headerlink" title="接口的组合"></a>接口的组合</h3><p>其实Go语言中的接口和Java中的接口都差不多，都是具有什么样的功能罢了，因此所谓的接口组合其实就是定义了多个接口，可以一起拿来使用罢了：</p><p>之前我们在retriever/main.go文件中只是定义了一个Retriever接口，接下来增加其他的接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">type Retriever interface &#123;  //获取信息接口</span><br><span class="line">Get(url string) string  //Get方法是接口中的方法，不过不需要使用func关键词定义，因为它本身就是函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Poster interface &#123;  //提交信息接口</span><br><span class="line">Post(url string, form map[string]string)string</span><br><span class="line">//Post方法是接口中的方法，不过不需要使用func关键词定义，因为它本身就是函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func download(r Retriever)string&#123;   //Retriever是接口</span><br><span class="line">return r.Get(&quot;http://www.baidu.com&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func post(poster Poster)&#123;   //Poster是接口</span><br><span class="line">poster.Post(&quot;http://www.baidu.com&quot;,</span><br><span class="line">map[string]string&#123;</span><br><span class="line">&quot;name&quot;: &quot;envy&quot;,</span><br><span class="line">&quot;language&quot;: &quot;golang&quot;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type RetrieverPoster interface &#123;</span><br><span class="line">Retriever   //此处直接调用之前的接口</span><br><span class="line">Poster</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func session(reposter RetrieverPoster)&#123;</span><br><span class="line">reposter.Get(&quot;http://www.baidu.com&quot;)</span><br><span class="line">reposter.Post(&quot;http://www.baidu.com&quot;,</span><br><span class="line">map[string]string&#123;</span><br><span class="line">&quot;name&quot;: &quot;envy&quot;,</span><br><span class="line">&quot;language&quot;: &quot;golang&quot;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面我们定义了两个接口<code>Retriever</code>和<code>Poster</code>，然后各自接口都有一个对象分别去调用接口中实现的方法，接着我们还定义了一个组合接口<code>RetrieverPoster</code>，这个<code>RetrieverPoster</code>接口中只是分别调用了<code>Retriever</code>和<code>Poster</code>这两个接口，这就是组合接口，最后的<code>session</code>方法中传入的<code>RetrieverPoster</code>对象可以调用Get和Post方法。</p><p>接下来在envyretriever.go文件中新增Post方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (r Retriever)Get(url string)string&#123;  //通过值传递无法修改其参数的值</span><br><span class="line">return r.Contents</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r Retriever)Post(url string, form map[string]string)string&#123;   </span><br><span class="line">//我们这里的Retriever对象实现了Poster接口中的Post方法</span><br><span class="line">r.Contents = form[&quot;contents&quot;]  //通过值传递无法修改其参数的值</span><br><span class="line">return &quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们的Retriever对象现在有了Get和Post方法，按照Go语言中鸭子类型的说法，那这个Retriever对象其实就是”RetrieverPoster”对象了，那就可以调用session方法了。打开retriever/main.go文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func session(reposter RetrieverPoster)string&#123;</span><br><span class="line">reposter.Post(url, map[string]string&#123;</span><br><span class="line">&quot;contents&quot;: &quot;这是组合接口中的RetrieverPoster对象&quot;,</span><br><span class="line">&#125;)</span><br><span class="line">return reposter.Get(url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">retriever := envy.Retriever&#123;&quot;这是envy创建的Retriever对象&quot;&#125;</span><br><span class="line">fmt.Println(&quot;调用session方法&quot;)</span><br><span class="line">fmt.Println(session(retriever))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">调用session方法</span><br><span class="line">这是envy创建的Retriever对象</span><br></pre></td></tr></table></figure></p><p>你会发现怎么输出结果不是<code>&quot;这是组合接口中的RetrieverPoster对象&quot;</code>这句话呢？那是因为你忘记了Go语言中只有值传递，值传递无法修改其参数，因此需要使用指针，也就是在类型参数前加<code>*</code>，在变量值后加<code>&amp;</code>取地址，之后运行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用session方法</span><br><span class="line">这是组合接口中的RetrieverPoster对象</span><br></pre></td></tr></table></figure></p><p>这也正确验证了Go语言中的鸭子类型是准确的。再次强调Go语言中的接口是由使用者来定义的，因此灵活度非常高，而实现者只需实现相应的方法即可，至于具体使用哪种接口则无所谓。</p><p>其实在Go语言中这种组合接口非常常见，如IO库中的<code>ReadWriter</code>、<code>ReadCloser</code>等：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// ReadWriter is the interface that groups the basic Read and Write methods.</span><br><span class="line">type ReadWriter interface &#123;</span><br><span class="line">Reader</span><br><span class="line">Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ReadCloser is the interface that groups the basic Read and Close methods.</span><br><span class="line">type ReadCloser interface &#123;</span><br><span class="line">Reader</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// WriteCloser is the interface that groups the basic Write and Close methods.</span><br><span class="line">type WriteCloser interface &#123;</span><br><span class="line">Writer</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Go语言中常用的标准接口"><a href="#Go语言中常用的标准接口" class="headerlink" title="Go语言中常用的标准接口"></a>Go语言中常用的标准接口</h1><p>接下来介绍Go语言中几个非常有用的标准接口，这对于平时开发有很大的帮助。</p><h3 id="Stringer"><a href="#Stringer" class="headerlink" title="Stringer"></a>Stringer</h3><p><code>Stringer</code>其实就是Java中的<code>toString</code>方法，<code>Stringer</code>存在于<code>fmt</code>包中，查看一下它的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Stringer is implemented by any value that has a String method,</span><br><span class="line">// which defines the ``native&apos;&apos; format for that value.</span><br><span class="line">// The String method is used to print values passed as an operand</span><br><span class="line">// to any format that accepts a string or to an unformatted printer</span><br><span class="line">// such as Print.</span><br><span class="line">type Stringer interface &#123;</span><br><span class="line">String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们尝试在之前的envyretriever.go文件中新增String方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (r *Retriever)String()string&#123;</span><br><span class="line">return fmt.Sprintf(</span><br><span class="line">&quot;Retriever:&#123;Contents=%s&#125;&quot;,r.Contents)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意此时既然是<code>String</code>方法，那当然是仅仅对参数是值对象才行，因此需要将envyretriever.go文件中的<code>Get</code>和<code>Post</code>方法修改为值接收者，然后在main.go文件中传入值参数就能自动调用这个String方法。</p><h3 id="Reader和Writer"><a href="#Reader和Writer" class="headerlink" title="Reader和Writer"></a>Reader和Writer</h3><p><code>Reader</code>及<code>Writer</code>接口存在于<code>io</code>包中，查看一下它的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Reader interface &#123;</span><br><span class="line">Read(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Writer interface &#123;</span><br><span class="line">Write(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Reader和Writer接口是对文件的一个抽象，不一定是文件才能使用ReaderWriter接口，磁盘上的、网络上的都可以。</p><p>Go语言中的接口是由是由使用者定义的，实现者只需要实现其中的方法即可。</p><p><a href="https://www.jianshu.com/p/6a46fc7b6e5b" target="_blank" rel="noopener">go语言的类型断言(Type Assertion)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;接口&quot;&gt;&lt;a href=&quot;#接口&quot; class=&quot;headerlink&quot; title=&quot;接口&quot;&gt;&lt;/a&gt;接口&lt;/h1&gt;&lt;p&gt;本篇主要介绍Go语言中的特色功能面向接口，由于Go语言的面向对象只支持封装，因此需要借助于接口来实现类似于继承和多态的功能。&lt;/p&gt;
&lt;h1
      
    
    </summary>
    
      <category term="go" scheme="http://blog.licheetools.top/categories/go/"/>
    
    
      <category term="golang" scheme="http://blog.licheetools.top/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记（6）：面向对象</title>
    <link href="http://blog.licheetools.top/2019/05/13/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://blog.licheetools.top/2019/05/13/Go语言学习笔记（6）：面向对象/</id>
    <published>2019-05-13T03:08:39.000Z</published>
    <updated>2019-11-04T14:05:33.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p><strong>Go语言中的面向”对象”和其他语言非常不同，仅仅支持封装，不支持继承和多态。</strong>那么你可能要问了，仅仅依靠封装能实现一些较为复杂的事情么？Go语言通过接口和封装来实现较为复杂的事，所以更多的是成为接口编程。</p><p><strong>既然只有封装，就没有class(类)，只有struct(结构体)。</strong></p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>结构体是用户定义的类型，表示若干个字段的集合。当需要将多个数据分组到一个整体，而不是将每个数据作为单独的类型进行维护时，可以使用结构体。是不是有点类的概念？</p><h1 id="二分搜索树例子理解结构体知识"><a href="#二分搜索树例子理解结构体知识" class="headerlink" title="二分搜索树例子理解结构体知识"></a>二分搜索树例子理解结构体知识</h1><p>下面尝试通过一个二分搜索树的例子来介绍关于结构体的知识。二分搜索树分为3部分，某个节点的值，节点的左子树，节点的右子树。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2974a54dcd88fcca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>其实结构体的声明和面向对象中类的声明非常类似：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义一个二分搜索树</span><br><span class="line">type treeNode struct&#123;</span><br><span class="line">value int   //节点值为int类型</span><br><span class="line">left, right *treeNode  //左右子树为指针类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在声明好结构体后，接下来就是定义它了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var root treeNode                                       //定义一个二分搜索树对象</span><br><span class="line">root = treeNode&#123;value: 2&#125;                               //二分搜索树root节点初始化</span><br><span class="line">root.left = &amp;treeNode&#123;&#125;                                 //二分搜索树root节点左子树初始化</span><br><span class="line">root.right = &amp;treeNode&#123;value: 6, left: nil, right: nil&#125; //二分搜索树root节点右子树初始化</span><br><span class="line">//root.right = &amp;treeNode&#123;6,nil, nil&#125;   </span><br><span class="line">    root.left.left =new(treeNode)   //给二分搜索树root节点的左子树的左侧创建一个节点</span><br><span class="line"></span><br><span class="line">    nodes :=[]treeNode&#123;</span><br><span class="line">    &#123;value:3&#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">&#123;5,nil,nil&#125;,</span><br><span class="line">&#123;8,nil,&amp;root&#125;,</span><br><span class="line">&#125;</span><br><span class="line">    fmt.Println(nodes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">[&#123;3 &lt;nil&gt; &lt;nil&gt;&#125; &#123;0 &lt;nil&gt; &lt;nil&gt;&#125; &#123;5 &lt;nil&gt; &lt;nil&gt;&#125; &#123;8 &lt;nil&gt; 0xc000048420&#125;]</span><br></pre></td></tr></table></figure></p><p>你发现了么，声明结构体就相当于Java中的创建一个类，然后实例化这个结构体就是Java中类的实例化过程。<strong>在Go语言中，不论是地址还是结构体本身，一律使用<code>.</code>来访问成员。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var root treeNode                                       //定义一个二分搜索树对象</span><br><span class="line">root = treeNode&#123;value: 2&#125;                               //二分搜索树root节点初始化</span><br><span class="line">root.left = &amp;treeNode&#123;&#125;                                 //二分搜索树root节点左子树初始化</span><br><span class="line">root.right = &amp;treeNode&#123;value: 6, left: nil, right: nil&#125; //二分搜索树root节点右子树初始化</span><br><span class="line">//root.right = &amp;treeNode&#123;6,nil, nil&#125;   </span><br><span class="line">root.left.left =new(treeNode)   //给二分搜索树root节点的左子树的左侧创建一个节点</span><br></pre></td></tr></table></figure><p><strong>Go语言提供了很多实例化结构体的方法，因此结构体是没有构造方法的。</strong>当然如果你可以创建一个工厂方法用于实例化构造体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//用于创建一个结构体对象</span><br><span class="line">func createTreeNode(value int) *treeNode&#123;</span><br><span class="line">return &amp;treeNode&#123;value:value&#125;  //这是一个局部变量的地址，但是Go语言允许返回局部变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相信聪明的你发现这个<code>createTreeNode</code>函数返回了一个局部对象的地址，这在C++中是不允许的，但是Go语言支持允许返回局部变量地址。然后使用该方法创建一个结构体对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> root.left.right = createTreeNode(9)</span><br><span class="line">//运行结果：</span><br><span class="line">&amp;&#123;9 &lt;nil&gt; &lt;nil&gt;&#125;</span><br></pre></td></tr></table></figure></p><p>看到这里你可能会问，返回的局部对象是存在于堆上还是栈上呢？像C++，它的局部变量是分配在栈中，函数一旦退出，则局部变量会被销毁，只有定义在堆上的变量才能传递出去，不过这样就有一个麻烦，这个变量就需要你手动释放。而在Java中，通过New关键词生成的对象一般都在堆上，然后等到不使用的时候由垃圾回收机制回收。在Go语言中，你不需要知道它具体分配在何处，因为它是由Go语言编译器和运行环境决定的。</p><p>例如下面的<code>treeNode</code>没有取地址且不用返回出去，则这个<code>treeNode</code>可以在栈上分配它；当这个<code>treeNode</code>取了地址且返回出去给其他使用时，这个<code>treeNode</code>就可以在堆上分配，然后这个<code>treeNode</code>就会参与垃圾回收，当这个<code>treeNode</code>的指针不再使用的时候就会被回收。因此不能说函数退出这个局部变量就销毁了，这个在Go语言中是不一定的。既然能返回局部变量，那就不用考虑对象到底在哪里分配了，程序相对来说就好写一些：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func createTreeNode(value int) &#123;</span><br><span class="line">return treeNode&#123;value:value&#125;  //这是一个局部变量的地址，但是Go语言允许返回局部变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来猜猜这段代码，创建了一个怎样的二分搜索树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var root treeNode                                       </span><br><span class="line">root = treeNode&#123;value: 2&#125;                               </span><br><span class="line">root.left = &amp;treeNode&#123;&#125;                                </span><br><span class="line">root.right = &amp;treeNode&#123;6, nil, nil&#125; </span><br><span class="line">root.right.left =new(treeNode)  </span><br><span class="line">root.left.right = createTreeNode(9)</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-872a61e4f0ea48f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>接下来介绍如何遍历这个二分搜索树，但在此之前先介绍如何为结构体定义方法。注意结构体方法并不是写在结构体中的，而是写在结构体外面的，它有一个接收者，其他和普通函数差别不大：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//定义结构体方法，用于输出二分搜索树的信息</span><br><span class="line">func (tnode treeNode)print()&#123;</span><br><span class="line">fmt.Println(tnode.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意到这个<code>func (tnode treeNode)print(){}</code>没有？普通的方法都是<code>func print(){}</code>，这里多了由小括号包含的<code>(tnode treeNode)</code>，我们称之为接收者。其实也就是告诉我们这个函数就是<code>treeNode</code>对象使用的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.print()</span><br></pre></td></tr></table></figure></p><p>当然如果你理解不了这个意思，可以使用普通函数的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func uprint(tnode treeNode)&#123;</span><br><span class="line">fmt.Println(tnode.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprint(root)</span><br></pre></td></tr></table></figure></p><p>看到没有，这个就是区别，使用前者指定了接收者，故无需再次输入参数，使用后者则需传入指定参数。<strong>Go语言中只有值传递。</strong>我们尝试修改一下之前创建的那个空子树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.right.left =new(treeNode)   //给二分搜索树root节点的左子树的左侧创建一个节点</span><br></pre></td></tr></table></figure></p><p>就是上面那个，我们定义一个方法，看看能不能将其结点的值修改为8:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (tnode treeNode)setValue(value int)&#123;</span><br><span class="line">tnode.value=value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root.right.left.setValue(8)</span><br><span class="line">root.right.left.print()</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><p><strong>再次强调一点Go语言中只有值传递。</strong>因此这样做是无法修改<code>root.right.left</code>节点的值的，此时可以借助于指针来完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (tnode *treeNode)setValueByPointer(value int)&#123;</span><br><span class="line">tnode.value=value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root.right.left.setValue(8)</span><br><span class="line">root.right.left.print()</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">8</span><br></pre></td></tr></table></figure></p><p>通过指针传入对象（其实就是原来对象的地址，最后结果反映到原来对象上）就能修改其值。</p><p>总结一下为结构体定义方法，如下所示，注意就是将普通的函数返回到方法名称之前罢了，其实是普通方法没有什么区别？不过这样写能让大家一眼就能找到哪些是结构体方法，增强了辨识度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (tnode treeNode)print()&#123;</span><br><span class="line">fmt.Println(tnode.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>结构体定义方法显示定义和命名方法接收者，只有使用指针作为方法接收者时才能修改结构的内容。nil指针其实也是可以调用方法的</strong></p><p>怎么理解nil指针也可以调用方法呢？我们尝试进行一个判断，并输出后测试一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func (tnode *treeNode)setValueByPointer(value int)&#123;</span><br><span class="line">if tnode == nil&#123;</span><br><span class="line">fmt.Println(&quot;你传入的是空指针&quot;)</span><br><span class="line">&#125;</span><br><span class="line">tnode.value=value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var testnil *treeNode</span><br><span class="line">testnil.setValueByPointer(99999)</span><br><span class="line">testnil = &amp;root</span><br><span class="line">testnil.setValueByPointer(2345)</span><br><span class="line">testnil.print()</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">你传入的是空指针</span><br><span class="line">panic: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">[signal 0xc0000005 code=0x1 addr=0x0 pc=0x49122d]</span><br></pre></td></tr></table></figure></p><p>出错是意料之中的事，因为第一次传进去的<code>testnil</code>是一个空指针<code>nil</code>，而<code>setValueByPointer</code>函数是需要有返回值的，而空指针<code>nil</code>是没有值的，因此会报错，其实你只需要在里面添加一个<code>return</code>就可以的解决这个问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func (tnode *treeNode)setValueByPointer(value int)&#123;</span><br><span class="line">if tnode == nil&#123;</span><br><span class="line">fmt.Println(&quot;你传入的是空指针&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">tnode.value=value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">你传入的是空指针</span><br><span class="line">2345</span><br></pre></td></tr></table></figure></p><p>不过需要说明的是并不是每次都需要判断传入的对象是不是nil，然后才进行后续操作，这个需要结合具体场景来的。</p><p>接下来介绍如何遍历这个二分搜索树：（学过二分搜索树的人肯定知道中序遍历结果是0 9 2 0 6)：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-872a61e4f0ea48f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>采用中序遍历的方式（遍历方式的名称是由该节点的遍历顺序来决定的，节点在最前面是前序，中间是中序，最后是后序）因此这里的中序就是先遍历左子树，再遍历节点，最后遍历右子树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//二分搜索树的中序遍历,其实采用了递归的思想</span><br><span class="line">func (tnode *treeNode)reverse()&#123;</span><br><span class="line">if tnode ==nil&#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">tnode.left.reverse()</span><br><span class="line">tnode.print()</span><br><span class="line">tnode.right.reverse()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">0</span><br><span class="line">9</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p><p>结果和我们的预期完全吻合，但是你有没有我们只是判断了<code>tnode</code>节点是否是nil，但是对于其左右子树没有判断，事实上在JavaScript和Java中这个是不用判断的，但是C++中可能需要判断。</p><p>接下来谈谈<code>值接收者</code>和<code>指针接收者</code>的区别：<br>1、需要修改结构体内容的必须使用<code>指针接收者</code>；<br>2、当结果过大时，也必须使用<code>指针接收者</code>；<br>3、在具有<code>指针接收者</code>的情况下，建议都采用<code>指针接收者</code>；<br>4、<code>值接收者</code>是Go语言独有的；很多语言都有<code>指针接收者</code>如Python中的self，Java中的引用等；</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>接下来介绍封装，在Java中就是使用一些关键词如<code>private</code>、<code>default</code>、<code>protected</code>、<code>public</code>，按照前面的顺序，自上而下，访问范围越来越大；自下而上，限制能力越来越强，它们所控制的范围如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4bd5c8b69ee574fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>但是在Go语言中就不一样了，Go语言通过函数的名字来进行范围控制的，名字一般使用CamelCase。<strong>首字母大写表示public，首字母小写表示private，这两个都是针对包而言的</strong></p><p><strong>包<code>package main</code>这个就是一个main包，默认使用的就是这个<code>main</code>包，<code>main</code>包包含了可执行入口。在Go语言中，每个目录都只能有一个包，包名不一定要和目录名一致。为结构体定义的方法必须放在同一个包内。</strong></p><p>尝试将之前的关于二分搜索树的代码拆分成不同的文件，然后进行导包操作：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-719ad9cd28616aee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>tree包里面包含一个包entry和文件node.go，而entry包中又包含entry.go文件。其中entry.go中只含有main方法，定义前面package为main包，当然也可以定义为entry包（每个目录都只能有一个包，包名不一定要和目录名一致。），但是我们只是让他运行main方法，因此定义package为main包。既然这样设置，那么以后包entry所有的go文件的package都必须是mian，否则会出错。同样外面的node.go文件中的package定义为tree包，因此以后tree文件里面所有go文件的package都必须定义为tree！</p><h3 id="扩展已有类型"><a href="#扩展已有类型" class="headerlink" title="扩展已有类型"></a>扩展已有类型</h3><p>现在有一个问题，就是你在开发过程中需要使用别人的包，那应该怎样使用呢？也就是如何扩展系统类型或别人的类型呢？你可以使用<strong>别名</strong>或者<strong>组合</strong>来解决这个问题。</p><p>这个需要配置GoPATH环境变量的，默认情况unix和linux是在<code>，~/go</code>下，Windows是在<code>%USERPROFILE%\go</code>。官方建议所有项目和第三方库都放在同一个GoPATH下面，但也可以将每个项目放在不同的GoPATH下面。Go语言会在编译时去各个GoPATH中找到不同的包。</p><h3 id="Go语言导包正确操作"><a href="#Go语言导包正确操作" class="headerlink" title="Go语言导包正确操作"></a>Go语言导包正确操作</h3><p>那么如何保证自己的go语言程序能正常运行呢？下面教大家如何设置(假设我准备所有go项目存放在<code>I:\Go\GoTest</code>文件夹下面，而我的Go语言安装在<code>G:\Applications\Go</code>文件夹下面):</p><p><strong>第一步：</strong>在<code>I:\Go\GoTest</code>文件夹下面新建<code>src</code>文件夹，注意必须是这个名字，不能随意修改；</p><p><strong>第二步：</strong>设置环境变量<code>GOROOT=G:\Applications\Go</code>（其实就是Go语言安装路径）和<code>Path=G:\Applications\Go\bin;</code>及<code>GOPATH=I:\Go\GoTest</code>（项目存放的地址，注意不能写成<code>I:\Go\GoTest\src</code>，仅仅写到<code>GoTest</code>文件夹为止）。</p><p><strong>第三步：</strong>配置GoLand参数，File–&gt;Settings–&gt;Go，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8b210fdd66eac33e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-362b3448eb005a17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>之后点击确认，可能需要重启GoLand，然后使用Alt+Enter键就能实现自动导包了！</p><h3 id="获取第三方库"><a href="#获取第三方库" class="headerlink" title="获取第三方库"></a>获取第三方库</h3><p>接下来介绍如何获取Go语言的第三方库。在Python中你可以使用<code>pip install +库名</code>的方式，而在Go语言中可以使用<code>go get +库名</code>的办法。但是直接从谷歌服务器上下载库在国内似乎不行，这时推荐使用<code>gopm +库名</code>的方式:</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-054ed1ac1c14ff9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>需要说明的是<code>go get</code>是内置的命令，而<code>gopm</code>是第三方工具，因此在使用前需要使用<code>go get</code>来安装<code>gopm</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/gpmgo/gopm</span><br></pre></td></tr></table></figure></p><p>之后会在你的src文件夹里面多了两个新的文件夹<code>bin</code>和<code>github.com</code>：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-1201ffa9f4355823.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>还记得前面设置的<code>Path=G:\Applications\Go\bin;</code>这个环境变量么，打开该文件夹发现里面都是可执行的exe文件：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b002fa43a92841e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>而我们刚才生成的bin目录下有一个<code>gopm.exe</code>，因此需要将这个gopm.exe复制到<br><code>G:\Applications\Go\bin</code>文件夹下面才能保证其正常运行。如果你觉得这种操作很麻烦可以直接修改path参数为<code>Path=%GOPATH%\bin;</code>这样就不需要导入了，那这样我们GOROOT下面的bin目录中的go、godoc、gofmt就无法正常运行了，那没事因为我们用到它的时候不多，手动使用他们也是可以接受的。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b002fa43a92841e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这个src文件夹里面会存有你的项目和你下载的第三方库。关于Go内置的一些其他命令可以查看这里<a href="https://www.bookstack.cn/books/go_command_tutorial" target="_blank" rel="noopener">GO 命令教程</a>。</p><p>下面介绍gopm的使用。其实也是使用<code>gopm get+库名</code>的方式，当然还可以使用<code>gopm help</code>查看各种参数实现自定义下载位置配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">NAME:</span><br><span class="line">   Gopm - Go Package Manager</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   Gopm [global options] command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">VERSION:</span><br><span class="line">   0.8.8.0307 Beta</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">   list         list all dependencies of current project</span><br><span class="line">   gen          generate a gopmfile for current Go project</span><br><span class="line">   get          fetch remote package(s) and dependencies</span><br><span class="line">   bin          download and link dependencies and build binary</span><br><span class="line">   config       configure gopm settings</span><br><span class="line">   run          link dependencies and go run</span><br><span class="line">   test         link dependencies and go test</span><br><span class="line">   build        link dependencies and go build</span><br><span class="line">   install      link dependencies and go install</span><br><span class="line">   clean        clean all temporary files</span><br><span class="line">   update       check and update gopm resources including itself</span><br><span class="line">   help, h      Shows a list of commands or help for one command</span><br><span class="line"></span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line">   --noterm, -n         disable color output</span><br><span class="line">   --strict, -s         strict mode</span><br><span class="line">   --debug, -d          debug mode</span><br><span class="line">   --help, -h           show help</span><br><span class="line">   --version, -v        print the version</span><br></pre></td></tr></table></figure></p><p>还可以使用<code>go build</code>来编译，使用<code>go install</code>会产生pkg文件和可执行文件；使用<code>go run</code>会直接编译且运行。</p><p>其实看到这里有一个非常大的问题，就是有些文件夹里面有多个main方法的入口，这是不允许的，特别是在<code>go build</code>时候，因此建议一个文件夹下面就仅仅只有一个go程序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Go语言中的面向”对象”和其他语言非常不同，仅仅支持封装，不支持继承和多态。&lt;/strong&gt;那么你可能要问
      
    
    </summary>
    
      <category term="go" scheme="http://blog.licheetools.top/categories/go/"/>
    
    
      <category term="golang" scheme="http://blog.licheetools.top/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记（4）：内建容器之数组、切片</title>
    <link href="http://blog.licheetools.top/2019/05/12/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9A%E5%86%85%E5%BB%BA%E5%AE%B9%E5%99%A8%E4%B9%8B%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87/"/>
    <id>http://blog.licheetools.top/2019/05/12/Go语言学习笔记（4）：内建容器之数组、切片/</id>
    <published>2019-05-12T13:58:57.000Z</published>
    <updated>2019-11-04T14:04:11.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本篇笔记主要介绍内建容器相关的知识，具体包括数组和切片等内容。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>Go语言中的数组和其他语言中的数组差不多，都是只能存放同一类型的数据。创建数组有多种方式，这里推荐几种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">//创建数组的第一种方式</span><br><span class="line">var array1 [6] int</span><br><span class="line">//创建数组的第二种方式,需要写出具体的数组内容</span><br><span class="line">array2 := [3] int &#123;1,2,3&#125;</span><br><span class="line">//创建数组的第二种方式,不需要写出具体的数组内容，...表示让编译器来帮我们数有几个int</span><br><span class="line">array3 := [...] int &#123;1,2,3,4,5,6,7,8&#125;</span><br><span class="line"></span><br><span class="line">//定义一个二维数组，2行3列为int类型的数组</span><br><span class="line">var twoarray [2][3] int</span><br><span class="line"></span><br><span class="line">fmt.Println(array1, array2, array3)</span><br><span class="line">fmt.Println(twoarray)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">[0 0 0 0 0 0] [1 2 3] [1 2 3 4 5 6 7 8]</span><br><span class="line">[[0 0 0] [0 0 0]]</span><br></pre></td></tr></table></figure></p><p><strong>注使用<code>:=</code>操作符时，需要指明具体的数组内容。Go语言数组规范和其他有点不同，数量写在类型前面。</strong></p><p>接下来是数组的遍历，借鉴于其他语言的遍历方式非常容易想到这种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//创建数组的第二种方式,不需要写出具体的数组内容，...表示让编译器来帮我们数有几个int</span><br><span class="line">array3 := [...] int &#123;2,4,6,8,10,12&#125;</span><br><span class="line">//一般的数组变量遍历方式</span><br><span class="line">for i:=0;i&lt;len(array3);i++&#123;</span><br><span class="line">fmt.Println(array3[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br><span class="line">12</span><br></pre></td></tr></table></figure></p><p>前面使用过<code>range</code>这个关键词，它可以直接获取数组的下标：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    //创建数组的第二种方式,不需要写出具体的数组内容，...表示让编译器来帮我们数有几个int</span><br><span class="line">array3 := [...] int &#123;2,4,6,8,10,12&#125;</span><br><span class="line">    //使用range关键词遍历数组</span><br><span class="line">    for i:=range array3&#123;</span><br><span class="line">fmt.Println(array3[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br><span class="line">12</span><br></pre></td></tr></table></figure></p><p>也可以直接输出下标和元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//创建数组的第二种方式,不需要写出具体的数组内容，...表示让编译器来帮我们数有几个int</span><br><span class="line">array3 := [...] int &#123;2,4,6,8,10,12&#125;</span><br><span class="line"></span><br><span class="line">//使用range关键词遍历数组，且输出数组下标和元素</span><br><span class="line">for i,v:=range array3&#123;</span><br><span class="line">fmt.Println(i ,v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">0 2</span><br><span class="line">1 4</span><br><span class="line">2 6</span><br><span class="line">3 8</span><br><span class="line">4 10</span><br><span class="line">5 12</span><br></pre></td></tr></table></figure></p><p>如果只需要数值，不需要下标，可以使用<code>_</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//使用匿名变量来传递</span><br><span class="line">for _, v := range array3&#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br><span class="line">12</span><br></pre></td></tr></table></figure></p><p>也就是可通过<code>_</code>来省略变量，不仅在<code>range</code>，任何地方都可以通过<code>_</code>来省略变量，当然如果只需要i(下标)，只需要写成：<code>for i :=range numbers</code>的形式。</p><p><strong>这个<code>range</code>不仅仅是Go语言所具有的，Java和Python中也有(C++中没有) ，不过只能是for each value，而不能同时获取i，v对象。</strong></p><p><strong>数组是值类型。</strong>怎么理解这句话呢？往下看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func printArray(array [6] int)&#123;</span><br><span class="line">//使用匿名变量来传递</span><br><span class="line">for _, v := range array&#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">//创建数组的第一种方式</span><br><span class="line">var array1 [6] int</span><br><span class="line">//创建数组的第二种方式,需要写出具体的数组内容</span><br><span class="line">array2 := [3] int &#123;1,2,3&#125;</span><br><span class="line">//创建数组的第二种方式,不需要写出具体的数组内容，...表示让编译器来帮我们数有几个int</span><br><span class="line">array3 := [...] int &#123;2,4,6,8,10,12&#125;</span><br><span class="line">    printArray(array1)</span><br><span class="line">printArray(array2)</span><br><span class="line">printArray(array3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">cannot use array2 (type [3]int) as type [6]int in argument to printArray</span><br></pre></td></tr></table></figure></p><p>也就是在Go语言中，因为是值传递，因此array [6]int与array [7]int是不同的类型。调用<code>func test(array [10] int)</code>会拷贝数组，这种情况和大部分的编程语言是不相同的，因为大部分传递数组都是引用传递，可以改变数组中元素的值，但是Go语言不行。</p><p>现在我们尝试修改一下数组的第一个元素信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func printArray(array [6] int)&#123;</span><br><span class="line">array[0] = 99999999</span><br><span class="line">//使用匿名变量来传递</span><br><span class="line">for _, v := range array&#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">//创建数组的第一种方式</span><br><span class="line">var array1 [6] int</span><br><span class="line">//创建数组的第二种方式,不需要写出具体的数组内容，...表示让编译器来帮我们数有几个int</span><br><span class="line">array3 := [...] int &#123;2,4,6,8,10,12&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;导入printTest函数后&quot;)</span><br><span class="line">    printArray(array1)</span><br><span class="line">fmt.Println(&quot;****************************************&quot;)</span><br><span class="line">printArray(array3)</span><br><span class="line">fmt.Println(&quot;再次打印array1和array2&quot;)</span><br><span class="line">fmt.Println(array1,array3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">导入printTest函数后</span><br><span class="line">99999999</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">****************************************</span><br><span class="line">99999999</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br><span class="line">12</span><br><span class="line">再次打印array1和array2</span><br><span class="line">[0 0 0 0 0 0] [2 4 6 8 10 12]</span><br></pre></td></tr></table></figure></p><p>运行结果发现你只是对传进去的参数进行了修改，对于array1和array2而言其实还是没什么变化。 </p><p>如果你非得修改原来的对象，可以借助于指针，修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func printArray(array *[6] int)&#123;  //添加指针</span><br><span class="line">array[0] = 99999999</span><br><span class="line">//使用匿名变量来传递</span><br><span class="line">for _, v := range array&#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">//创建数组的第一种方式</span><br><span class="line">var array1 [6] int</span><br><span class="line">//创建数组的第二种方式,不需要写出具体的数组内容，...表示让编译器来帮我们数有几个int</span><br><span class="line">array3 := [...] int &#123;2,4,6,8,10,12&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;导入printTest函数后&quot;)</span><br><span class="line">printArray(&amp;array1)  //取地址</span><br><span class="line">fmt.Println(&quot;****************************************&quot;)</span><br><span class="line">printArray(&amp;array3)  //取地址</span><br><span class="line">fmt.Println(&quot;再次打印array1和array2&quot;)</span><br><span class="line">fmt.Println(array1,array3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">导入printTest函数后</span><br><span class="line">99999999</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">****************************************</span><br><span class="line">99999999</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br><span class="line">12</span><br><span class="line">再次打印array1和array2</span><br><span class="line">[99999999 0 0 0 0 0] [99999999 4 6 8 10 12]</span><br></pre></td></tr></table></figure></p><p>上面只是<code>*[6] int</code>添加了指针，然后在array1和array3前加<code>&amp;</code>取地址，进而完成了数组元素的修改。<strong>其实，在Go语言中一般不直接使用数组，也不使用数组的指针，而是使用切片。</strong></p><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>切片slice，在很多语言中都有。来看一段代码，提前了解一下什么是slice切片：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array1 := [...]int&#123;1,3,5,7,9,11,13&#125;</span><br><span class="line">s := array1[2:6]</span><br></pre></td></tr></table></figure></p><p>其实这个<code>s</code>就是一个slice，如果之前学过python或者其他语言的话就非常好理解这个slice了，slice都是左闭右开，也就是[2:6]表示取第2,3,4,5个元素，不包括第6个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">array1 := [...]int&#123;1,3,5,7,9,11,13&#125;</span><br><span class="line">fmt.Println(&quot;array1[2:6] is：&quot;,array1[2:6])   // [5 7 9 11]</span><br><span class="line">fmt.Println(&quot;array1[:6] is：&quot;,array1[:6])  // [1 3 5 7 9 11]</span><br><span class="line">fmt.Println(&quot;array1[2:] is：&quot;,array1[2:])  // [5 7 9 11 13]</span><br><span class="line">fmt.Println(&quot;array1[:] is：&quot;,array1[:])  //  [1 3 5 7 9 11 13]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意和Python中的切片不同，你最大数值不能超出数组的个数，也就是说使用<code>[2:7]</code>是可以的，因为7取不到，但是如果使用<code>[2:8]</code>就会报错，（言外之意，最开始更不能大于数组的个数了）这一点需要注意。</p><p>那么你可能要问这个切片到底是什么？其实这个切片就是对于某个数组的一个视图，这个视图非常灵活。在方法中定义参数的时候，如果不带具体的数字，其实这就是一个视图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func updateSlice(s [] int)&#123;</span><br><span class="line">s[0] = 999</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">array1 := [...]int&#123;1,3,5,7,9,11,13&#125;</span><br><span class="line"></span><br><span class="line">s1 := array1[5:]</span><br><span class="line">fmt.Println(&quot;array[5:] is:&quot;,s1)</span><br><span class="line">s2 := array1[:]</span><br><span class="line">fmt.Println(&quot;array[:] is:&quot;,s2)</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;s1切片后：&quot;)</span><br><span class="line">updateSlice(s1)</span><br><span class="line">fmt.Println(s1)</span><br><span class="line">fmt.Println(array1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;s2切片后：&quot;)</span><br><span class="line">updateSlice(s2)</span><br><span class="line">fmt.Println(s2)</span><br><span class="line">fmt.Println(array1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">array[5:] is: [11 13]</span><br><span class="line">array[:] is: [1 3 5 7 9 11 13]</span><br><span class="line">s1切片后：</span><br><span class="line">[999 13]</span><br><span class="line">[1 3 5 7 9 999 13]</span><br><span class="line">s2切片后：</span><br><span class="line">[999 3 5 7 9 999 13]</span><br><span class="line">[999 3 5 7 9 999 13]</span><br></pre></td></tr></table></figure></p><p>看到没有，这个切片是原来数组的一个视图，通过修改这个视图进而达到修改原数组的目的，Go语言中的切片和其他语言的切片差别很大，需要仔细体会一下其中的设计思想。<strong>slice本身没有数据，是对底层数组的一个视图view</strong>。你会发现一个非常有意思的现象：Go语言支持多次slice，你可以在slice上面再次进行slice，但是最终都会反映到原来数组的修改上，这一点非常重要。</p><p>slice支持多次slice，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">//slice的扩展</span><br><span class="line">arraytest := [...] int&#123;2,4,6,8,10,12,14&#125;</span><br><span class="line">s1 := arraytest[2:5] </span><br><span class="line">s2 := s1[3:5] </span><br><span class="line"></span><br><span class="line">fmt.Println(s1)</span><br><span class="line">fmt.Println(s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">[6 8 10]</span><br><span class="line">[12 14]</span><br></pre></td></tr></table></figure></p><p>为什么会是这样呢？难道s2取的不是s1[3]和s1[4]的值么？输出一下看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(s1[3])</span><br><span class="line">fmt.Println(s1[4])</span><br><span class="line">//运行结果：</span><br><span class="line">panic: runtime error: index out of range</span><br></pre></td></tr></table></figure></p><p>居然报了索引越界这个错误，因此这里的<code>s1[3:5]</code>取的根本就不是s1[3]和s1[4]的值!那它取的到底是什么呢？</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-743b9ee6a9be7b29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>当你使用s1的时候，它是对arraytest数组的一个视图，表面上只有6,8,10这三个元素，实际上还有不可见的12和14也在这个视图中。然后使用s2的时候，发现这个看不见的两个元素满足条件就返回。因此这里的s2的取值范围不得超过这个看不见的数值。其实在数据结构中就会发现这里看不见的元素其实就是容量与实际数量的差值。</p><p>通过资料发现slice的底层实现：</p><p>ptr表示slice的开头元素；len是可见的长度，即使用<code>[]</code>取值只能在这个范围内，否则引发索引越界错误；cap是容量，只要在这个容量内都是可以扩展的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-f11df784f2a8e1c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><strong>slice可以向后扩展，但不可以向前扩展。s[i]不能越过len(s)，向后扩展可超越len(s)，但不可以超越底层数组cap(s)。</strong></p><p>尝试输出一下之前例子的len和cap信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">//slice的扩展</span><br><span class="line">arraytest := [...] int&#123;2,4,6,8,10,12,14&#125;</span><br><span class="line">s1 := arraytest[2:5] </span><br><span class="line">s2 := s1[3:5]  </span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;arraytest:&quot;,arraytest)</span><br><span class="line">fmt.Printf(&quot;s1=%v, len(s1)=%d, cap(s1)=%d&quot;,s1, len(s1), cap(s1))</span><br><span class="line">fmt.Println(&quot;\n&quot;)</span><br><span class="line">fmt.Printf(&quot;s2=%v, len(s2)=%d, cap(s2)=%d&quot;,s2, len(s2), cap(s2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">arraytest: [2 4 6 8 10 12 14]</span><br><span class="line">s1=[6 8 10], len(s1)=3, cap(s1)=5</span><br><span class="line"></span><br><span class="line">s2=[12 14], len(s2)=2, cap(s2)=2</span><br></pre></td></tr></table></figure></p><h1 id="切片操作之添加元素"><a href="#切片操作之添加元素" class="headerlink" title="切片操作之添加元素"></a>切片操作之添加元素</h1><p>接下来介绍如何网切片中添加元素，看一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">arraytest := [...] int&#123;2,4,6,8,10,12,14,16&#125;</span><br><span class="line">s1 := arraytest[2:5]  //[6 8 10]</span><br><span class="line">s2 := s1[3:5]  //s1[3]和s1[4]的值， [12 14]</span><br><span class="line">s3:=append(s2, 88)</span><br><span class="line"></span><br><span class="line">//s4和s5不再是对原来数组的一个视图view</span><br><span class="line">s4:=append(s3, 99)</span><br><span class="line">s5:=append(s4,66)</span><br><span class="line"></span><br><span class="line">fmt.Println(s1)</span><br><span class="line">fmt.Println(s2)</span><br><span class="line">fmt.Println(s3)</span><br><span class="line">fmt.Println(s4)</span><br><span class="line">fmt.Println(s5)</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;**********************&quot;)</span><br><span class="line">fmt.Println(arraytest)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">[6 8 10]</span><br><span class="line">[12 14]</span><br><span class="line">[12 14 88]</span><br><span class="line">[12 14 88 99]</span><br><span class="line">[12 14 88 99 66]</span><br><span class="line">**********************</span><br><span class="line">[2 4 6 8 10 12 14 88]</span><br></pre></td></tr></table></figure></p><p>此处的arraytest中具有8个元素，<code>s1 := arraytest[2:5]</code>输出[6 8 10]，但是其实前面也说了里面其实是包括了看不见的其余3个元素，因此我们心里面知道它的值是[6 8 10 12 14 16]就行，然后<code>s2 := s1[3:5]</code>表面上输出的是[12 14]，其实心里面也知道它的值是[12 14 16]，接着使用append方法，查看一下append方法的源码可知：<code>func append(slice []Type, elems ...Type) []Type</code>然后添加88，你会发现它会将原有的16进行替换，因为这个appen其实也是在len范围内，也就是可见范围内修改，不可见的元素当做不存在，进而进行替换。</p><p><strong>但是向slice中添加元素，若超过cap容量时，此时系统会重新分配更大的底层数组，若此时原来的数组不使用，则会被Go的垃圾回收机制给回收。</strong></p><p> <code>s4:=append(s3, 99)</code>和 <code>s5:=append(s4,66)</code>因为追加的元素超过了原来数组的cap，因此它们都不再是对原来数组的一个视图view了。</p><p>由于Go语言中的值传递，因此必须append的返回值，如s=append(s,val)。</p><h1 id="切片操作之创建切片"><a href="#切片操作之创建切片" class="headerlink" title="切片操作之创建切片"></a>切片操作之创建切片</h1><p>之前使用的切片都是借助于数组来的，接下来介绍如何直接创建切片。<strong>第一种var方式</strong>，看一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var s [] int //创建一个切片，如果不赋值则默认为空值nil</span><br><span class="line">fmt.Println(s==nil)  //true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">true</span><br></pre></td></tr></table></figure></p><p>接下来尝试给这个nil的切片赋值，使之包含20以内的奇数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var s [] int</span><br><span class="line">for i:=0;i&lt;10;i++&#123;</span><br><span class="line">s=append(s,2*i+1)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">[1 3 5 7 9 11 13 15 17 19]</span><br></pre></td></tr></table></figure></p><p>但是我们并不知道这个切片的<code>len</code>和<code>cap</code>，这时可以定义一个函数用于及时输出相关信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func printSlice(s [] int)&#123;</span><br><span class="line">fmt.Printf(&quot;len(s)=%d, cap(s)=%d\n&quot;,len(s),cap(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var s [] int</span><br><span class="line">for i:=0;i&lt;10;i++&#123;</span><br><span class="line">printSlice(s)</span><br><span class="line">s=append(s,2*i+1)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">len(s)=0, cap(s)=0</span><br><span class="line">len(s)=1, cap(s)=1</span><br><span class="line">len(s)=2, cap(s)=2</span><br><span class="line">len(s)=3, cap(s)=4</span><br><span class="line">len(s)=4, cap(s)=4</span><br><span class="line">len(s)=5, cap(s)=8</span><br><span class="line">len(s)=6, cap(s)=8</span><br><span class="line">len(s)=7, cap(s)=8</span><br><span class="line">len(s)=8, cap(s)=8</span><br><span class="line">len(s)=9, cap(s)=16</span><br><span class="line">[1 3 5 7 9 11 13 15 17 19]</span><br></pre></td></tr></table></figure></p><p>我们发现刚定义的空切片其len和cap都是0，但是并不会报错，其实就相当于<code>nil</code>。你是不是还发现这个cap是根据2的幂数来进行扩容的，当2的某个幂数被占满时就扩容至下一个幂数。</p><p><strong>第二种<code>：=</code>方式</strong>，针对不同的场景使用不同的方式创建slice，来看一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func printSlice(s [] int)&#123;</span><br><span class="line">fmt.Printf(&quot;value=%v,len(s)=%d, cap(s)=%d\n&quot;,s, len(s),cap(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">s1 := []int &#123;1,2,3,4,5&#125;  //知道slice的类型及具体数值</span><br><span class="line">printSlice(s1)</span><br><span class="line"></span><br><span class="line">s2:= make([]int ,8)  //知道slice的类型，不知道具体的数值,一个参数表示len和cap是一样的</span><br><span class="line">printSlice(s2)</span><br><span class="line"></span><br><span class="line">s3:=make([]int ,6, 12) //知道slice的类型，不知道具体的长度和容量,两个参数前者是len，后者是cap</span><br><span class="line">printSlice(s3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">value=[1 2 3 4 5],len(s)=5, cap(s)=5</span><br><span class="line">value=[0 0 0 0 0 0 0 0],len(s)=8, cap(s)=8</span><br><span class="line">value=[0 0 0 0 0 0],len(s)=6, cap(s)=12</span><br></pre></td></tr></table></figure></p><p>再来查看一下make方法的源码：<code>func make(t Type, size ...IntegerType) Type</code>，我们可以知道make方法第一个参数是类型，之后都是Integer类型，最后返回的是Type类型，make的作用很大，看一下源码中的解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// The make built-in function allocates and initializes an object of type</span><br><span class="line">// slice, map, or chan (only). Like new, the first argument is a type, not a</span><br><span class="line">// value. Unlike new, make&apos;s return type is the same as the type of its</span><br><span class="line">// argument, not a pointer to it. The specification of the result depends on</span><br><span class="line">// the type:</span><br><span class="line">//Slice: The size specifies the length. The capacity of the slice is</span><br><span class="line">//equal to its length. A second integer argument may be provided to</span><br><span class="line">//specify a different capacity; it must be no smaller than the</span><br><span class="line">//length. For example, make([]int, 0, 10) allocates an underlying array</span><br><span class="line">//of size 10 and returns a slice of length 0 and capacity 10 that is</span><br><span class="line">//backed by this underlying array.</span><br><span class="line">//Map: An empty map is allocated with enough space to hold the</span><br><span class="line">//specified number of elements. The size may be omitted, in which case</span><br><span class="line">//a small starting size is allocated.</span><br><span class="line">//Channel: The channel&apos;s buffer is initialized with the specified</span><br><span class="line">//buffer capacity. If zero, or the size is omitted, the channel is</span><br><span class="line">//unbuffered.</span><br></pre></td></tr></table></figure></p><h1 id="切片操作之复制切片"><a href="#切片操作之复制切片" class="headerlink" title="切片操作之复制切片"></a>切片操作之复制切片</h1><p>接下来介绍如何复制切片，这个其实非常简单，看一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func printSlice(s [] int)&#123;</span><br><span class="line">fmt.Printf(&quot;value=%v,len(s)=%d, cap(s)=%d\n&quot;,s, len(s),cap(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">s1 := []int &#123;1,2,3,4,5&#125;  //知道slice类型及具体数值，[1 2 3 4 5]</span><br><span class="line">s2:= make([]int ,8)  //知道slice类型，不知道具体数值,一个参数表示len和cap的数值，[0 0 0 0 0 0 0 0]</span><br><span class="line"></span><br><span class="line">a:=copy(s2 ,s1)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">fmt.Println(s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">5  //返回的是源切片长度和目标切片长度中最小的那个。</span><br><span class="line">[1 2 3 4 5 0 0 0]</span><br></pre></td></tr></table></figure></p><p>我们查看一下copy函数的源码：<code>func copy(dst, src []Type) int</code>可以发现它的作用是从源切片复制元素到目标切片。而且它也会从一个字符串中复制字节到一个字节类型的切片里面。源切片和目标切片可能会溢出，最后copy函数返回的是源切片长度和目标切片长度中最小的那个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// The copy built-in function copies elements from a source slice into a</span><br><span class="line">// destination slice. (As a special case, it also will copy bytes from a</span><br><span class="line">// string to a slice of bytes.) The source and destination may overlap. Copy</span><br><span class="line">// returns the number of elements copied, which will be the minimum of</span><br><span class="line">// len(src) and len(dst).</span><br></pre></td></tr></table></figure></p><h1 id="切片操作之删除切片"><a href="#切片操作之删除切片" class="headerlink" title="切片操作之删除切片"></a>切片操作之删除切片</h1><p>创建切片后，如果想删除它应该怎样操作呢？接下来就介绍如何删除切片，不过大家需要明确Go语言中的delete方法不适用于切片，只适用于Map，因此这里的删除操作就不能使用直接delete函数，但是还是有方法。</p><h3 id="删除切片中间元素"><a href="#删除切片中间元素" class="headerlink" title="删除切片中间元素"></a>删除切片中间元素</h3><p>在前面介绍切片的时候说过切片的好处就是可以随意取值，然后拼接不就可以了么。例如现在有一个切片<code>[1 2 3 4 5 0 0 0]</code>，想删除其中数值为5的元素，我们应该怎么做呢？可以取[1 2 3 4]和[0 0 0]啊，然后拼起来呀<code>s2[:4] +s2[5:]</code>但是Go语言的切片不支持<code>+</code>操作，可以使用<code>append</code>方法，但是前面也说过<code>append</code>方法的源码<code>func append(slice []Type, elems ...Type) []Type</code>，第一个参数是切片，之后其余参数都是元素，而不是一个切片，因此我们需要将<code>s2[5:]</code>中所包含的[0 0 0]作为参数传进去，当然这里只有3个参数，如果有更多就不能使用这种枚举法来了，此时可以使用<code>s2[5:]...</code>的方式，这样就直接获取了<code>s2[5:]</code>中包含的所有参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(&quot;切片删除操作&quot;)</span><br><span class="line">s5:=[]int &#123;1,2,3,4,5,0,0,0&#125;  //[1 2 3 4 5 0 0 0]</span><br><span class="line">//删除其中数值为5的元素，可以取[1 2 3 4]和[0 0 0]啊，s2[:4] +s2[5:]</span><br><span class="line">s6 :=append(s5[:4],s5[5:]...)</span><br><span class="line">fmt.Println(s6)</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">[1 2 3 4 5 0 0 0]</span><br><span class="line">切片删除操作</span><br><span class="line">[1 2 3 4 0 0 0]</span><br></pre></td></tr></table></figure></p><h3 id="删除切片首尾元素"><a href="#删除切片首尾元素" class="headerlink" title="删除切片首尾元素"></a>删除切片首尾元素</h3><p>其实原理和删除中间元素一致，需要注意的是Go语言中没有Python中的<code>-1</code>概念，下标只能从0开始往后读，不能从后往前读：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s8:=[]int &#123;1,2,3,4,5,0,0,0&#125;  //[1 2 3 4 5 0 0 0]</span><br><span class="line">s9:=s8[:1]</span><br><span class="line">s10:=s8[1:]</span><br><span class="line">fmt.Println(s9,s10)</span><br><span class="line"></span><br><span class="line">s11:=s8[len(s8)-1:]</span><br><span class="line">s12:=s8[:len(s8)-1]</span><br><span class="line">fmt.Println(s11,s12)</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">[1 2 3 4 5 0 0 0]</span><br><span class="line">[1] [2 3 4 5 0 0 0]</span><br><span class="line">[0] [1 2 3 4 5 0 0]</span><br></pre></td></tr></table></figure></p><p>至此关于数组和切片的操作就到此为止，下一篇介绍Map、字符和字符串。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本篇笔记主要介绍内建容器相关的知识，具体包括数组和切片等内容。&lt;/p&gt;
&lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; 
      
    
    </summary>
    
      <category term="go" scheme="http://blog.licheetools.top/categories/go/"/>
    
    
      <category term="golang" scheme="http://blog.licheetools.top/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记（3）：程序结构</title>
    <link href="http://blog.licheetools.top/2019/05/11/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"/>
    <id>http://blog.licheetools.top/2019/05/11/Go语言学习笔记（3）：程序结构/</id>
    <published>2019-05-11T13:58:43.000Z</published>
    <updated>2019-11-04T14:03:33.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本篇笔记主要介绍程序结构相关的知识，具体包括条件语句、循环、函数和指针等内容。</p><h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>给定一个自然数v，如果它在0-100之间则返回v，若大于100则返回100，小于0则返回0，使用Go语言实现的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func ifTest(v int) int&#123;</span><br><span class="line">if v &gt;100 &#123;   //if的条件里面不需要括号</span><br><span class="line">return 100</span><br><span class="line">&#125;else if v &lt;0 &#123;</span><br><span class="line">return 0</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var a int = ifTest(5)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p><p><strong>注意到没有if的条件里面不需要括号，创建的文件中不能包含下划线。</strong><code>func ifTest(v int) int</code>中参数v的前面不需要添加<code>var</code>关键词，后面的int则是该函数的返回结果。</p><p>现在来使用Go语言来读取某个文件的信息，如<code>test.txt</code>中的内容，相应的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;io/ioutil&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func readFieTest()&#123;</span><br><span class="line">const filename  =  &quot;test.txt&quot;</span><br><span class="line">contents, errorinfo :=ioutil.ReadFile(filename)   </span><br><span class="line">//var contents ,errorinfo = ioutil.ReadFile(filename)</span><br><span class="line">if errorinfo != nil &#123;   </span><br><span class="line">fmt.Println(errorinfo)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">fmt.Printf(&quot;%s\n&quot;,contents)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">readFieTest()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>读取文件需要采用ioutil包中的ReadFile函数，查看源码可知该函数一次可以返回两个值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func ReadFile(filename string) ([]byte, error) &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>if errorinfo != nil</code>中的nil就是无的意思，此处就是产生了错误，可以参考这篇文章了解更多关于nil的信息：<a href="https://blog.csdn.net/zf766045962/article/details/81005037" target="_blank" rel="noopener">理解Go语言的nil </a>。其实上面那种方式不是很简介，可以使用类似于Java中的三元表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;io/ioutil&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func readFieTest()&#123;</span><br><span class="line">const filename  =  &quot;test.txt&quot;</span><br><span class="line">if contents, errorinfo := ioutil.ReadFile(filename) ;errorinfo != nil &#123;  </span><br><span class="line">//先运行前半句后进行判断</span><br><span class="line">fmt.Println(errorinfo)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">fmt.Printf(&quot;%s&quot;,contents)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">readFieTest()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现没有if的条件里可以进行赋值，且if条件里赋值的变量作用域就是这个if语句。接下来聊一聊switch，很多语言中都有switch。</p><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>switch后面是可以接表达式的（也可以不接），使用Go实现计算某两个整数的加减乘除的功能，相应的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func eval(a, b int,operation string) int &#123;</span><br><span class="line">var result int</span><br><span class="line">switch operation &#123;</span><br><span class="line">case &quot;+&quot;:</span><br><span class="line">result = a +b</span><br><span class="line">case &quot;-&quot;:</span><br><span class="line">result = a-b</span><br><span class="line">case &quot;*&quot;:</span><br><span class="line">result = a*b</span><br><span class="line">case &quot;/&quot;:</span><br><span class="line">result = a/b</span><br><span class="line">default:</span><br><span class="line">panic(&quot;不支持的运算方式&quot;+operation)   //这个panic就是报错，让程序停下来</span><br><span class="line">&#125;</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">test:= eval(3,4,&quot;*&quot;)</span><br><span class="line">fmt.Println(test)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">12</span><br></pre></td></tr></table></figure></p><p>细心的你发现什么奇特之处么？对，里面没有<code>break</code>，因为Go语言中的<code>switch</code>会自动break，除非使用了<code>fallthrough</code>。而在C、C++或者是Java中你要么在后面添加break要么添加continue。</p><p>再来举一个例子，用于判断学生成绩情况：当分数小于60，则显示不及格；60-69为及格；70-79为中等；80-89为良好；90-100为优秀。使用Go语言实现的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func scoreTest(score int)string &#123;</span><br><span class="line">var result string = &quot;&quot;</span><br><span class="line">switch &#123;</span><br><span class="line">case score &lt;0 ||score &gt;100 :</span><br><span class="line">panic(fmt.Sprintf(&quot;无效的分数:%d&quot;,score))   //如果这个条件成立，则程序不再往下执行</span><br><span class="line">case score &lt;60:</span><br><span class="line">result = &quot;不及格&quot;</span><br><span class="line">case score&lt;70:</span><br><span class="line">result = &quot;及格&quot;</span><br><span class="line">case score &lt;80:</span><br><span class="line">result = &quot;中等&quot;</span><br><span class="line">case score &lt;90:</span><br><span class="line">result = &quot;良好&quot;</span><br><span class="line">case score &lt;=100:</span><br><span class="line">result = &quot;优秀&quot;</span><br><span class="line">&#125;</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(</span><br><span class="line">scoreTest(59),</span><br><span class="line">    scoreTest(62),</span><br><span class="line">scoreTest(77),</span><br><span class="line">scoreTest(84),</span><br><span class="line">scoreTest(99),</span><br><span class="line">//scoreTest(-99),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">不及格 及格 中等 良好 优秀</span><br></pre></td></tr></table></figure></p><p>如果程序满足panic的要求，则程序会停止运行。<strong>switch后面可以没有表达式</strong></p><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><p>使用Go语言实现求解0-指定数字内的数字之和，如100以内整数的和，相应的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func sumTest(a int) int &#123;</span><br><span class="line">sum := 0</span><br><span class="line">for i :=0;i&lt;=a;i++ &#123;</span><br><span class="line">sum+=i</span><br><span class="line">&#125;</span><br><span class="line">return sum</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(sumTest(100))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面使用了for循环，可以发现这个for循环的格式除了条件中不包含括号以外，其实和Java，JavaScript的代码完全一致。且大家要学会在函数中尽量使用<code>:=</code>的方式替代<code>var</code>来声明变量。</p><p><strong>for的条件中不包含括号，且条件中可省略初始条件，结束条件以及递增表达式</strong></p><p>再来看一个例子，将整数转换成二进制的表达式，相应的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func intToBinary(n int)string &#123;</span><br><span class="line">result := &quot;&quot;</span><br><span class="line">for ;n&gt;0;n/=2&#123;   //省略初始条件，相当于while</span><br><span class="line">lsb := n%2</span><br><span class="line">result = strconv.Itoa(lsb) +result</span><br><span class="line">&#125;</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(</span><br><span class="line">intToBinary(5), // 101</span><br><span class="line">intToBinary(13), //1101</span><br><span class="line">intToBinary(121242),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再来换一种方式读取之前那个test.txt文件中的内容，现在是一行行的进行读取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//一行行读取</span><br><span class="line">func printFileTest(filename string)&#123;</span><br><span class="line">file, err :=os.Open(filename)</span><br><span class="line">if err != nil&#123;</span><br><span class="line">panic(err)  //程序停下来去报错</span><br><span class="line">&#125;else&#123;</span><br><span class="line">scanner := bufio.NewScanner(file)</span><br><span class="line">for scanner.Scan()&#123;   </span><br><span class="line"> // 这里既没有开始条件，也没有递增条件，只有结束条件，此时分号都可以不写，Go语言中没有while</span><br><span class="line">    fmt.Println(scanner.Text())  //输出</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">printFileTest(&quot;test.txt&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这段代码里面for中既没有开始条件，也没有递增条件，只有结束条件，那么此时的分号都可以不写，记住Go语言中没有while。因为while的功能和for相似，所以Go语言中就没有必要存在while这个关键词了。</p><p>当for中什么也不加，则变成了一个死循环，就相当于其他语言中的while true。Go语言中的死循环实现起来非常简单，那是因为后面会经常使用到死循环。</p><p>简单总结一下循环语句的特点：<strong>1、for和if条件后面没有括号；2、if条件里面也可以定义变量；3、Go语言中没有while；4、switch中不需要定义break，也可以直接switch多个语句。</strong></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>其实在前面我们就使用了<code>func</code>这个关键词用于定义函数，函数定义的格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func 函数名称(参数名称，参数类型)返回值类型&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要说明的是，Go语言的函数可以有多个返回值的，且类型可以不相同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">//求解两个数的和</span><br><span class="line">func sumTest(a,b int)int&#123;</span><br><span class="line">return a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求两个数相除的商及余数</span><br><span class="line">func divTest(a ,b int) (int,int, string) &#123;</span><br><span class="line">return a/b, a%b, &quot;你好&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(sumTest(3,6))</span><br><span class="line">fmt.Println(divTest(13, 4))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">9</span><br><span class="line">3 1 你好</span><br></pre></td></tr></table></figure></p><p>在上面的代码中不知道返回的到底是什么，只知道都是int类型，其实可以像声明变量的方式那样给返回值设置名称：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//求两个数相除的商及余数</span><br><span class="line">func divTest(a ,b int) (q, r int, s string) &#123;</span><br><span class="line">return a/b, a%b, &quot;你好&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于Go语言非常严格，定义的变量一定要使用，如果函数有多个返回值，我们只想取某个值时，那么其余的变量可以使用匿名变量<code>_</code>来接收。尽管Go语言支持返回多个类型值，但是不要乱用，一般返回两个，前者是数据，后者是错误<code>nil</code>，如下图所示。将前面实现两个数的四则运算的相关代码进行改写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func calcTest(a, b int,operation string ) (int, error) &#123;</span><br><span class="line">switch operation &#123;</span><br><span class="line">case &quot;+&quot;:</span><br><span class="line">return a+b, nil</span><br><span class="line">case &quot;-&quot;:</span><br><span class="line">    return a-b,nil</span><br><span class="line">case &quot;*&quot;:</span><br><span class="line">        return a*b,nil</span><br><span class="line">case &quot;/&quot;:</span><br><span class="line">        return a/b,nil</span><br><span class="line">default:</span><br><span class="line">return 0,fmt.Errorf(&quot;不支持的运算操作:%s&quot;,operation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(calcTest(3,5,&quot;+&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">8 &lt;nil&gt;</span><br></pre></td></tr></table></figure></p><p>上述代码其实还不够完善，在main方法中对正常与否需要进行判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">if result ,err:= calcTest(3,5,&quot;+&quot;);err != nil&#123;</span><br><span class="line">//程序运行存在错误</span><br><span class="line">fmt.Println(&quot;程序运行存在错误&quot;,err)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">fmt.Println(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Go语言中函数可以返回多个值，且可以给多个值声明名称，但是返回多个值的情况仅仅适用于非常简单的函数，不过取不取名字和调用者无关。</p><p>Go语言是函数式编程，函数是一等公民（Python中也是），函数里面的参数，返回值里面都可以包含函数。通过前面求两个数的四则运算这个例子进行改写，实现将函数作为参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p><strong>Go语言没有其他语言中的默认参数、可变参数、函数重载等，只有一个可变参数列表</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//求可变参数列表中参数之和</span><br><span class="line">func dynamicVariable(values ... int)int &#123;</span><br><span class="line">sum :=0</span><br><span class="line">for i:=range values&#123;</span><br><span class="line">sum+=values[i]</span><br><span class="line">&#125;</span><br><span class="line">return sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(dynamicVariable(1,2,3,4,5,6))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">21</span><br></pre></td></tr></table></figure></p><p>函数小结：1、函数返回值的类型写在最后面；2、函数可以返回多个值；3、函数可作为参数进行使用；4、没有默认参数和可选参数，函数重载等。</p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>大家不要听到指针就害怕，Go语言中的指针和C语言中的指针差别很大（<strong>Go语言中的指针不能运算</strong>，而C语言中却可以），比C中的指针简单多了。</p><p>看到这里就必须谈到一个老生常谈的问题：Go语言中的参数传递是值传递还是引用传递？在C和C++中既可以值传递也可以引用传递。Java和Python绝大部分都是引用传递，除了系统的自建类型以外。那么什么是值传递？什么是引用传递呢？我们通过C++中的一段代码进行了解（C++中使用<code>&amp;</code>表示引用传递）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void pass_by_value(int a)&#123;  //值传递</span><br><span class="line">a++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void pass_by_guide(int&amp; a)&#123;  //引用传递</span><br><span class="line">a++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int a =3;</span><br><span class="line">pass_by_value(a)</span><br><span class="line">printf(&quot;值传递以后的值为：%d\n&quot;,a);</span><br><span class="line"></span><br><span class="line">pass_by_guide(a)</span><br><span class="line">printf(&quot;引用传递以后的值为：%d\n&quot;,a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">3  4</span><br></pre></td></tr></table></figure></p><p>pass_by_value是值传递，会将a的值从main函数中拷贝一份到pass_by_value函数中，真正作了一份拷贝，拷贝进去的a加了1，那么main函数中的a并没有发生变化，没有动依旧是3。pass_by_guide是引用传递，它不会拷贝，此时main函数中的a和pass_by_guide中的a其实是引用了同一个变量a，因此在pass_by_guide函数中进行了加1操作，自然main函数中的a也会发生变化，因此就变成了4。值传递就是拷贝，原来值不会发生变化；引用传递不会拷贝，会导致原来的值发生变化。</p><p><strong>Go语言只有值传递一种方式。</strong>Go语言中的参数需要配合其指针来使用，具体分情况：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2c9563d3d2a7a75c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>上面这种就是值传递，两者没有影响。下面是使用到了指针的情况：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0d78efeb43abb63e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>左侧是一个int类型名为a的变量，右侧是一个int类型名为aa的指针，通过指针实现相当于引用传递的效果，把a的地址给了你以后，可以修改a的值。这些都是基本数据类型，再来尝试一个自定义类型：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-371b925a467370ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>当把左侧的book对象传给右侧的read函数时，一般这个book对象本身通常包含指向data的一个指针，然后拷贝一份到右侧函数中，右侧的book对象也有一个pdata，但是是指向同一个data，其实就是拷贝了同一份指针。因此在Go语言中，自定义类型的时候需要考虑把它作为一个值还是一个指针来用。这里的book其实就是作为一个值来用。</p><p>用一个交换两个对象的值这个例子来加深大家的印象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//交换两个对象的值</span><br><span class="line">func swap(a,b int) &#123;</span><br><span class="line">a,b = b ,a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">a ,b := 1,2</span><br><span class="line">swap(a,b)</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">1,2</span><br></pre></td></tr></table></figure></p><p>你会发现这个函数没有用，两个数值并没有发生交换，的确是这样的，那是因为这个需要借助于指针来完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//交换两个对象的值</span><br><span class="line">func swap(a,b *int) &#123;</span><br><span class="line">*a,*b = *b ,*a  //声明指针需要使用*</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">a ,b := 1,2</span><br><span class="line">swap(&amp;a,&amp;b)  //传递地址需要使用&amp;</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">2,1</span><br></pre></td></tr></table></figure></p><p>不过这种看起来挺麻烦的，其实之前的代码不是没有起作用，而是没有将结果进行返回，修改一下代码其实是可以的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func swapTest(a,b int)(int ,int) &#123;</span><br><span class="line">return b ,a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">a ,b := 1,2</span><br><span class="line">a, b = swapTest(a,b)</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">2,1</span><br></pre></td></tr></table></figure></p><p>这样就通过接收函数的返回值，进而实现交换两个数值的目的。至此程序结构部分就学到这里，后面学习Go语言中的内建容器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本篇笔记主要介绍程序结构相关的知识，具体包括条件语句、循环、函数和指针等内容。&lt;/p&gt;
&lt;h1 id=&quot;条件语句&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="go" scheme="http://blog.licheetools.top/categories/go/"/>
    
    
      <category term="golang" scheme="http://blog.licheetools.top/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记（5）：内建容器之Map、字符、字符串</title>
    <link href="http://blog.licheetools.top/2019/05/11/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9A%E5%86%85%E5%BB%BA%E5%AE%B9%E5%99%A8%E4%B9%8BMap%E3%80%81%E5%AD%97%E7%AC%A6%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://blog.licheetools.top/2019/05/11/Go语言学习笔记（5）：内建容器之Map、字符、字符串/</id>
    <published>2019-05-11T01:58:30.000Z</published>
    <updated>2019-11-04T14:04:53.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本篇笔记继续介绍内建容器相关的知识，具体包括Map、字符和字符串等内容。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map这种数据结构在很多语言中都有，不过名字不同，JavaScript称对象，Java称Map，Python称字典，但Map其实就是键值对。</p><p>创建map的方式为<code>map[k]v</code>，当然也可以创建复合map<code>map[k1]map[k2]v</code>，还可以使用<code>make</code>方法创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">m1:=map[string]string&#123;   //map[k]v</span><br><span class="line">&quot;name&quot;:&quot;envy&quot;,</span><br><span class="line">&quot;language&quot;:&quot;Golang&quot;,</span><br><span class="line">&quot;job&quot;:&quot;Developer&quot;,</span><br><span class="line">&#125;</span><br><span class="line">m2:=make(map[string]int)  //m2 ==empty map</span><br><span class="line">var m3 map[string]int  //m3==nil，Go语言中的nil是可以参与运算的</span><br><span class="line">fmt.Println(m1,m2,m3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">map[job:Developer language:Golang name:envy] map[] map[]</span><br></pre></td></tr></table></figure></p><p>接下来介绍map的遍历操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">m1:=map[string]string&#123;   //map[k]v</span><br><span class="line">&quot;name&quot;:&quot;envy&quot;,</span><br><span class="line">&quot;language&quot;:&quot;Golang&quot;,</span><br><span class="line">&quot;job&quot;:&quot;Developer&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;map的遍历K,V操作&quot;)</span><br><span class="line">for k,v:=range m1&#123;</span><br><span class="line">fmt.Println(k,v)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;map的遍历K操作&quot;)</span><br><span class="line">for k:=range m1&#123;</span><br><span class="line">fmt.Println(k)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;map的遍历V操作&quot;)</span><br><span class="line">for _,v:=range m1&#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">map的遍历K,V操作</span><br><span class="line">language Golang</span><br><span class="line">job Developer</span><br><span class="line">name envy</span><br><span class="line"></span><br><span class="line">map的遍历K操作</span><br><span class="line">name</span><br><span class="line">language</span><br><span class="line">job</span><br><span class="line"></span><br><span class="line">map的遍历V操作</span><br><span class="line">Golang</span><br><span class="line">Developer</span><br><span class="line">envy</span><br></pre></td></tr></table></figure></p><p>多次运行发现每次遍历结果是不相同的，这个map是无序的，其实是一个hashmap。</p><h3 id="获取map的值"><a href="#获取map的值" class="headerlink" title="获取map的值"></a>获取map的值</h3><p>接下来获取map的值，这个对于提高编码能力非常有帮助，可以使用map[“k”]的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">m1:=map[string]string&#123;   //map[k]v</span><br><span class="line">&quot;name&quot;:&quot;envy&quot;,</span><br><span class="line">&quot;language&quot;:&quot;Golang&quot;,</span><br><span class="line">&quot;job&quot;:&quot;Developer&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;获取map中value的值&quot;)</span><br><span class="line">myname:= m1[&quot;name&quot;]</span><br><span class="line">fmt.Println(myname)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">获取map中value的值</span><br><span class="line">envy</span><br></pre></td></tr></table></figure></p><p>当你尝试使用一个map中不存在的键去获取值时，程序运行不会出错，但是没有输出，其实就是Zero Value：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myscore:=m1[&quot;test&quot;]</span><br><span class="line">fmt.Println(myscore)  //没有输出</span><br></pre></td></tr></table></figure></p><p>那么如何判断map中是否存在某个键呢？可以在<code>m[&quot;k&quot;]</code>的返回中取出状态，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myname, ok:= m1[&quot;name&quot;]</span><br><span class="line">fmt.Println(myname, ok)  //envy true</span><br><span class="line"></span><br><span class="line">myscore, ok:=m1[&quot;test&quot;]</span><br><span class="line">fmt.Println(myscore, ok) //  false</span><br></pre></td></tr></table></figure></p><p>一般我们都不是这样使用，而是结合if语句进行判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if myname,ok :=m1[&quot;test&quot;];ok&#123;</span><br><span class="line">fmt.Println(myname)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">fmt.Println(&quot;m1中不存在该键&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">m1中不存在该键</span><br></pre></td></tr></table></figure></p><p>接下来介绍如何删除map中的元素，这下就能使用到前面说过的delete方法了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// The delete built-in function deletes the element with the specified key</span><br><span class="line">// (m[key]) from the map. If m is nil or there is no such element, delete</span><br><span class="line">// is a no-op.</span><br><span class="line">func delete(m map[Type]Type1, key Type)</span><br></pre></td></tr></table></figure></p><p>这个<code>delete</code>有两个参数，第一个是map对象，第二个是map的键：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">job, ok:= m1[&quot;job&quot;]</span><br><span class="line">fmt.Println(job, ok)</span><br><span class="line"></span><br><span class="line">delete(m1, &quot;job&quot;)</span><br><span class="line">job, ok= m1[&quot;job&quot;]</span><br><span class="line">fmt.Println(job, ok)</span><br><span class="line">//运行结果：</span><br><span class="line">Developer true</span><br><span class="line"> false</span><br></pre></td></tr></table></figure></p><p>简单总结一下map的操作：1、可以使用<code>make(map[string]int)</code>等方式创建map；2、使用<code>m[key]</code>获取元素；3、当key不存在时，将会获取Value类型的初始值；4、可以使用<code>value,ok:=m[key]</code>来判断是否存在Key；5、可以使用<code>delete(map,key)</code>来删除map中的元素；6、可以使用range来遍历key或者是key、value键值对；7、无法保证map的遍历顺序，若要按照指定顺序则需手动设置（采用slice排序）；8、可以使用<code>len</code>来获取map的长度。</p><p>map使用哈希表，因此必须可以比较是否相等。除了slice、map和function等内建类型外，都可以作为key。自定义类型(Struct类型)中不包含上述字段，也可以作为key。它不像Java中采用equals和hascode等方法进行判断，Go语言可以自己在编译过程中自行判断是否包含上述字段。</p><h1 id="Map例题"><a href="#Map例题" class="headerlink" title="Map例题"></a>Map例题</h1><p>查看leetcode中一道题目：查找最长不含有重复字符的字串。例如abcabcbb–&gt;abc；<br>bbbb–&gt;b；pwwkew–&gt;wke。接下来好好分析这个题目：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-427d5d13c9677ba0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>假设字符串从X开始重复，那么两个x之间的则是不包含最长重复字符串的字串(maxlength)，暂记左侧为start，也就是字符串开始。如果之间存在重复字符串，则将右侧的x向左移动，此时将x最后出现的位置记作lastplace[x]。我们知道这个lastplace[x]会有两种情况：1)在start之前，此时大可不去理会，因为此时最大字串就是x本身；2）介于两个x之间，此时需要更新start的值，指向lastplace[x]+1的位置。无论哪种情况，最后都要更新lastplace[x]和maxlength。最后输出的是不包含最长重复字符串的字串的长度，也就是maxlength。</p><p>接下来尝试使用Go语言解决这个问题，注意一下在前面说过Go语言中的字符是rune类型是32位的，而我们遍历字符串得到的其实是一个int32的类型，因此类型不对，但是我们可以将字符串转成字节数组啊，这样每一个字符就是一个字节占8位，和通常的语言保持一致了，可以查看源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// string is the set of all strings of 8-bit bytes, conventionally but not</span><br><span class="line">// necessarily representing UTF-8-encoded text. A string may be empty, but</span><br><span class="line">// not nil. Values of string type are immutable.</span><br><span class="line">type string string</span><br></pre></td></tr></table></figure></p><p>string里面的每个字节都是8位的，而我们采用for循环遍历得到的是int32类型，不过将string转为字节数组后，里面存的就是uint8类型了，满足要求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is</span><br><span class="line">// used, by convention, to distinguish byte values from 8-bit unsigned</span><br><span class="line">// integer values.</span><br><span class="line">type byte = uint8</span><br></pre></td></tr></table></figure></p><p>然后就可以写代码了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func returnLengthNonRepetingSubString(s string)int&#123;</span><br><span class="line">lastplace:=make(map[byte]int)</span><br><span class="line">start:=0</span><br><span class="line">maxlength:=0</span><br><span class="line">for i,ch :=range []byte(s)&#123;  //遍历字符串,i是索引，ch是字符</span><br><span class="line">if lastI,ok:= lastplace[ch]; ok &amp;&amp; lastI&gt;=start&#123;</span><br><span class="line">start = lastI+1</span><br><span class="line">&#125;</span><br><span class="line">if i - start + 1 &gt;maxlength&#123;</span><br><span class="line">maxlength = i-start +1</span><br><span class="line">&#125;</span><br><span class="line">lastplace[ch] = i</span><br><span class="line">&#125;</span><br><span class="line">return maxlength</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(returnLengthNonRepetingSubString(&quot;abcabcbb&quot;))</span><br><span class="line">fmt.Println(returnLengthNonRepetingSubString(&quot;bbbb&quot;))</span><br><span class="line">fmt.Println(returnLengthNonRepetingSubString(&quot;pwwkew&quot;))</span><br><span class="line">fmt.Println(returnLengthNonRepetingSubString(&quot;abcdefgh&quot;))</span><br><span class="line"></span><br><span class="line">fmt.Println(returnLengthNonRepetingSubString(&quot;你好世界&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果:</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">8</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p><p>有一个非常奇怪的地方就是最后输出中文却是10，那是因为之前将字符串转为字节数组其实只是支持asii，并不支持utf8。接下来就介绍如何支持中文，那就是进入字符和字符串的学习了。</p><h1 id="字符及字符串"><a href="#字符及字符串" class="headerlink" title="字符及字符串"></a>字符及字符串</h1><p>前面说过rune其实就相当于Go语言中的char，那么我们现在看一个例子，用于输出字符串的长度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">a:=&quot;你好envy!&quot;</span><br><span class="line">fmt.Println(len(a))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">11</span><br></pre></td></tr></table></figure></p><p>为什么是11呢？我们尝试输出一下它的字节：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">a:=&quot;你好envy!&quot;  //utf-8编码</span><br><span class="line">for _,v:=range []byte(a)&#123;  </span><br><span class="line">fmt.Printf(&quot;%x  &quot;,v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">e4  bd  a0  e5  a5  bd  65  6e  76  79  21</span><br></pre></td></tr></table></figure></p><p>我么发现一个中文占了3个字节，英文和符号只占一个，这个就是UTF-8编码，它是一种可变字节长度的编码。Unicode编码中一个英文占2个字节，而网上多以英文为主这会占据很多资源。而UTF-8编码是可变字节的编码，一个中文占了3个字节，英文和符号只占一个字节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">a:=&quot;你好envy!&quot;  //utf-8编码</span><br><span class="line">fmt.Println(a)</span><br><span class="line">for _,v:=range []byte(a)&#123;  //遍历字节数组</span><br><span class="line">fmt.Printf(&quot;%x  &quot;,v)   //e4  bd  a0  e5  a5  bd  65  6e  76  79  21</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">for i,ch :=range a&#123;   //遍历字符串,i是int类型，而ch是int32类型其实也就是rune</span><br><span class="line">fmt.Printf(&quot;(%d %x)&quot;,i,ch)  //unicode编码</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">你好envy!</span><br><span class="line">e4  bd  a0  e5  a5  bd  65  6e  76  79  21  </span><br><span class="line">(0 4f60)(3 597d)(6 65)(7 6e)(8 76)(9 79)(10 21)</span><br></pre></td></tr></table></figure></p><p>我们可以发现其实第二列是utf8编码，第三列就是unicode编码，字节数组就是起到了将utf8编码转为Unicode编码的作用。Go语言提供了<code>utf8</code>这个库，这个库提供了我们对utf8的操作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">utf8.RuneCountInString(s)   //返回给定字符串中rune的个数</span><br></pre></td></tr></table></figure></p><p><strong>decode的作用是将其他编码的字符串转换成unicode编码；encode的作用是将unicode编码转换成其他编码的字符串。</strong></p><p>我们来看一下utf8.DecodeRune这个方法的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and its width in bytes.</span><br></pre></td></tr></table></figure></p><p>可以发现它的作用就是将bytes以UTF8的形式进行解压并返回字节和字节的长度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bytes :=[]byte(a)</span><br><span class="line">for len(bytes)&gt;0&#123;</span><br><span class="line">ch, size := utf8.DecodeRune(bytes)</span><br><span class="line">bytes = bytes[size:]</span><br><span class="line">fmt.Printf(&quot;%c &quot;,ch)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">你 好 e n v y !</span><br></pre></td></tr></table></figure></p><p>上面这种还不是很好理解，我们希望输出每个字符及所对应的索引号，其实转成rune不就可以了么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for i,v:=range []rune(a)&#123;</span><br><span class="line">fmt.Printf(&quot;(%d %c)&quot;,i,v)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">(0 你)(1 好)(2 e)(3 n)(4 v)(5 y)(6 !)</span><br></pre></td></tr></table></figure></p><p>也就这种是我们经常可以使用到的，前面几种其实都是比较底层的内容。</p><p><code>[]rune(a)</code>就是将字符串string转成字符rune，注意每个rune是4个字节，因此这里的类型转换并不是对当前这个内存的重新理解，而是转它decode出来的结果，decode出来的是每个字符占4个字节，然后重新定义了一个rune数组，并将其存起来。这个decode还有转utf8的过程，转完会存取来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e4  bd  a0  e5  a5  bd  65  6e  76  79  21  </span><br><span class="line">(0 4f60)(3 597d)(6 65)(7 6e)(8 76)(9 79)(10 21)</span><br></pre></td></tr></table></figure></p><p>它们并不是用上面的内存去解释下面的内存，而是发生了变化，重新定义了一个rune数组用于存取字符。</p><p>总结一下，我们前面使用<code>range</code>来遍历pos,rune对，发现pos位置是不连续的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(0 4f60)(3 597d)(6 65)(7 6e)(8 76)(9 79)(10 21)</span><br></pre></td></tr></table></figure></p><p>中文会每次加3，英文和符号加1；<strong>使用len(string)获得的只是字节数，并不是字符数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:=&quot;你好envy!&quot;  </span><br><span class="line">len(a)) //字节数11</span><br><span class="line">utf8.RuneCountInString(a)) //字符数7</span><br></pre></td></tr></table></figure></p><p><strong>使用<code>[]byte(a)</code>获得a的所有字节数，使用<code>[]rune(a)</code>会返回一个rune数组的slice。</strong></p><p>我们知道golang中的string类型存储的字符串是不可变的， 如果要修改string内容需要将string转换为[]byte或[]rune，并且修改后的string内容是重新分配的。   byte和rune的区别是byte是8位，rune是32位：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type byte = uint8</span><br><span class="line">type rune = int32</span><br></pre></td></tr></table></figure></p><p>前面那个<code>查找最长不含有重复字符的字串</code>的代码是不支持中文的，接下来进行改造使之支持中文：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func returnCLengthNonRepetingSubString(s string)int&#123;</span><br><span class="line">lastplace:=make(map[rune]int)</span><br><span class="line">start:=0</span><br><span class="line">maxlength:=0</span><br><span class="line">for i,ch :=range []rune(s)&#123;  //遍历字符串,i是索引，ch是字符</span><br><span class="line">if lastI,ok:= lastplace[ch]; ok &amp;&amp; lastI&gt;=start&#123;</span><br><span class="line">start = lastI+1</span><br><span class="line">&#125;</span><br><span class="line">if i - start + 1 &gt;maxlength&#123;</span><br><span class="line">maxlength = i-start +1</span><br><span class="line">&#125;</span><br><span class="line">lastplace[ch] = i</span><br><span class="line">&#125;</span><br><span class="line">return maxlength</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(returnCLengthNonRepetingSubString(&quot;abcabcbb&quot;))</span><br><span class="line">fmt.Println(returnCLengthNonRepetingSubString(&quot;bbbb&quot;))</span><br><span class="line">fmt.Println(returnCLengthNonRepetingSubString(&quot;pwwkew&quot;))</span><br><span class="line">fmt.Println(returnCLengthNonRepetingSubString(&quot;abcdefgh&quot;))</span><br><span class="line"></span><br><span class="line">fmt.Println(returnCLengthNonRepetingSubString(&quot;&quot;))</span><br><span class="line">fmt.Println(returnCLengthNonRepetingSubString(&quot;你好世界&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">8</span><br><span class="line">0</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p><p>其实你会发现我们只是将其中的<code>byte</code>修改为<code>rune</code>即可，这里有一个注意点就是<code>for i,ch :=range []rune(s)</code>这里面是不能直接使用s，你可以试一下，发现结果变成了这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">8</span><br><span class="line">0</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p><p>因为没有问题，中文还是出了问题，因为它会将一个中文当做3个字符来使用。所以必须使用<code>[]rune(s)</code>。</p><p>对于字符串的操作，Go语言提供了一个<code>strings</code>的库，大家可以自行使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">strings.Fields()   </span><br><span class="line">strings.Join()</span><br><span class="line">strings.Split()</span><br><span class="line"></span><br><span class="line">strings.Contains()</span><br><span class="line">strings.Index()</span><br><span class="line"></span><br><span class="line">strings.ToLower()</span><br><span class="line">strings.ToUpper()</span><br><span class="line"></span><br><span class="line">strings.Trim()</span><br><span class="line">strings.TrimLeft()</span><br><span class="line">strings.TrimRight()</span><br></pre></td></tr></table></figure></p><p>这样关于内建容器的介绍就到此为止了，后续介绍Go语言中所谓的”面向对象”。<br>参考文章：<a href="https://blog.csdn.net/shida_csdn/article/details/93745178" target="_blank" rel="noopener">rune 与 string 的区别和联系（笔记）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本篇笔记继续介绍内建容器相关的知识，具体包括Map、字符和字符串等内容。&lt;/p&gt;
&lt;h1 id=&quot;Map&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="go" scheme="http://blog.licheetools.top/categories/go/"/>
    
    
      <category term="golang" scheme="http://blog.licheetools.top/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记（2）：变量</title>
    <link href="http://blog.licheetools.top/2019/05/10/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E5%8F%98%E9%87%8F/"/>
    <id>http://blog.licheetools.top/2019/05/10/Go语言学习笔记（2）：变量/</id>
    <published>2019-05-10T13:58:30.000Z</published>
    <updated>2019-11-04T14:02:53.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本篇笔记一起来学习Go语言中的变量、内建变量类型和常量这3个非常基础的知识。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>Go语言变量的声明使用关键词var，然后跟上变量名称，变量类型，初始值。例如：<code>var a int = 5</code>，string和int类型的默认值分别是空串和0。在Go语言中，推荐使用驼峰命名法来给变量进行命名，如<code>var jobUsedTest int = 66</code>等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func variableTest()&#123;</span><br><span class="line">var a int</span><br><span class="line">var s string</span><br><span class="line">fmt.Println(a, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">variableTest()</span><br><span class="line">&#125;</span><br><span class="line">#  运行结果：</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><p>这个空串似乎没有打印输出，那是因为<code>fmt.Println</code>是根据变量的名字进行输出，此时可以使用格式化输出<code>fmt.Printf(&quot;%d, %q&quot;,a, s)</code>，注意不能使用<code>fmt.Printf(&quot;%d, %s&quot;,a, s)</code>，q代表quote就是引号。</p><p>再来定义一些具有初始值的变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func variableValueTest()&#123;</span><br><span class="line">var name string = &quot;newbee&quot;</span><br><span class="line">var age int = 22</span><br><span class="line">fmt.Println(name, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Go语言还可以一次声明多个相同类型的变量，需要注意的是Go语言非常严格，声明的变量一定要使用用上，否则会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func manyVariableValue()&#123;</span><br><span class="line">var hobby, address  string = &quot;running&quot;, &quot;beijing&quot;  //声明了2个变量，后面只输出了一个，所以程序会报错</span><br><span class="line">fmt.Println(hobby)   // 这样输出是错误的，需要添加address </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func manyVariableValue()&#123;</span><br><span class="line">var hobby, address  string = &quot;running&quot;, &quot;beijing&quot;</span><br><span class="line">fmt.Println(hobby, address)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">manyVariableValue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样运行就没问题了，可以正常输出。不过看到这里是不是觉得非常别扭，因为程序可以从后面变量值就能猜测出变量的类型，为什么后面不可以省略变量类型呢？我没说不可以啊，哈哈哈哈哈哈哈哈。其实早期的语言不可以，像C但是C现在都支持了，而我们的Go语言肯定也支持啊，因此去掉后面的变量类型也是可以的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func variableTypeDeduction()&#123;</span><br><span class="line">var name  = &quot;newbee&quot;</span><br><span class="line">var age  = 22</span><br><span class="line">var number, address, answer, words = 23, &quot;北京&quot;, true, &quot;加油&quot;</span><br><span class="line">fmt.Println(name, age)</span><br><span class="line">fmt.Println(number, address, answer, words)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到没有，是不是觉得这个除了<code>func</code>和<code>fmt.Println</code>函数不同，是不是和JavaScript非常相似，去掉变量类型后，可以一次声明多个不同类型的变量。<strong>也就是说后面跟了变量的类型，那么一次只能声明多个相同类型的变量，没有设置变量类型就可以声明不同类型的变量。</strong></p><p>其实上面声明变量还是有点复杂，试试更简单的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func variableShorterTest()&#123;</span><br><span class="line">number, address, answer, words := 23, &quot;北京&quot;, true, &quot;加油&quot;  </span><br><span class="line">number = 99 // 第二次赋值的时候，不能添加:号</span><br><span class="line">fmt.Println(number, address, answer, words)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一行中的<code>:=</code>和<code>var</code>效果类似，用于定义一个变量，记住第一次的声明变量必须添加<code>:</code>。第二次赋值的时候，不能添加<code>:</code>号，因为此时是重新赋值，而不是重新声明变量。说的更明白点就是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func variableTestSingle()&#123;</span><br><span class="line">score:= 100   // 等同于var score =100</span><br><span class="line">fmt.Println(score)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意使用:=代替var的形式，只能用于变量被声明在函数中的，而在函数的外面（包里面）定义变量只能使用var关键词，因为函数外面只能是关键词开头。</strong>Go语言没有全局变量这种说法。</p><p>当然了当你声明的变量很多时，可以将变量放在一个小括号中，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var job_1 = &quot;IT&quot;</span><br><span class="line">var company_1 = &quot;jialidun&quot;</span><br><span class="line">||</span><br><span class="line">var (</span><br><span class="line">job_2 = &quot;IT&quot;</span><br><span class="line">company_2 = &quot;jialidun&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>总结一下变量这一小节的知识：var关键词可以放在函数内，也可以直接放在包内，还可以使用var()来集中定义变量。Go语言可以让编译器自动识别类型，因此在声明变量的时候可以不后跟变量类型。在函数内可以使用<code>:=</code>代替<code>var</code>声明变量，在包内是不可以的。</p><h1 id="内建变量类型"><a href="#内建变量类型" class="headerlink" title="内建变量类型"></a>内建变量类型</h1><p>Go语言提供了7种内建的变量类型，具体如下：<br><strong>1、数值（16个）</strong>：<br>整型12个[（byte（8位）、int、int8、int16、int32、int64）和(uint、uint8、uint16、uint32、uint64、uintprt)]；<br>浮点型2个[float32、float64]；（没有Java中的double类型）<br>复数型2个[complex64、complex128]；（complex64代表实部和虚部都是32位）<br>（前面加u的是有符号整数，后面数值是整数的位数，没有Java中的short、long等类型，最后面的uintprt是指针，位规定长度时，其长度根据操作系统来确定）<br><strong>2、字符串和字符类型(2个)</strong>：string、rune；（没有Java中的char类型，在Java中char就是一个字节，不过1个字节坑太多，rune是32位的）<br><strong>3、接口型（1个）</strong>：error；<br><strong>4、布尔型（1个）</strong>：bool。</p><p>接下来对复数进行简要的复习：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0410d42dbc6e309e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>再来看一个非常美丽的欧拉公式：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-d2413a32471e57af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>通过上面复数的简单复习，后面会通过Go语言来验证这个公式。先来尝试输出<code>3+4i</code>的模：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;math/cmplx&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func euler()&#123;</span><br><span class="line">euler := 3+4i   //写成euler := 3+4*i是错误的，变成euler := 3+4*1i是可以的</span><br><span class="line">fmt.Println(cmplx.Abs(euler))   //注意使用cmplx而不是complx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">euler()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果：</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p><p>接下来就来验证欧拉公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;math&quot;</span><br><span class="line">&quot;math/cmplx&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func eulerTest()&#123;</span><br><span class="line">fmt.Println(cmplx.Exp(1i*math.Pi)+1)  //不需要写底数E</span><br><span class="line">fmt.Println(cmplx.Pow(math.E,1i*math.Pi) +1)  //需要写底数E</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">eulerTest()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">(0+1.2246467991473515e-16i)</span><br><span class="line">(0+1.2246467991473515e-16i)</span><br></pre></td></tr></table></figure></p><p>好像结果都不是0啊，那是因为虚部后面其实是有位数的，无法精确到那么准。</p><p>我们再来尝试使用Python来试试，看看结果是怎样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import cmath</span><br><span class="line"></span><br><span class="line">print(cmath.exp(1j*cmath.pi)+1)</span><br><span class="line"></span><br><span class="line"># 输出结果：</span><br><span class="line">1.2246467991473532e-16j</span><br></pre></td></tr></table></figure></p><p>似乎也不是那么精准呢，我前面也说过出现这样的问题就在于精度误差，如果只取小数点后5位呢，再来看看Go语言写的代码运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(&quot;%.5f&quot;,cmplx.Exp(1i*math.Pi)+1)</span><br><span class="line"></span><br><span class="line">// 运行结果：</span><br><span class="line">(0.00000+0.00000i)</span><br></pre></td></tr></table></figure></p><p>这样就验证了欧拉公式。</p><p>再来聊一下类型转换，在Java中有隐式和强制类型转换两种，所谓的隐式就是小类型转为大类型，比如福田区是属于深圳市，而深圳市隶属于广东省，因此福田区也是广东省的。强制类型就是大类型转为小类型，如珠海市属于广东省，但你能说它属于深圳市么？因此强制类型转换可能会出现问题。<strong>在Go语言中，只有强制类型转换唯一一种</strong>。</p><p>举个例子定义两个变量a,b分别是直角三角形的两条直角边，求它的第三边c，你肯定知道是5，那么如何通过Go语言来解决呢？我们发现<code>func Sqrt(x float64) float64</code>这个<code>Sqrt</code>函数里面要求参数是<code>float64</code>，最后返回结果也是<code>float64</code>，可是我们的边长是int类型，因此需要强制类型转换，其实就是使用<code>float64</code>这个构造方法<code>float64(a*a + b*b)</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;math&quot;</span><br><span class="line">&quot;math/cmplx&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func triangleTest()&#123;</span><br><span class="line">var a, b int = 3, 4</span><br><span class="line">var c int</span><br><span class="line">//c = math.Sqrt(a*a + b*b)  需要强制类型转换</span><br><span class="line">c = int(math.Sqrt(float64(a*a + b*b)))  //转换了两次</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">triangleTest()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p><p>也就是说直接使用<code>var c int = math.Sqrt(a*a + b*b)</code>是错误的，必须采用<code>var c int = int(math.Sqrt(float64(a*a + b*b)))</code>，其实使用<code>float64</code>是有一些瑕疵的，因为精度有待提高，假设是4.9999，使用int转换后可能是4，而不是5，这个问题不是Go语言具有的，其实很多编程语言都是存在这个问题的。</p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>使用<code>const</code>关键词定义的变量，我们称之为常量，常量可以存放函数内和包内。注意如果体会以下代码的区别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const a, b = 3, 4</span><br><span class="line">var c = int(math.Sqrt(a*a + b*b))</span><br><span class="line"></span><br><span class="line">var a, b  = 3, 4</span><br><span class="line">var c = int(math.Sqrt(float64(a*a + b*b)))</span><br><span class="line"></span><br><span class="line">const a, b int = 3, 4</span><br><span class="line">var c = int(math.Sqrt(float64(a*a + b*b)))</span><br></pre></td></tr></table></figure></p><p>可以发现，使用<code>const</code>关键词修饰的变量，如果后面没有指明变量类型，其实它可是float32、float64亦或是int、int8……等等，因此不需要强制类型转换，而使用<code>var</code>关键词修饰的变量，如果后面没有指明变量类型，则就需要强制类型转换。当然如果<code>const</code>关键词修饰的变量，后面指明了变量类型，那就需要强制类型转换的。</p><p>你也可以使用<code>()</code>来同时声明一组常量，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">a =3</span><br><span class="line">b= 4</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>还有不知道你注意没有函数名称里面包含大写字母，我们所有的关键词和变量名称都是小写的？注意这是有规定的，因为大写的字母代表着Java中的public的意思，即访问权限的控制，所以目前大家只需要做到全部小写即可。<strong>常量的数值可以作为各种类型使用。</strong></p><h1 id="使用常量定义枚举类型"><a href="#使用常量定义枚举类型" class="headerlink" title="使用常量定义枚举类型"></a>使用常量定义枚举类型</h1><p>接下来尝试使用常量来定义枚举类型，Go语言中没有定义枚举类型的关键词，也是使用<code>const</code>关键词进行修饰，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//使用const来定义枚举类型</span><br><span class="line">func enumsTest()&#123;</span><br><span class="line">const(</span><br><span class="line">Java = 0  // 枚举类型变量必须有初始值</span><br><span class="line">Python = 1</span><br><span class="line">Go =2</span><br><span class="line">PHP =3</span><br><span class="line">JavaScript = 4</span><br><span class="line">)</span><br><span class="line">fmt.Println(Java , Python , Go, PHP, JavaScript)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">enumsTest()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">0 1 2 3 4</span><br></pre></td></tr></table></figure></p><p>但是这种感觉和使用<code>const</code>一次性定义很多变量差别不是很大，此时Go语言给我们提供了<code>iota</code>，它代表自增值，初始值为0。还可以使用<code>_</code>进行占位，这样可以跳过某个序号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func enumsTest()&#123;</span><br><span class="line">const(</span><br><span class="line">Java = iota  // 枚举类型变量必须有初始值</span><br><span class="line">_   // 使用匿名变量“_”</span><br><span class="line">Go</span><br><span class="line">PHP</span><br><span class="line">JavaScript</span><br><span class="line">)</span><br><span class="line">fmt.Println(Java  , Go, PHP, JavaScript)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">enumsTest()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">0 2 3 4</span><br></pre></td></tr></table></figure></p><p>当然<code>iota</code>的功能比这大多了。假设我们想输出B,KB,MB,GB,TB,PB呢？（1KB=1024B）,相应的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func enumsTest()&#123;</span><br><span class="line">    // B,KB,MB,GB,TB,PB</span><br><span class="line">const(</span><br><span class="line">B = 1 &lt;&lt; (10*iota)</span><br><span class="line">KB</span><br><span class="line">MB</span><br><span class="line">GB</span><br><span class="line">TB</span><br><span class="line">PB</span><br><span class="line">)</span><br><span class="line">fmt.Println(B,KB,MB,GB,TB,PB)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    enumsTest()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">1 1024 1048576 1073741824 1099511627776 1125899906842624</span><br></pre></td></tr></table></figure></p><p>其实上面介绍的就是普通枚举类型和自增值枚举类型。那么到此关于变量、内建变量类型和常量的介绍就到此为止了。</p><h1 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h1><p>1、Go语言的变量类型写在变量名之后；<br>2、编译器可以推测变量的类型，可省写变量类型；<br>3、Go语言中没有char类型，只有rune类型；<br>4、Go语言原生支持复数类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本篇笔记一起来学习Go语言中的变量、内建变量类型和常量这3个非常基础的知识。&lt;/p&gt;
&lt;h1 id=&quot;变量&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="go" scheme="http://blog.licheetools.top/categories/go/"/>
    
    
      <category term="golang" scheme="http://blog.licheetools.top/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记（1）：概述</title>
    <link href="http://blog.licheetools.top/2019/05/10/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E6%A6%82%E8%BF%B0/"/>
    <id>http://blog.licheetools.top/2019/05/10/Go语言学习笔记（1）：概述/</id>
    <published>2019-05-10T09:03:19.000Z</published>
    <updated>2019-11-04T14:01:42.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;
      
    
    </summary>
    
      <category term="go" scheme="http://blog.licheetools.top/categories/go/"/>
    
    
      <category term="golang" scheme="http://blog.licheetools.top/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>SSM搭建二手市场交易平台（二十九）：项目部署上线</title>
    <link href="http://blog.licheetools.top/2018/09/06/SSM%E6%90%AD%E5%BB%BA%E4%BA%8C%E6%89%8B%E5%B8%82%E5%9C%BA%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9A%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF/"/>
    <id>http://blog.licheetools.top/2018/09/06/SSM搭建二手市场交易平台（二十九）：项目部署上线/</id>
    <published>2018-09-06T00:21:06.000Z</published>
    <updated>2019-04-15T14:26:08.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jdk的安装"><a href="#jdk的安装" class="headerlink" title="jdk的安装"></a>jdk的安装</h2><p>1、使用<code>rpm -qa|grep jdk</code>命令查看是否存在jdk。</p><p>2、新建develpoer和setup文件夹，具体是/develpoer/setup；</p><p>3、进入到setup文件夹，执行<code>sudo wget https://download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/jdk-8u201-linux-x64.rpm?AuthParam=1553169636_b11b9e5be288ddf0358ea33e6f97682e</code>，后面的https则是jdk的rpm地址，具体的点击这里<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">jdk8</a>；注意后面的AuthParam，这个需要我们F12调出开发者模式，然后再次点击下载按钮，在headers里面可以直接寻找。然后对下载完的jdk进行重命名，命令如下：<code>sudo mv jdk-8u201-linux-x64.rpm?AuthParam=1553169636_b11b9e5be288ddf0358ea33e6f97682e jdk-8u201-linux-x64.rpm</code>这样名字就发生了改变，变成<code>jdk-8u201-linux-x64.rpm</code>。<br>4、如果觉得下载速度很慢，你可以使用<code>sudo wget http://learning.happymmall.com/jdk/jdk-7u80-linux-x64.rpm</code>这样我就就不需要进行修改名字了。<br>5、接下来使用下面的命令赋予用户权限：<code>sudo chmod +x jdk-7u80-linux-x64.rpm</code>，或者其他的权限，如777权限。</p><p>6、接下来使用下面的命令进行安装jdk：<code>sudo rpm -ivh jdk-7u80-linux-x64.rpm</code>，这样改jdk就直接被安装在setup这个文件夹里面了。如果出现下面的问题，请接着看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu RPM should not be used directly install RPM packages, use Alien instead!</span><br></pre></td></tr></table></figure></p><p>方法1：</p><ol><li><p>先安装 alien 和 fakeroot 这两个工具，其中前者可以将 rpm 包转换为 deb 包。安装命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install alien fakeroot</span><br></pre></td></tr></table></figure></li><li><p>将需要安装的 rpm 包下载备用，假设为 package.rpm</p></li><li><p>使用 alien 将 rpm 包转换为 deb 包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fakeroot alien package.rpm</span><br></pre></td></tr></table></figure></li><li><p>一旦转换成功，我们可以即刻使用以下指令来安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i package.deb</span><br></pre></td></tr></table></figure></li></ol><p>方法:2：<br>1.输入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install rpm alien</span><br></pre></td></tr></table></figure></p><p>2..输入以下代码：（过程有点慢，等待一下）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alien -d package.rpm</span><br></pre></td></tr></table></figure></p><p>3..输入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i package.deb</span><br></pre></td></tr></table></figure></p><p>详细的点击这里<a href="https://blog.csdn.net/suleil1/article/details/49471723" target="_blank" rel="noopener">bug解决方法</a><br>如下图所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-4-ubuntu:~/java/developer/setup$ ls</span><br><span class="line"> jdk1.8_1.8.0202-1_amd64.deb   jdk-8u202-linux-x64.rpm  &apos;jdk-8u202-linux-x64.rpm?AuthParam=1553176185_71b2a824d4d35c4a61c57ccd5f476606&apos;</span><br><span class="line">ubuntu@VM-0-4-ubuntu:~/java/developer/setup$ sudo dpkg -i jdk1.8_1.8.0202-1_amd64.deb</span><br><span class="line">Selecting previously unselected package jdk1.8.</span><br><span class="line">(Reading database ... 86516 files and directories currently installed.)</span><br><span class="line">Preparing to unpack jdk1.8_1.8.0202-1_amd64.deb ...</span><br><span class="line">Unpacking jdk1.8 (1.8.0202-1) ...</span><br><span class="line">Setting up jdk1.8 (1.8.0202-1) ...</span><br><span class="line">ubuntu@VM-0-4-ubuntu:~/java/developer/setup$</span><br></pre></td></tr></table></figure></p><p>之后就会将我们的jdk默认安装在/usr/java/jdk1.8.0_202-amd64下面，我们使用ls或者ll就能查看信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-4-ubuntu:/usr/java/jdk1.8.0_202-amd64$ ll</span><br><span class="line">total 26016</span><br><span class="line">drwxr-xr-x 8 root root     4096 Mar 21 22:24 ./</span><br><span class="line">drwxr-xr-x 4 root root     4096 Mar 21 22:23 ../</span><br><span class="line">drwxr-xr-x 2 root root     4096 Mar 21 22:24 bin/</span><br><span class="line">-rw-r--r-- 1 root root     3244 Dec 16 04:50 COPYRIGHT</span><br><span class="line">drwxr-xr-x 3 root root     4096 Mar 21 22:24 include/</span><br><span class="line">drwxr-xr-x 4 root root     4096 Mar 21 22:23 .java/</span><br><span class="line">-rw-r--r-- 1 root root  5211154 Dec 12 18:20 javafx-src.zip</span><br><span class="line">drwxr-xr-x 5 root root     4096 Mar 21 22:24 jre/</span><br><span class="line">drwxr-xr-x 5 root root     4096 Mar 21 22:24 lib/</span><br><span class="line">-rw-r--r-- 1 root root       40 Dec 16 04:50 LICENSE</span><br><span class="line">drwxr-xr-x 4 root root     4096 Mar 21 22:24 man/</span><br><span class="line">-rw-r--r-- 1 root root      159 Dec 16 04:50 README.html</span><br><span class="line">-rw-r--r-- 1 root root      424 Dec 16 04:50 release</span><br><span class="line">-rw-r--r-- 1 root root 21105955 Dec 16 04:50 src.zip</span><br><span class="line">-rw-r--r-- 1 root root   112724 Dec 12 18:20 THIRDPARTYLICENSEREADME-JAVAFX.txt</span><br><span class="line">-rw-r--r-- 1 root root   153824 Dec 16 04:50 THIRDPARTYLICENSEREADME.txt</span><br><span class="line">ubuntu@VM-0-4-ubuntu:/usr/java/jdk1.8.0_202-amd64$</span><br></pre></td></tr></table></figure></p><p>7、接下来就是环境变量的设置了，使用下面的命令即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure></p><p>在文件的最底部添加下面的代码：（这里面把其他环境也添加了，你可以自己有选择的粘贴）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_202-amd64</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export MAVEN_HOME=/home/ubuntu/java/developer/apache-maven-3.0.5</span><br><span class="line">export NODE_HOME=/usr/local/node-v4.4.7-linux-x64</span><br><span class="line">export RUBY_HOME=/usr/local/ruby</span><br><span class="line">export CATALINA_HOME=/home/ubuntu/java/developer/apache-tomcat-7.0.73</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$CATALINA_HOME/bin:$MAVEN_HOME/bin:$NODE_HOME/bin:/usr/local/bin:$RUBY_HOME/bin</span><br><span class="line"></span><br><span class="line">export LC_ALL=en_US.UTF-8</span><br></pre></td></tr></table></figure></p><p>也可以点击这里<a href="http://learning.happymmall.com/env/" target="_blank" rel="noopener">profile</a>，选择profile文件，然后打开即可。</p><p>8、接下来我们激活刚才的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source  /etc/profile</span><br></pre></td></tr></table></figure></p><p>9、使用<code>java -version</code>查看是否安装成功，出现java的版本就说明成功了。如果出现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error occurred during initialization of VM</span><br><span class="line">java/lang/NoClassDefFoundError: java/lang/Object</span><br></pre></td></tr></table></figure></p><p>，请参考这篇文章：<a href="https://blog.csdn.net/hanxue_wuhen/article/details/71312947" target="_blank" rel="noopener">解决办法</a>或者这篇文章：<a href="https://blog.51cto.com/53cto/1702607" target="_blank" rel="noopener">办法2</a><br>，当然我这里也直接附上解决办法。因为你的<code>/usr/java/jdk1.8.0_202-amd64/jre/lib</code><br>下面缺少<code>rt.jar</code>；还有<code>/usr/java/jdk1.8.0_202-amd64/lib</code>下面缺少<code>tools.jar</code>。那是因为你编译过度，将jar文件编译为<code>tools.pack</code>和<code>rt.pack</code>，这里我们直接使用反编译工具unpack200即可。分两步进行，首先执行反编译，然后移动文件即可。(当然，你完全可以在对应的目录下反编译，这样就不需要移动文件了。)<br>1、反编译，使用下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo unpack200  /usr/java/jdk1.8.0_202-amd64/lib/tools.pack  tools.jar</span><br></pre></td></tr></table></figure></p><p>这样我们的tools.jar就被编译在当前文件夹了。<br>同样执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo unpack200  /usr/java/jdk1.8.0_202-amd64/lib/rt.pack  rt.jar</span><br></pre></td></tr></table></figure></p><p>这样我们的rt.jar就被编译在当前文件夹了。<br>2、移动文件, tools.jar就是在/usr/java/jdk1.8.0_202-amd64/lib文件下面，你使用这样的命令就可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /usr/java/jdk1.8.0_202-amd64/lib/tools.jar /usr/java/jdk1.8.0_202-amd64/lib</span><br></pre></td></tr></table></figure></p><p>而rt.jar则是在/usr/java/jdk1.8.0_202-amd64/jre/lib，记得不要搞错！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /usr/java/jdk1.8.0_202-amd64/lib/rt.jar /usr/java/jdk1.8.0_202-amd64/jre/lib</span><br></pre></td></tr></table></figure></p><p>接下来重复第9步，查看是否成功！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-4-ubuntu:/usr/java/jdk1.8.0_202-amd64/lib$ java -version</span><br><span class="line">java version &quot;1.8.0_202&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_202-b08)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode)</span><br><span class="line">ubuntu@VM-0-4-ubuntu:/usr/java/jdk1.8.0_202-amd64/lib$</span><br></pre></td></tr></table></figure></p><p>如果有多个版本的java，这个java -version是根据你的环境设置来体现的。至此我们java的安装就结束了。</p><h2 id="tomcat的安装"><a href="#tomcat的安装" class="headerlink" title="tomcat的安装"></a>tomcat的安装</h2><p>进入developer文件夹，里面输入以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget http://learning.happymmall.com/tomcat/apache-tomcat-7.0.73.tar.gz</span><br></pre></td></tr></table></figure></p><p>待下载完毕以后，我们就开始解压它，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf apache-tomcat-7.0.73.tar.gz</span><br></pre></td></tr></table></figure></p><p>查看一下，发现没问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-4-ubuntu:~/java/developer$ ll</span><br><span class="line">total 8752</span><br><span class="line">drwxrwxr-x 4 ubuntu ubuntu    4096 Mar 22 10:25 ./</span><br><span class="line">drwxrwxr-x 4 ubuntu ubuntu    4096 Mar 21 18:20 ../</span><br><span class="line">drwxr-xr-x 9 root   root      4096 Mar 22 10:25 apache-tomcat-7.0.73/</span><br><span class="line">-rw-r--r-- 1 root   root   8938514 Apr 17  2017 apache-tomcat-7.0.73.tar.gz</span><br><span class="line">drwxrwxr-x 2 ubuntu ubuntu    4096 Mar 21 22:22 setup/</span><br></pre></td></tr></table></figure></p><p>接下来，我们可以把<code>apache-tomcat-7.0.73.tar.gz</code>移动到setup文件夹下面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv apache-tomcat-7.0.73.tar.gz setup/</span><br></pre></td></tr></table></figure></p><p>发现setup里面是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">drwxrwxr-x 2 ubuntu ubuntu      4096 Mar 22 10:28  ./</span><br><span class="line">drwxrwxr-x 4 ubuntu ubuntu      4096 Mar 22 10:28  ../</span><br><span class="line">-rw-r--r-- 1 root   root     8938514 Apr 17  2017  apache-tomcat-7.0.73.tar.gz</span><br><span class="line">-rw-r--r-- 1 ubuntu ubuntu 156926672 Mar 21 22:22  jdk1.8_1.8.0202-1_amd64.deb</span><br><span class="line">-rw-rw-r-- 1 ubuntu ubuntu 178418154 Mar 21 22:12  jdk-8u202-linux-x64.rpm</span><br><span class="line">-rw-r--r-- 1 root   root       85416 Mar 21 22:20 &apos;jdk-8u202-linux-x64.rpm?AuthParam=1553176185_71b2a824d4d35c4a61c57ccd5f476606&apos;</span><br></pre></td></tr></table></figure></p><p>接下来，我们退回到上一层，也就是developer文件夹，然后进入到apache-tomcat-7.0.73这个文件夹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-4-ubuntu:~/java/developer$ cd apache-tomcat-7.0.73</span><br><span class="line">ubuntu@VM-0-4-ubuntu:~/java/developer/apache-tomcat-7.0.73$ ll</span><br><span class="line">total 124</span><br><span class="line">drwxr-xr-x 9 root   root    4096 Mar 22 10:25 ./</span><br><span class="line">drwxrwxr-x 4 ubuntu ubuntu  4096 Mar 22 10:28 ../</span><br><span class="line">drwxr-xr-x 2 root   root    4096 Mar 22 10:25 bin/</span><br><span class="line">drwxr-xr-x 2 root   root    4096 Nov  8  2016 conf/</span><br><span class="line">drwxr-xr-x 2 root   root    4096 Mar 22 10:25 lib/</span><br><span class="line">-rw-r--r-- 1 root   root   56846 Nov  8  2016 LICENSE</span><br><span class="line">drwxr-xr-x 2 root   root    4096 Nov  8  2016 logs/</span><br><span class="line">-rw-r--r-- 1 root   root    1239 Nov  8  2016 NOTICE</span><br><span class="line">-rw-r--r-- 1 root   root    8965 Nov  8  2016 RELEASE-NOTES</span><br><span class="line">-rw-r--r-- 1 root   root   16195 Nov  8  2016 RUNNING.txt</span><br><span class="line">drwxr-xr-x 2 root   root    4096 Mar 22 10:25 temp/</span><br><span class="line">drwxr-xr-x 7 root   root    4096 Nov  8  2016 webapps/</span><br><span class="line">drwxr-xr-x 2 root   root    4096 Nov  8  2016 work/</span><br><span class="line">ubuntu@VM-0-4-ubuntu:~/java/developer/apache-tomcat-7.0.73$</span><br></pre></td></tr></table></figure></p><p>接下来编辑conf/server.xml文件，使用的命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim conf/server.xml</span><br></pre></td></tr></table></figure></p><p>我们编辑它的目的就是修改utf的字符集，我们直接在当前模式（默认情况），输入/8080，然后回车就能找到这个connection（下面的截图是我们在widows下面的配置。）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F:\tomcat\apache-tomcat-8.5.34\conf\server.xml</span><br></pre></td></tr></table></figure></p><p>{我的路径是这里，你打开它，找到第69-71行代码：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-727121717de4b380.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>添加这一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URIEncoding=&quot;UTF-8&quot;</span><br></pre></td></tr></table></figure></p><p>注意：截图中之所以有是因为我已经配置完了，之前是没有的。}</p><p>你添加这个以后进行保存退出即可。<br>接下来就是开始运行，进入到bin目录，具体的可以参看这些：<br>启动使用：在配置环境的bin目录下使用startup.bat命令；<br>关闭使用：在配置环境的bin目录下使用shutdown.bat命令。<br>这个的配置环境，我们在前面进行了配置，也就是这些：<br>就是<code>${CATALINA_HOME}/bin/startup.bat</code>或者是<code>${CATALINA_HOME}/bin/shutdown.bat</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-4-ubuntu:~/java/developer/apache-tomcat-7.0.73/bin$ sudo ./startup.sh</span><br><span class="line">Using CATALINA_BASE:   /home/ubuntu/java/developer/apache-tomcat-7.0.73</span><br><span class="line">Using CATALINA_HOME:   /home/ubuntu/java/developer/apache-tomcat-7.0.73</span><br><span class="line">Using CATALINA_TMPDIR: /home/ubuntu/java/developer/apache-tomcat-7.0.73/temp</span><br><span class="line">Using JRE_HOME:        /usr</span><br><span class="line">Using CLASSPATH:       /home/ubuntu/java/developer/apache-tomcat-7.0.73/bin/bootstrap.jar:/home/ubuntu/java/developer/apache-tomcat-7.0.73/bin/tomcat-juli.jar</span><br><span class="line">Tomcat started.</span><br><span class="line">ubuntu@VM-0-4-ubuntu:~/java/developer/apache-tomcat-7.0.73/bin$</span><br></pre></td></tr></table></figure></p><p>出现这个Tomcat started.就说明配置成功，且启动成功了。此时，由于我们的防火墙还没有配置，你用公网IP的8080端口就能访问到我们的tomcat首页了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-acb99d9892a64b64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="maven的安装"><a href="#maven的安装" class="headerlink" title="maven的安装"></a>maven的安装</h2><p>我们回到developer文件夹，在里面进行相关操作，在里面输入以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget http://learning.happymmall.com/maven/apache-maven-3.0.5-bin.tar.gz</span><br></pre></td></tr></table></figure></p><p>待下载完毕以后，我们就开始解压它，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf apache-maven-3.0.5-bin.tar.gz</span><br></pre></td></tr></table></figure></p><p>查看一下，发现没问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-4-ubuntu:~/java/developer$ ll</span><br><span class="line">total 5052</span><br><span class="line">drwxrwxr-x 5 ubuntu ubuntu    4096 Mar 22 10:56 ./</span><br><span class="line">drwxrwxr-x 4 ubuntu ubuntu    4096 Mar 21 18:20 ../</span><br><span class="line">drwxr-xr-x 6 root   root      4096 Mar 22 10:56 apache-maven-3.0.5/</span><br><span class="line">-rw-r--r-- 1 root   root   5144659 Apr 17  2017 apache-maven-3.0.5-bin.tar.gz</span><br><span class="line">drwxr-xr-x 9 root   root      4096 Mar 22 10:25 apache-tomcat-7.0.73/</span><br><span class="line">drwxrwxr-x 2 ubuntu ubuntu    4096 Mar 22 10:28 setup/</span><br></pre></td></tr></table></figure></p><p>接下来，我们可以把<code>apache-maven-3.0.5-bin.tar.gz</code>移动到setup文件夹下面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv apache-maven-3.0.5-bin.tar.gz setup/</span><br></pre></td></tr></table></figure></p><p>发现setup里面是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-4-ubuntu:~/java/developer/setup$ ll</span><br><span class="line">total 341356</span><br><span class="line">drwxrwxr-x 2 ubuntu ubuntu      4096 Mar 22 10:57  ./</span><br><span class="line">drwxrwxr-x 5 ubuntu ubuntu      4096 Mar 22 10:57  ../</span><br><span class="line">-rw-r--r-- 1 root   root     5144659 Apr 17  2017  apache-maven-3.0.5-bin.tar.gz</span><br><span class="line">-rw-r--r-- 1 root   root     8938514 Apr 17  2017  apache-tomcat-7.0.73.tar.gz</span><br><span class="line">-rw-r--r-- 1 ubuntu ubuntu 156926672 Mar 21 22:22  jdk1.8_1.8.0202-1_amd64.deb</span><br><span class="line">-rw-rw-r-- 1 ubuntu ubuntu 178418154 Mar 21 22:12  jdk-8u202-linux-x64.rpm</span><br></pre></td></tr></table></figure></p><p>接下来，我们直接输入<code>mvn -version</code>，看是不是成功出现版本号了，如果没有，请检查环境变量是否设置有误:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-4-ubuntu:~/java/developer/apache-maven-3.0.5$ mvn -version</span><br><span class="line">Apache Maven 3.0.5 (r01de14724cdef164cd33c7c8c2fe155faf9602da; 2013-02-19 21:51:28+0800)</span><br><span class="line">Maven home: /home/ubuntu/java/developer/apache-maven-3.0.5</span><br><span class="line">Java version: 1.8.0_202, vendor: Oracle Corporation</span><br><span class="line">Java home: /usr/java/jdk1.8.0_202-amd64/jre</span><br><span class="line">Default locale: en_US, platform encoding: UTF-8</span><br><span class="line">OS name: &quot;linux&quot;, version: &quot;4.15.0-29-generic&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;</span><br></pre></td></tr></table></figure></p><h2 id="vsftpd的安装"><a href="#vsftpd的安装" class="headerlink" title="vsftpd的安装"></a>vsftpd的安装</h2><p>同样我们退回到developer文件夹，我们使用下面的命令进行安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vsftpd</span><br></pre></td></tr></table></figure></p><p>如果你使用centOs，则使用<code>sudo yum-y install vsftpd</code>。现在我们需要创建一个文件夹，退回到developer文件夹的上一层，因为我们创建的这个product文件和这个developer的是同级别的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-4-ubuntu:~/java$ mkdir product</span><br><span class="line">ubuntu@VM-0-4-ubuntu:~/java$ cd product</span><br><span class="line">ubuntu@VM-0-4-ubuntu:~/java/product$ ll</span><br><span class="line">total 8</span><br><span class="line">drwxrwxr-x 2 ubuntu ubuntu 4096 Mar 22 11:13 ./</span><br><span class="line">drwxrwxr-x 5 ubuntu ubuntu 4096 Mar 22 11:13 ../</span><br><span class="line">ubuntu@VM-0-4-ubuntu:~/java/product$</span><br></pre></td></tr></table></figure></p><p>接着进入到product文件夹，在里面新建一个ftpfile，然后赋予其可以登录ftpserver，但是没有登录其他的权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-4-ubuntu:~/java/product$ mkdir ftpfile</span><br><span class="line">ubuntu@VM-0-4-ubuntu:~/java/product$ sudo useradd ftpuser -d /product/ftpfile -s /sbin/nologin</span><br></pre></td></tr></table></figure></p><p>紧接着赋予其用户组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-4-ubuntu:~/java/product$ sudo chown -R ftpuser.ftpuser ./ftpfile/</span><br></pre></td></tr></table></figure></p><p>查看一下，发现多了一个ftpfile文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-4-ubuntu:~/java/product$ ll</span><br><span class="line">total 12</span><br><span class="line">drwxrwxr-x 3 ubuntu  ubuntu  4096 Mar 22 11:15 ./</span><br><span class="line">drwxrwxr-x 5 ubuntu  ubuntu  4096 Mar 22 11:13 ../</span><br><span class="line">drwxrwxr-x 2 ftpuser ftpuser 4096 Mar 22 11:15 ftpfile/</span><br></pre></td></tr></table></figure></p><p>接下来我们重置ftpuser的登录密码：（我的密码是admin123）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-4-ubuntu:~/java/product$ sudo passwd ftpuser</span><br><span class="line">Enter new UNIX password: </span><br><span class="line">Retype new UNIX password: </span><br><span class="line">passwd: password updated successfully</span><br><span class="line">ubuntu@VM-0-4-ubuntu:~/java/product$</span><br></pre></td></tr></table></figure></p><p>接下来进入到/etc/vsftpd文件，如果没有改文件夹，说明那些都是直接在/etc下面，不安全，我们在/etc新建一个vsftpd的文件夹，依次执行下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /etc/ftpusers /etc/vsftpd</span><br><span class="line">sudo mv /etc/vsftpd.conf /etc/vsftpd</span><br></pre></td></tr></table></figure></p><p>紧接着，进入vsftpd文件夹，在里面执行<code>sudo vim chroot_list</code>，在里面添加<code>ftpuser</code>即可，然后保存退出即可。</p><p>下面修改其安全策略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/selinux/config</span><br></pre></td></tr></table></figure></p><p>确保里面的代码是这样的，没有就进行添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELINUX=disabled</span><br><span class="line"></span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></table></figure></p><p>当然你可以使用下面的命令，这个结果和刚才修改config的效果是一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo setsebool -P ftp_home_dir 1</span><br></pre></td></tr></table></figure></p><p>接下来我们备份一下这个<code>vsftpd.conf</code>，并将线上的进行复制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mv vsftpd.conf vsftpd.conf.bak</span><br><span class="line"></span><br><span class="line">sudo wget http://learning.happymmall.com/vsftpdconfig/vsftpd.conf</span><br></pre></td></tr></table></figure></p><p>查看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-4-ubuntu:/etc/vsftpd$ ll</span><br><span class="line">total 32</span><br><span class="line">drwxr-xr-x   2 root root 4096 Mar 22 12:01 ./</span><br><span class="line">drwxr-xr-x 100 root root 4096 Mar 22 11:34 ../</span><br><span class="line">-rw-r--r--   1 root root    8 Mar 22 11:38 chroot_list</span><br><span class="line">-rw-r--r--   1 root root  132 Mar 22 11:30 ftpusers</span><br><span class="line">-rw-r--r--   1 root root 4786 Apr 17  2017 vsftpd.conf</span><br><span class="line">-rw-r--r--   1 root root 5850 Mar 22 11:32 vsftpd.conf.bak</span><br></pre></td></tr></table></figure></p><p>这样vsftpd我们就安装好了。</p><h2 id="nginx的安装"><a href="#nginx的安装" class="headerlink" title="nginx的安装"></a>nginx的安装</h2><p>因为nginx需要编译，因此我们需要进入到setup这个文件夹，在里面执行下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget http://learning.happymmall.com/nginx/linux-nginx-1.10.2.tar.gz</span><br></pre></td></tr></table></figure></p><p>nginx的安装需要依赖，因此我们先执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential libtool libpcre3  libpcre3-dev zlib1g-dev openssl</span><br></pre></td></tr></table></figure></p><p>查看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-4-ubuntu:~/java/developer/setup$ ll</span><br><span class="line">total 342252</span><br><span class="line">drwxrwxr-x 2 ubuntu ubuntu      4096 Mar 22 12:05  ./</span><br><span class="line">drwxrwxr-x 5 ubuntu ubuntu      4096 Mar 22 10:57  ../</span><br><span class="line">-rw-r--r-- 1 root   root     5144659 Apr 17  2017  apache-maven-3.0.5-bin.tar.gz</span><br><span class="line">-rw-r--r-- 1 root   root     8938514 Apr 17  2017  apache-tomcat-7.0.73.tar.gz</span><br><span class="line">-rw-r--r-- 1 ubuntu ubuntu 156926672 Mar 21 22:22  jdk1.8_1.8.0202-1_amd64.deb</span><br><span class="line">-rw-rw-r-- 1 ubuntu ubuntu 178418154 Mar 21 22:12  jdk-8u202-linux-x64.rpm</span><br><span class="line">-rw-r--r-- 1 root   root       85416 Mar 21 22:20 &apos;jdk-8u202-linux-x64.rpm?AuthParam=1553176185_71b2a824d4d35c4a61c57ccd5f476606&apos;</span><br><span class="line">-rw-r--r-- 1 root   root      910812 Apr 17  2017  linux-nginx-1.10.2.tar.gz</span><br></pre></td></tr></table></figure></p><p>接下来进行解压安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf linux-nginx-1.10.2.tar.gz</span><br></pre></td></tr></table></figure></p><p>查看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-4-ubuntu:~/java/developer/setup$ ll</span><br><span class="line">total 342256</span><br><span class="line">drwxrwxr-x 3 ubuntu ubuntu      4096 Mar 22 12:16  ./</span><br><span class="line">drwxrwxr-x 5 ubuntu ubuntu      4096 Mar 22 10:57  ../</span><br><span class="line">-rw-r--r-- 1 root   root     5144659 Apr 17  2017  apache-maven-3.0.5-bin.tar.gz</span><br><span class="line">-rw-r--r-- 1 root   root     8938514 Apr 17  2017  apache-tomcat-7.0.73.tar.gz</span><br><span class="line">-rw-r--r-- 1 ubuntu ubuntu 156926672 Mar 21 22:22  jdk1.8_1.8.0202-1_amd64.deb</span><br><span class="line">-rw-rw-r-- 1 ubuntu ubuntu 178418154 Mar 21 22:12  jdk-8u202-linux-x64.rpm</span><br><span class="line">-rw-r--r-- 1 root   root       85416 Mar 21 22:20 &apos;jdk-8u202-linux-x64.rpm?AuthParam=1553176185_71b2a824d4d35c4a61c57ccd5f476606&apos;</span><br><span class="line">-rw-r--r-- 1 root   root      910812 Apr 17  2017  linux-nginx-1.10.2.tar.gz</span><br><span class="line">drwxr-xr-x 8   1001   1001      4096 Oct 18  2016  nginx-1.10.2/</span><br></pre></td></tr></table></figure></p><p>进入解压好的nginx-1.10.2目录，查看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-4-ubuntu:~/java/developer/setup/nginx-1.10.2$ ll</span><br><span class="line">total 700</span><br><span class="line">drwxr-xr-x 8   1001   1001   4096 Oct 18  2016 ./</span><br><span class="line">drwxrwxr-x 3 ubuntu ubuntu   4096 Mar 22 12:16 ../</span><br><span class="line">drwxr-xr-x 6   1001   1001   4096 Mar 22 12:16 auto/</span><br><span class="line">-rw-r--r-- 1   1001   1001 264254 Oct 18  2016 CHANGES</span><br><span class="line">-rw-r--r-- 1   1001   1001 402997 Oct 18  2016 CHANGES.ru</span><br><span class="line">drwxr-xr-x 2   1001   1001   4096 Mar 22 12:16 conf/</span><br><span class="line">-rwxr-xr-x 1   1001   1001   2481 Oct 18  2016 configure*</span><br><span class="line">drwxr-xr-x 4   1001   1001   4096 Mar 22 12:16 contrib/</span><br><span class="line">drwxr-xr-x 2   1001   1001   4096 Mar 22 12:16 html/</span><br><span class="line">-rw-r--r-- 1   1001   1001   1397 Oct 18  2016 LICENSE</span><br><span class="line">drwxr-xr-x 2   1001   1001   4096 Mar 22 12:16 man/</span><br><span class="line">-rw-r--r-- 1   1001   1001     49 Oct 18  2016 README</span><br><span class="line">drwxr-xr-x 9   1001   1001   4096 Mar 22 12:16 src/</span><br><span class="line">ubuntu@VM-0-4-ubuntu:~/java/developer/setup/nginx-1.10.2$</span><br></pre></td></tr></table></figure></p><p>接下来执行下面的命令：(默认编译为当前路径)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure</span><br></pre></td></tr></table></figure></p><p>紧接着执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure></p><p>如果运行出现下面的情况，请不要慌：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make[1]: *** [objs/src/core/ngx_murmurhash.o] Error 1</span><br><span class="line">make[1]: Leaving directory &apos;/home/ubuntu/java/developer/setup/nginx-1.10.2&apos;</span><br><span class="line">Makefile:8: recipe for target &apos;build&apos; failed</span><br><span class="line">make: *** [build] Error 2</span><br></pre></td></tr></table></figure></p><p>找到我们<code>nginx-1.10.2/objs/Makefile</code>文件，将里面的-Werror删除掉即可：<br><img src="https://upload-images.jianshu.io/upload_images/8964398-888fadaed2128fe8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>（注意只是删除-Werror，改行其余信息不能动），之后重新运行刚才的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure></p><p>如果最后出现下面的说明，就说明可以了，我们继续往后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make[1]: Leaving directory &apos;/home/ubuntu/java/developer/setup/nginx-1.10.2&apos;</span><br></pre></td></tr></table></figure></p><p>继续执行安装命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p><p>后面的防火墙配置，我们就专门会说的。接下来配置其详细信息。<br>查看一下它所在的目录：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-4-ubuntu:~/java/developer/setup/nginx-1.10.2$ whereis nginx</span><br><span class="line">nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/local/nginx /usr/share/nginx /usr/share/man/man8/nginx.8.gz</span><br></pre></td></tr></table></figure></p><p>我们进入到/usr/local/nginx下面，然后进入到conf里面，接着编辑主文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim nginx.conf</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-816e7d0cabc6a3eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>我们往下拉，我们https server的位置添加下面一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include vhost/*.conf;</span><br></pre></td></tr></table></figure></p><p>（截图是我已经配置好的，目的是让大家对此有一个更清醒的认识。）</p><p>紧接着在nginx.conf文件的同级目录下面新建vhost文件夹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir vhost</span><br></pre></td></tr></table></figure></p><p>进入到该文件夹，添加我们反向代理的文件。</p><p>当然你也可以参考这篇文章进行安装：<a href="https://www.cnblogs.com/EasonJim/p/7806879.html" target="_blank" rel="noopener">ubuntu安装nginx</a></p><h2 id="mysql的安装"><a href="#mysql的安装" class="headerlink" title="mysql的安装"></a>mysql的安装</h2><p>首先查看是否安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -qa| grep mysql-server</span><br></pre></td></tr></table></figure></p><p>没有我们就开始安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure></p><p>这个我们就直接安装在java这个文件夹里面了。<br>然后修改MySQL的字符集：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure></p><p>在mysqld部分添加下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">character-set-server=utf8</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure></p><p>然后是mysql的启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo sysv-rc-conf mysqld on</span><br><span class="line">sudo sysv-rc-conf --list mysqld</span><br></pre></td></tr></table></figure></p><p>注意一下，我们要的是2-5是开的，0和6是关闭的即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-4-ubuntu:/etc/apt$ sudo sysv-rc-conf --list mysqld</span><br><span class="line">mysqld       2:on       3:on    4:on    5:on</span><br><span class="line">ubuntu@VM-0-4-ubuntu:/etc/apt$</span><br></pre></td></tr></table></figure></p><p>关于MySQL的防火墙的配置，我们在后面也会说明的。<br>接下来我们开始启动mysql，使用下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure></p><p>如果提示没有sysv-rc-conf，请参看这篇文章：<a href="https://blog.csdn.net/sw1009374593/article/details/84929494" target="_blank" rel="noopener">ubuntu 18 当使用命令sudo apt-get install sysv-rc-conf安装不上时，提示“ E: 无法定位软件包问题</a>.<br>如果重启出现<code>Can &#39;t connect to local MySQL server through socket &#39;/tmp/mysql.sock &#39;(2) &quot;;</code>的情况，请注意，我们应该查看这篇文章：<a href="https://blog.csdn.net/hjf161105/article/details/78850658" target="_blank" rel="noopener">解决办法</a>。或者这篇文章：<a href="https://blog.csdn.net/u012150360/article/details/84546192" target="_blank" rel="noopener">办法2</a><br>开始创建数据库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database `secondhandmarket` default character set utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></table></figure></p><p>插入新用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into mysql.user(host,user,authentication_string)values(&quot;127.0.0.1&quot;,&quot;envy&quot;,authentication_string(&quot;envy&quot;));</span><br></pre></td></tr></table></figure></p><p>创建数据表，我们首先查看sql的路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/ubuntu/java/squirrel/secondhandmarket.sql</span><br></pre></td></tr></table></figure></p><p>然后进入mysql，我们首先使用<code>use secondhandmarket;</code>，接着执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /home/ubuntu/java/squirrel/secondhandmarket.sql</span><br></pre></td></tr></table></figure></p><p>接着查看一下表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br><span class="line"></span><br><span class="line">select * from admin\G;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;jdk的安装&quot;&gt;&lt;a href=&quot;#jdk的安装&quot; class=&quot;headerlink&quot; title=&quot;jdk的安装&quot;&gt;&lt;/a&gt;jdk的安装&lt;/h2&gt;&lt;p&gt;1、使用&lt;code&gt;rpm -qa|grep jdk&lt;/code&gt;命令查看是否存在jdk。&lt;/p&gt;
&lt;p&gt;2
      
    
    </summary>
    
      <category term="java" scheme="http://blog.licheetools.top/categories/java/"/>
    
    
      <category term="SSM框架" scheme="http://blog.licheetools.top/tags/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="JAVA后端" scheme="http://blog.licheetools.top/tags/JAVA%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>SSM搭建二手市场交易平台（二十八）：前台订单获取以及后台管理员订单管理功能开发</title>
    <link href="http://blog.licheetools.top/2018/09/05/SSM%E6%90%AD%E5%BB%BA%E4%BA%8C%E6%89%8B%E5%B8%82%E5%9C%BA%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9A%E5%89%8D%E5%8F%B0%E8%AE%A2%E5%8D%95%E8%8E%B7%E5%8F%96%E4%BB%A5%E5%8F%8A%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E5%91%98%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91/"/>
    <id>http://blog.licheetools.top/2018/09/05/SSM搭建二手市场交易平台（二十八）：前台订单获取以及后台管理员订单管理功能开发/</id>
    <published>2018-09-05T14:21:06.000Z</published>
    <updated>2019-04-15T14:24:13.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本篇我们来完成前台获取订单详情，用户个人中心查看订单以及后台管理员订单管理等功能的开发，里面涉及到的知识点挺多的，需要好好理解。</p><h2 id="前台获取订单详情"><a href="#前台获取订单详情" class="headerlink" title="前台获取订单详情"></a>前台获取订单详情</h2><p>首先我们打开OrderController.java这个文件，里面写入代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line">     * 前台获取订单详情</span><br><span class="line">     * @author lenovo</span><br><span class="line">     * */</span><br><span class="line">    @RequestMapping(value = &quot;detail.do&quot;)  //这里就是具体的每个方法的url链接</span><br><span class="line">    @ResponseBody   //自动序列化json功能</span><br><span class="line">    public ServerResponse detail(HttpSession session,Long orderNo)&#123;</span><br><span class="line">        //验证用户是否登录</span><br><span class="line">        User user =(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">        //未登录需要用户强制登录</span><br><span class="line">        if(user ==null)&#123;</span><br><span class="line">            return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),ResponseCode.NEED_LOGIN.getDesc());</span><br><span class="line">        &#125;</span><br><span class="line">        //实现我们前台获取订单详情的逻辑</span><br><span class="line">        return iOrderService.getOrderDetail(user.getId(),orderNo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>接着打开IOrderService.Java文件，里面新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerResponse&lt;OrderVo&gt; getOrderDetail(Integer userId, Long orderNo);  //前台获取订单详情</span><br></pre></td></tr></table></figure></p><p>最后我们打开OrderServiceImpl.java文件，里面的新增代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line">     * 前台获取订单详情</span><br><span class="line">     * @author lenovo</span><br><span class="line">     * */</span><br><span class="line">    public ServerResponse&lt;OrderVo&gt; getOrderDetail(Integer userId,Long orderNo)&#123;</span><br><span class="line">        Order order =orderMapper.selectOrderByUserIdAndOrderNo(userId,orderNo);</span><br><span class="line">        if(order !=null)&#123;</span><br><span class="line">            List&lt;OrderItem&gt; orderItemList =orderItemMapper.getOrderItemByUserIdAndOrderNo(userId,orderNo);</span><br><span class="line">            OrderVo orderVo =assembleOrderVo(order,orderItemList);</span><br><span class="line">            return ServerResponse.createBySuccess(orderVo);</span><br><span class="line">        &#125;</span><br><span class="line">        return ServerResponse.createByErrorMessage(&quot;没有找到该订单&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这样我们前台获取订单详情功能开发就完成了，接下来我们来开发用户个人中心查看订单这个功能。</p><h2 id="用户个人中心查看订单"><a href="#用户个人中心查看订单" class="headerlink" title="用户个人中心查看订单"></a>用户个人中心查看订单</h2><p>首先我们打开OrderController.java这个文件，里面写入代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 用户个人中心查看订单（需要分页）</span><br><span class="line"> * @author lenovo</span><br><span class="line"> * */</span><br><span class="line">@RequestMapping(value = &quot;list.do&quot;)  //这里就是具体的每个方法的url链接</span><br><span class="line">@ResponseBody   //自动序列化json功能</span><br><span class="line">public ServerResponse list(HttpSession session,@RequestParam(value = &quot;pageNum&quot; ,defaultValue = &quot;1&quot;)int pageNum,</span><br><span class="line">                           @RequestParam(value = &quot;pageSize&quot; ,defaultValue = &quot;10&quot;)int pageSize)&#123;</span><br><span class="line">    //验证用户是否登录</span><br><span class="line">    User user =(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">    //未登录需要用户强制登录</span><br><span class="line">    if(user ==null)&#123;</span><br><span class="line">        return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),ResponseCode.NEED_LOGIN.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line">    //实现我们用户个人中心查看订单的逻辑</span><br><span class="line">    return iOrderService.getOrderList(user.getId(),pageNum,pageSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着打开IOrderService.Java文件，里面新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerResponse&lt;PageInfo&gt; getOrderList(Integer userId, int pageNum, int pageSize);   //前台用户个人中心查看订单（需要分页）</span><br></pre></td></tr></table></figure></p><p>最后我们打开OrderServiceImpl.java文件，里面的新增代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/***</span><br><span class="line"> * 前台用户个人中心查看订单（需要分页）</span><br><span class="line"> * @author lenovo</span><br><span class="line"> * */</span><br><span class="line">public ServerResponse&lt;PageInfo&gt; getOrderList(Integer userId,int pageNum,int pageSize)&#123;</span><br><span class="line">    PageHelper.startPage(pageNum,pageSize);</span><br><span class="line"></span><br><span class="line">    List&lt;Order&gt; orderList =orderMapper.selectOrderByUserId(userId);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    List&lt;OrderVo&gt; orderVoList =assembleOrderVoList(orderList,userId);</span><br><span class="line">    PageInfo pageResult =new PageInfo(orderList);</span><br><span class="line">    pageResult.setList(orderVoList);</span><br><span class="line">    return ServerResponse.createBySuccess(pageResult);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">private List&lt;OrderVo&gt; assembleOrderVoList(List&lt;Order&gt; orderList,Integer userId)&#123;</span><br><span class="line">    //将List&lt;Order&gt; 对象转换为List&lt;OrderVo&gt;对象</span><br><span class="line">    List&lt;OrderVo&gt; orderVoList =Lists.newArrayList();</span><br><span class="line">    for(Order order:orderList)&#123;</span><br><span class="line">        List&lt;OrderItem&gt; orderItemList =Lists.newArrayList();</span><br><span class="line">        //判断一下是不是管理员，管理员查询时不需要传入参数userId</span><br><span class="line">        if(userId ==null)&#123;</span><br><span class="line">            //todo 管理员查询时不需要传入参数userId</span><br><span class="line">            orderItemList =orderItemMapper.getOrderItemByOrderNo(order.getOrderNo());</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            orderItemList =orderItemMapper.getOrderItemByUserIdAndOrderNo(userId,order.getOrderNo());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OrderVo orderVo =assembleOrderVo(order,orderItemList);</span><br><span class="line">        orderVoList.add(orderVo);</span><br><span class="line">    &#125;</span><br><span class="line">    return orderVoList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意一下，这里我们管理员查询订单的时候是可以不用userId的，因此需要自己去配置一个查询语句：<code>orderItemList =orderItemMapper.getOrderItemByOrderNo(order.getOrderNo());</code>我们打开OrderItemMapper.java文件，里面新增代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;OrderItem&gt; getOrderItemByOrderNo(@Param(value = &quot;orderNo&quot;)Long orderNo);</span><br></pre></td></tr></table></figure></p><p>然后打开OrderItemMapper.xml文件，里面新增代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getOrderItemByOrderNo&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;long&quot;&gt;</span><br><span class="line">  select</span><br><span class="line">  &lt;include refid=&quot;Base_Column_List&quot;/&gt;</span><br><span class="line">  from store_order_item</span><br><span class="line">  where order_no =#&#123;orderNo&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p><p>这样我们前台用户个人中心查看订单的功能就实现了，那么也就意味着我们前台关于订单的功能开发也就完成了。接下来我们需要去完成后台管理员关于订单模块的功能。</p><h2 id="后台管理员查询订单"><a href="#后台管理员查询订单" class="headerlink" title="后台管理员查询订单"></a>后台管理员查询订单</h2><p>首先我们打开controller这个包，在backend这个包里面新建OrderManageController.java这个文件，里面写入代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package top.store.controller.backend;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.github.pagehelper.PageInfo;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line">import top.store.common.Const;</span><br><span class="line">import top.store.common.ResponseCode;</span><br><span class="line">import top.store.common.ServerResponse;</span><br><span class="line">import top.store.pojo.User;</span><br><span class="line">import top.store.service.IOrderService;</span><br><span class="line">import top.store.service.IUserService;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/manage/order&quot;)</span><br><span class="line">public class OrderManageController &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private IUserService iUserService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private IOrderService iOrderService;</span><br><span class="line"></span><br><span class="line">    /****</span><br><span class="line">     *</span><br><span class="line">     * 后台管理员查看订单（需要分页）</span><br><span class="line">     * */</span><br><span class="line">    @RequestMapping(&quot;list.do&quot;)</span><br><span class="line">    @ResponseBody   //自动序列化json功能</span><br><span class="line">    public ServerResponse&lt;PageInfo&gt; orderList(HttpSession session,@RequestParam(value = &quot;pageNum&quot; ,defaultValue = &quot;1&quot;)int pageNum,</span><br><span class="line">                                              @RequestParam(value = &quot;pageSize&quot; ,defaultValue = &quot;10&quot;)int pageSize)&#123;</span><br><span class="line">        //判断一下登录情况</span><br><span class="line">        User user=(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">        if(user ==null)&#123;</span><br><span class="line">            return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),&quot;用户未登录，请登录&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断一下是不是管理员身份</span><br><span class="line">        if(iUserService.checkAdminRole(user).isSuccess())&#123;</span><br><span class="line">            //如果是管理员就增加查看订单（需要分页）的逻辑</span><br><span class="line">            return iOrderService.manageList(pageNum,pageSize);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return ServerResponse.createByErrorMessage(&quot;无权限操作，需要管理员权限&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着打开IOrderService.Java文件，里面新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerResponse&lt;PageInfo&gt; manageList(int pageNum,int pageSize);    //后台管理员查看订单（需要分页）</span><br></pre></td></tr></table></figure></p><p>最后我们打开OrderServiceImpl.java文件，里面的新增代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * 后台管理员查询订单(不需要userId)</span><br><span class="line"> * */</span><br><span class="line">public ServerResponse&lt;PageInfo&gt; manageList(int pageNum,int pageSize)&#123;</span><br><span class="line">    PageHelper.startPage(pageNum,pageSize);</span><br><span class="line">    List&lt;Order&gt; orderList =orderMapper.selectAllOrder();</span><br><span class="line"></span><br><span class="line">    List&lt;OrderVo&gt; orderVoList =this.assembleOrderVoList(orderList,null);</span><br><span class="line">    PageInfo pageResult =new PageInfo(orderList);</span><br><span class="line">    pageResult.setList(orderVoList);</span><br><span class="line">    return ServerResponse.createBySuccess(pageResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样后台管理员查询订单的功能就实现了，接下来我们就去实现后台管理员获取订单详情的功能了。</p><h2 id="后台管理员获取订单详情"><a href="#后台管理员获取订单详情" class="headerlink" title="后台管理员获取订单详情"></a>后台管理员获取订单详情</h2><p>首先我们打开OrderManageController.java这个文件，里面写入代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/****</span><br><span class="line"> *</span><br><span class="line"> * 后台管理员获取订单详情</span><br><span class="line"> * */</span><br><span class="line">@RequestMapping(&quot;detail.do&quot;)</span><br><span class="line">@ResponseBody   //自动序列化json功能</span><br><span class="line">public ServerResponse&lt;OrderVo&gt; orderDetail(HttpSession session, Long orderNo)&#123;</span><br><span class="line">    //判断一下登录情况</span><br><span class="line">    User user=(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">    if(user ==null)&#123;</span><br><span class="line">        return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),&quot;用户未登录，请登录&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断一下是不是管理员身份</span><br><span class="line">    if(iUserService.checkAdminRole(user).isSuccess())&#123;</span><br><span class="line">        //如果是管理员就增加获取订单详情的逻辑</span><br><span class="line">        return iOrderService.manageDetail(orderNo);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return ServerResponse.createByErrorMessage(&quot;无权限操作，需要管理员权限&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着打开IOrderService.Java文件，里面新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerResponse&lt;OrderVo&gt; manageDetail(Long orderNo);  //后台管理员获取订单详情</span><br></pre></td></tr></table></figure></p><p>最后我们打开OrderServiceImpl.java文件，里面的新增代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * 后台管理员获取订单详情</span><br><span class="line"> * */</span><br><span class="line">public ServerResponse&lt;OrderVo&gt; manageDetail(Long orderNo)&#123;</span><br><span class="line">    Order order =orderMapper.selectOrderByOrderNo(orderNo);</span><br><span class="line">    if(order !=null)&#123;</span><br><span class="line">        List&lt;OrderItem&gt; orderItemList =orderItemMapper.getOrderItemByOrderNo(orderNo);</span><br><span class="line">        OrderVo orderVo =assembleOrderVo(order,orderItemList);</span><br><span class="line">        return ServerResponse.createBySuccess(orderVo);</span><br><span class="line">    &#125;</span><br><span class="line">    return ServerResponse.createByErrorMessage(&quot;对不起，该订单并不存在&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样后台管理员获取订单详情的功能就实现了，接下来我们就去实现后台管理员搜索订单的功能。</p><h2 id="后台管理员搜索订单"><a href="#后台管理员搜索订单" class="headerlink" title="后台管理员搜索订单"></a>后台管理员搜索订单</h2><p>首先我们打开OrderManageController.java这个文件，里面写入代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/****</span><br><span class="line">     *</span><br><span class="line">     * 后台管理员搜索订单(有分页)</span><br><span class="line">     * */</span><br><span class="line">    @RequestMapping(&quot;search.do&quot;)</span><br><span class="line">    @ResponseBody   //自动序列化json功能</span><br><span class="line">    public ServerResponse&lt;PageInfo&gt; orderSearch(HttpSession session, Long orderNo,@RequestParam(value = &quot;pageNum&quot; ,defaultValue = &quot;1&quot;)int pageNum,</span><br><span class="line">                                               @RequestParam(value = &quot;pageSize&quot; ,defaultValue = &quot;10&quot;)int pageSize)&#123;</span><br><span class="line">        //判断一下登录情况</span><br><span class="line">        User user=(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">        if(user ==null)&#123;</span><br><span class="line">            return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),&quot;用户未登录，请登录&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断一下是不是管理员身份</span><br><span class="line">        if(iUserService.checkAdminRole(user).isSuccess())&#123;</span><br><span class="line">            //如果是管理员就增加搜索订单的逻辑</span><br><span class="line">            return iOrderService.manageSearch(orderNo,pageNum,pageSize);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return ServerResponse.createByErrorMessage(&quot;无权限操作，需要管理员权限&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>接着打开IOrderService.Java文件，里面新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerResponse&lt;PageInfo&gt; manageSearch(Long orderNo,int pageNum,int pageSize);  //后台管理员搜索订单(有分页)</span><br></pre></td></tr></table></figure></p><p>最后我们打开OrderServiceImpl.java文件，里面的新增代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/****</span><br><span class="line">     *</span><br><span class="line">     * 后台管理员搜索订单(有分页)</span><br><span class="line">     * */</span><br><span class="line">    public ServerResponse&lt;PageInfo&gt; manageSearch(Long orderNo,int pageNum,int pageSize)&#123;</span><br><span class="line">        PageHelper.startPage(pageNum,pageSize);</span><br><span class="line">        Order order =orderMapper.selectOrderByOrderNo(orderNo);</span><br><span class="line"></span><br><span class="line">        if(order !=null)&#123;</span><br><span class="line">            List&lt;OrderItem&gt; orderItemList =orderItemMapper.getOrderItemByOrderNo(orderNo);</span><br><span class="line">            OrderVo orderVo =assembleOrderVo(order,orderItemList);</span><br><span class="line"></span><br><span class="line">            PageInfo pageResult =new PageInfo(Lists.newArrayList(order));</span><br><span class="line">            pageResult.setList(Lists.newArrayList(orderVo));</span><br><span class="line">            return ServerResponse.createBySuccess(pageResult);</span><br><span class="line">        &#125;</span><br><span class="line">        return ServerResponse.createByErrorMessage(&quot;对不起，该订单并不存在&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这样后台管理员搜索订单的功能就实现了，接下来我们就去实现后台管理员订单发货的功能。</p><h2 id="后台管理员订单发货"><a href="#后台管理员订单发货" class="headerlink" title="后台管理员订单发货"></a>后台管理员订单发货</h2><p>首先我们打开OrderManageController.java这个文件，里面写入代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/****</span><br><span class="line"> *</span><br><span class="line"> * 后台管理员订单发货</span><br><span class="line"> * */</span><br><span class="line">@RequestMapping(&quot;send_goods.do&quot;)</span><br><span class="line">@ResponseBody   //自动序列化json功能</span><br><span class="line">public ServerResponse&lt;String&gt; OrderSendGoods(HttpSession session, Long orderNo)&#123;</span><br><span class="line">    //判断一下登录情况</span><br><span class="line">    User user=(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">    if(user ==null)&#123;</span><br><span class="line">        return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),&quot;用户未登录，请登录&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断一下是不是管理员身份</span><br><span class="line">    if(iUserService.checkAdminRole(user).isSuccess())&#123;</span><br><span class="line">        //如果是管理员就增加获取订单发货的逻辑</span><br><span class="line">        return iOrderService.manageSendGoods(orderNo);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return ServerResponse.createByErrorMessage(&quot;无权限操作，需要管理员权限&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着打开IOrderService.Java文件，里面新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerResponse&lt;String&gt; manageSendGoods(Long orderNo);   //后台管理员订单发货</span><br></pre></td></tr></table></figure></p><p>最后我们打开OrderServiceImpl.java文件，里面的新增代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/****</span><br><span class="line"> *</span><br><span class="line"> * 后台管理员订单发货</span><br><span class="line"> * */</span><br><span class="line">public ServerResponse&lt;String&gt; manageSendGoods(Long orderNo)&#123;</span><br><span class="line">    Order order =orderMapper.selectOrderByOrderNo(orderNo);</span><br><span class="line"></span><br><span class="line">    //判断订单状态是否是已支付，然后进行发货</span><br><span class="line">    if(order !=null)&#123;</span><br><span class="line">        if(order.getStatus()==Const.OrderStatusEnum.PAID.getCode())&#123;</span><br><span class="line">            order.setStatus(Const.OrderStatusEnum.SHIPPED.getCode());  //修改状态为发货</span><br><span class="line">            order.setSendTime(new Date());  //修改发货时间为现在</span><br><span class="line">            orderMapper.updateByPrimaryKeySelective(order);  //更新该订单信息</span><br><span class="line">            return ServerResponse.createBySuccessMassage(&quot;发货成功&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ServerResponse.createByErrorMessage(&quot;对不起，该订单并不存在&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样本篇我们关于前台获取订单详情，用户个人中心查看订单以及后台管理员订单管理等功能的开发介绍就到此为止了，接下来是进行各个相关接口的测试。</p><p> 由于测试比较简单，这里直接附上几张测试截图即可，不作过多说明：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2c3d8f93afb2823a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e2fdca568796a672.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>那么到此为止，我们所有的功能都开发完毕，后面就是服务器的配置与部署了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本篇我们来完成前台获取订单详情，用户个人中心查看订单以及后台管理员订单管理等功能的开发，里面涉及到的知识点挺多的，需要好好理
      
    
    </summary>
    
      <category term="java" scheme="http://blog.licheetools.top/categories/java/"/>
    
    
      <category term="SSM框架" scheme="http://blog.licheetools.top/tags/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="JAVA后端" scheme="http://blog.licheetools.top/tags/JAVA%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>SSM搭建二手市场交易平台（二十七）：取消订单和获取商品信息功能开发</title>
    <link href="http://blog.licheetools.top/2018/09/05/SSM%E6%90%AD%E5%BB%BA%E4%BA%8C%E6%89%8B%E5%B8%82%E5%9C%BA%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E5%8F%96%E6%B6%88%E8%AE%A2%E5%8D%95%E5%92%8C%E8%8E%B7%E5%8F%96%E5%95%86%E5%93%81%E4%BF%A1%E6%81%AF%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91/"/>
    <id>http://blog.licheetools.top/2018/09/05/SSM搭建二手市场交易平台（二十七）：取消订单和获取商品信息功能开发/</id>
    <published>2018-09-05T08:21:06.000Z</published>
    <updated>2019-04-15T14:22:47.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本篇我们来完成前台取消订单和获取购物车中商品信息等功能的开发，里面涉及到的知识点挺多的，需要好好理解。</p><h2 id="前台取消订单功能开发"><a href="#前台取消订单功能开发" class="headerlink" title="前台取消订单功能开发"></a>前台取消订单功能开发</h2><p>首先我们打开OrderController.java这个文件，里面写入代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 前台取消订单（删除订单）</span><br><span class="line"> * @author lenovo</span><br><span class="line"> * */</span><br><span class="line">@RequestMapping(value = &quot;cancel.do&quot;)  //这里就是具体的每个方法的url链接</span><br><span class="line">@ResponseBody   //自动序列化json功能</span><br><span class="line">public ServerResponse cancel(HttpSession session,Long orderNo)&#123;</span><br><span class="line">    //验证用户是否登录</span><br><span class="line">    User user =(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">    //未登录需要用户强制登录</span><br><span class="line">    if(user ==null)&#123;</span><br><span class="line">        return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),ResponseCode.NEED_LOGIN.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line">    //实现我们前台取消订单（删除订单）的逻辑</span><br><span class="line">    return iOrderService.cancel(user.getId(),orderNo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着打开IOrderService.Java文件，里面新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerResponse&lt;String&gt; cancel(Integer userId,Long orderNo);   ////前台取消（删除）订单</span><br></pre></td></tr></table></figure></p><p>最后我们打开OrderServiceImpl.java文件，里面的新增代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/***</span><br><span class="line"> *</span><br><span class="line"> * 前台取消订单（删除订单）</span><br><span class="line"> */</span><br><span class="line">public ServerResponse&lt;String&gt; cancel(Integer userId,Long orderNo)&#123;</span><br><span class="line">    Order order =orderMapper.selectOrderByUserIdAndOrderNo(userId,orderNo);</span><br><span class="line">    if(order ==null)&#123;</span><br><span class="line">        return ServerResponse.createByErrorMessage(&quot;该用户此订单不存在&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(order.getStatus() ==Const.OrderStatusEnum.PAID.getCode())&#123;</span><br><span class="line">        return ServerResponse.createByErrorMessage(&quot;此订单已付款，无法取消&quot;);//已经付款的订单我们会通过支付宝退款的方式进行解决</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Order updateOrder =new Order();</span><br><span class="line">    updateOrder.setId(order.getId());</span><br><span class="line">    updateOrder.setStatus(Const.OrderStatusEnum.CANCELED.getCode());</span><br><span class="line"></span><br><span class="line">    int rowCount =orderMapper.updateByPrimaryKeySelective(updateOrder);</span><br><span class="line">    if(rowCount&gt;0)&#123;</span><br><span class="line">        return ServerResponse.createBySuccess();</span><br><span class="line">    &#125;</span><br><span class="line">    return ServerResponse.createByError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我们前台取消订单功能开发就完成了，接下来我们来开发前台用户查看购物车商品明细这个功能。</p><h2 id="前台用户查看购物车商品明细"><a href="#前台用户查看购物车商品明细" class="headerlink" title="前台用户查看购物车商品明细"></a>前台用户查看购物车商品明细</h2><p>首先我们打开OrderController.java这个文件，里面写入代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 前台用户查看购物车选中商品明细</span><br><span class="line"> * 这里是购物车中已经选中的商品（假设用户购买了10件，已经付款了5件，还有5件是需要留在购物车里面的，然后通过这个接口去进行商品信息的查看）</span><br><span class="line"> * @author lenovo</span><br><span class="line"> * */</span><br><span class="line">@RequestMapping(value = &quot;get_order_cart_product.do&quot;)  //这里就是具体的每个方法的url链接</span><br><span class="line">@ResponseBody   //自动序列化json功能</span><br><span class="line">public ServerResponse getOrderCartProduct(HttpSession session)&#123;</span><br><span class="line">    //验证用户是否登录</span><br><span class="line">    User user =(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">    //未登录需要用户强制登录</span><br><span class="line">    if(user ==null)&#123;</span><br><span class="line">        return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),ResponseCode.NEED_LOGIN.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line">    //实现我们前台用户查看购物车选中商品明细的逻辑</span><br><span class="line">    return iOrderService.getOrderCartProduct(user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着打开IOrderService.Java文件，里面新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerResponse getOrderCartProduct(Integer userId);    //前台用户查看购物车选中商品明细</span><br></pre></td></tr></table></figure></p><p>最后我们打开OrderServiceImpl.java文件，里面的新增代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line">   * 前台用户查看购物车选中商品明细</span><br><span class="line">   * 这里是购物车中已经选中的商品（假设用户购买了10件，已经付款了5件，还有5件是需要留在购物车里面的，然后通过这个接口去进行商品信息的查看）</span><br><span class="line">   * @author lenovo</span><br><span class="line">   * */</span><br><span class="line">  public ServerResponse getOrderCartProduct(Integer userId)&#123;</span><br><span class="line">      //这个是我们需要返回的对象</span><br><span class="line">      OrderProductVo orderProductVo = new OrderProductVo();</span><br><span class="line">      //根据用户id从购物车中获取已经选中的数据（返回结果是Cart类型的list）</span><br><span class="line">      List&lt;Cart&gt; cartList =cartMapper.selectCheckedCartByUserId(userId);</span><br><span class="line"></span><br><span class="line">      //通过前面得到的cartList来获得订单明细表（其实就是子订单）</span><br><span class="line">      ServerResponse serverResponse =this.getCartOrderItem(userId,cartList);</span><br><span class="line"></span><br><span class="line">      if(!serverResponse.isSuccess())&#123;</span><br><span class="line">          return serverResponse;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //这里得到的是所有的子订单</span><br><span class="line">      List&lt;OrderItem&gt; orderItemList =(List&lt;OrderItem&gt;)serverResponse.getData();</span><br><span class="line"></span><br><span class="line">      //先创建一个用于存放所有子订单中商品的集合</span><br><span class="line">      List&lt;OrderItemVo&gt; orderItemVoList =Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">      //计算目前已经选中商品的总价</span><br><span class="line">      //将各个子订单进行求和，获取订单总价</span><br><span class="line">      BigDecimal payment = new BigDecimal(&quot;0&quot;);</span><br><span class="line">      for(OrderItem orderItem:orderItemList)&#123;</span><br><span class="line">          payment =BigDecimalUtil.add(payment.doubleValue(),orderItem.getTotalPrice().doubleValue());</span><br><span class="line">          orderItemVoList.add(assembleOrderItemVo(orderItem));</span><br><span class="line">      &#125;</span><br><span class="line">      orderProductVo.setProductTotalPrice(payment);</span><br><span class="line">      orderProductVo.setOrderItemVoList(orderItemVoList);</span><br><span class="line">      orderProductVo.setImageHost(PropertiesUtil.getProperty(&quot;ftp.server.http.prefix&quot;));</span><br><span class="line"></span><br><span class="line">      return ServerResponse.createBySuccess(orderProductVo);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>注意，在这里我们需要新建一个OrderProductVo.java文件，里面的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package top.store.vo;</span><br><span class="line"></span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class OrderProductVo &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;OrderItemVo&gt; orderItemVoList;</span><br><span class="line">    private BigDecimal productTotalPrice;</span><br><span class="line">    private String imageHost;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public List&lt;OrderItemVo&gt; getOrderItemVoList() &#123;</span><br><span class="line">        return orderItemVoList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOrderItemVoList(List&lt;OrderItemVo&gt; orderItemVoList) &#123;</span><br><span class="line">        this.orderItemVoList = orderItemVoList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BigDecimal getProductTotalPrice() &#123;</span><br><span class="line">        return productTotalPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setProductTotalPrice(BigDecimal productTotalPrice) &#123;</span><br><span class="line">        this.productTotalPrice = productTotalPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getImageHost() &#123;</span><br><span class="line">        return imageHost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setImageHost(String imageHost) &#123;</span><br><span class="line">        this.imageHost = imageHost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本篇我们来完成前台取消订单和获取购物车中商品信息等功能的开发，里面涉及到的知识点挺多的，需要好好理解。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="java" scheme="http://blog.licheetools.top/categories/java/"/>
    
    
      <category term="SSM框架" scheme="http://blog.licheetools.top/tags/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="JAVA后端" scheme="http://blog.licheetools.top/tags/JAVA%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>SSM搭建二手市场交易平台（二十六）：前台创建订单功能开发</title>
    <link href="http://blog.licheetools.top/2018/09/04/SSM%E6%90%AD%E5%BB%BA%E4%BA%8C%E6%89%8B%E5%B8%82%E5%9C%BA%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9A%E5%89%8D%E5%8F%B0%E5%88%9B%E5%BB%BA%E8%AE%A2%E5%8D%95%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91/"/>
    <id>http://blog.licheetools.top/2018/09/04/SSM搭建二手市场交易平台（二十六）：前台创建订单功能开发/</id>
    <published>2018-09-04T08:21:06.000Z</published>
    <updated>2019-04-15T14:21:58.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本篇我们来完成订单模模块功能的开发，包括前台和后台开发，里面涉及到的知识点挺多的，需要好好理解。</p><h2 id="模块说明"><a href="#模块说明" class="headerlink" title="模块说明"></a>模块说明</h2><p>本模块具体包括前台和后台开发：前台功能包括：创建订单；商品信息；订单列表；订单详情和取消订单这5个部分，而后台功能则包括：订单列表；订单搜索；订单详情和订单发货这4个部分。</p><h2 id="学会技能"><a href="#学会技能" class="headerlink" title="学会技能"></a>学会技能</h2><p>在本模块中，你将会学到避免业务逻辑中横向越权和纵向越权等安全漏洞；设计实用、安全、扩展性强大的常量、枚举类；订单号生成规则、订单严谨性判断；PJO 和 VO 之间的实际操练以及Mybatis的批量插入等知识。</p><h2 id="数据表的设计"><a href="#数据表的设计" class="headerlink" title="数据表的设计"></a>数据表的设计</h2><p>这里我们会使用到两个数据表，因为订单需要和订单信息绑定在一块：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-5005acc7eee29980.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="store_order这个数据表（总订单也就是用于最后付款的订单）"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e5977cd52dad8c63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="store_order_item这个数据表（子订单）"></p><h2 id="前台创建订单"><a href="#前台创建订单" class="headerlink" title="前台创建订单"></a>前台创建订单</h2><p>首先我们打开controller这个包下面的portal包，打开之前的那个OrderController，里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 前台创建订单</span><br><span class="line"> * @author lenovo</span><br><span class="line"> * */</span><br><span class="line">@RequestMapping(value = &quot;create.do&quot;)  //这里就是具体的每个方法的url链接</span><br><span class="line">@ResponseBody   //自动序列化json功能</span><br><span class="line">public ServerResponse create(HttpSession session,Integer shippingId)&#123;</span><br><span class="line">    //验证用户是否登录</span><br><span class="line">    User user =(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">    //未登录需要用户强制登录</span><br><span class="line">    if(user ==null)&#123;</span><br><span class="line">        return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),ResponseCode.NEED_LOGIN.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line">    //实现我们前台创建订单的逻辑</span><br><span class="line">    return iOrderService.createOrder(user.getId(),shippingId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着打开sevcice包下面的IOrderService.Java文件，里面新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerResponse createOrder(Integer userId,Integer shippingId);   //前台创建订单</span><br></pre></td></tr></table></figure></p><p>接着打开sevcice包下面的Impl包，我们找到OrderServiceImpl.java文件，里面的新增代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line">    /***</span><br><span class="line">     *</span><br><span class="line">     * 前台订单功能开发(代码是从下往上读)</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    public ServerResponse createOrder(Integer userId,Integer shippingId)&#123;</span><br><span class="line">        //根据用户id从购物车中获取已经选中的数据（返回结果是Cart类型的list）</span><br><span class="line">        List&lt;Cart&gt; cartList =cartMapper.selectCheckedCartByUserId(userId);</span><br><span class="line"></span><br><span class="line">        //计算这个订单的总价</span><br><span class="line">        //1、判断返回值是否成功</span><br><span class="line">        ServerResponse serverResponse =this.getCartOrderItem(userId,cartList);</span><br><span class="line">        if(!serverResponse.isSuccess())&#123;</span><br><span class="line">            return serverResponse;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //2、开始计算总价</span><br><span class="line">        List&lt;OrderItem&gt; orderItemList =(List&lt;OrderItem&gt;)serverResponse.getData();  //这里得到的是所有的子订单</span><br><span class="line"></span><br><span class="line">        BigDecimal payment =this.getOrderTotalPrice(orderItemList);  //这里得到的是所有的子订单的总价，也就是订单的总价</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //生成订单(将前面的store_order_item表的信息进行汇总，生成store_order表)</span><br><span class="line">        Order order = this.assembleOrder(userId,shippingId,payment);</span><br><span class="line"></span><br><span class="line">        //判断订单是否为空</span><br><span class="line">        if(order==null)&#123;</span><br><span class="line">            return ServerResponse.createByErrorMessage(&quot;生成订单错误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //判断子订单是否为空</span><br><span class="line">        if(CollectionUtils.isEmpty(orderItemList))&#123;</span><br><span class="line">            return ServerResponse.createByErrorMessage(&quot;购物车为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //在前面我们getCartOrderItem这个函数里面，我们就没有对order_no进行配置，现在需要配置了</span><br><span class="line">        for(OrderItem orderItem:orderItemList)&#123;</span><br><span class="line">            orderItem.setOrderNo(order.getOrderNo());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //mybatis的批量插入(将所有的子订单进行插入,从而生成订单)</span><br><span class="line">        orderItemMapper.batchInsert(orderItemList);</span><br><span class="line"></span><br><span class="line">        //订单生成成功，我们需要减少商品的库存</span><br><span class="line">        this.produceProductStock(orderItemList);</span><br><span class="line"></span><br><span class="line">        //订单生成成功，接着我们需要清空购物车</span><br><span class="line">        this.cleanCart(cartList);</span><br><span class="line"></span><br><span class="line">        //然后需要将数据返回给前端</span><br><span class="line">        OrderVo orderVo =assembleOrderVo(order,orderItemList);</span><br><span class="line">        return ServerResponse.createBySuccess(orderVo);</span><br><span class="line">    &#125;</span><br><span class="line">    //组装新的付款订单，并返回给前端(记得新建3个Vo对象便于后面进行付款订单的组装，这个付款的订单包含订单信息，子订单信息，收货地址信息)</span><br><span class="line">    private OrderVo assembleOrderVo(Order order,List&lt;OrderItem&gt; orderItemList)&#123;</span><br><span class="line">        //下面的信息是订单数据表里面有的信息</span><br><span class="line">        OrderVo orderVo =new OrderVo();</span><br><span class="line">        orderVo.setOrderNo(order.getOrderNo());</span><br><span class="line">        orderVo.setPayment(order.getPayment());</span><br><span class="line">        orderVo.setPaymentType(order.getPaymentType());</span><br><span class="line">        orderVo.setPaymentTypeDesc(Const.PaymentTypeEnum.codeOf(order.getPaymentType()).getValue());</span><br><span class="line"></span><br><span class="line">        orderVo.setPostage(order.getPostage());</span><br><span class="line">        orderVo.setStatus(order.getStatus());</span><br><span class="line">        orderVo.setStatusDesc(Const.OrderStatusEnum.codeOf(order.getStatus()).getValue());</span><br><span class="line"></span><br><span class="line">        orderVo.setShippingId(order.getShippingId());</span><br><span class="line"></span><br><span class="line">        //下面的信息是订单数据表里没有的信息，我们需要从之前的收货地址表中获取(记住此订单不是数据库中的store_order这个表)</span><br><span class="line">        Shipping shipping =shippingMapper.selectByPrimaryKey(order.getShippingId());</span><br><span class="line">        if(shipping !=null)&#123;</span><br><span class="line">            orderVo.setReceiverName(shipping.getReceiverName());  //这里就是说如果新的订单存在，显示它的姓名及信息</span><br><span class="line">            orderVo.setShippingVo(assembleShippingVo(shipping));</span><br><span class="line">        &#125;</span><br><span class="line">        //以下是各种时间的转换</span><br><span class="line">        orderVo.setPaymentTime(DateTimeUtil.dateToStr(order.getPaymentTime()));</span><br><span class="line">        orderVo.setEndTime(DateTimeUtil.dateToStr(order.getEndTime()));</span><br><span class="line">        orderVo.setCreateTime(DateTimeUtil.dateToStr(order.getCreateTime()));</span><br><span class="line">        orderVo.setCloseTime(DateTimeUtil.dateToStr(order.getCloseTime()));</span><br><span class="line"></span><br><span class="line">        orderVo.setImageHost(PropertiesUtil.getProperty(&quot;ftp.server.http.prefix&quot;));</span><br><span class="line"></span><br><span class="line">        //下面的信息是订单数据表里没有的信息，我们需要从之前的子订单表中获取(记住此订单不是数据库中的store_order这个表)</span><br><span class="line">        List&lt;OrderItemVo&gt; orderItemVoList =Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">        for(OrderItem orderItem:orderItemList)&#123;</span><br><span class="line">            OrderItemVo orderItemVo =assembleOrderItemVo(orderItem);</span><br><span class="line">            orderItemVoList.add(orderItemVo);</span><br><span class="line">        &#125;</span><br><span class="line">        orderVo.setOrderItemVoList(orderItemVoList);</span><br><span class="line">        return orderVo;</span><br><span class="line">    &#125;</span><br><span class="line">    //</span><br><span class="line">    private OrderItemVo assembleOrderItemVo(OrderItem orderItem)&#123;</span><br><span class="line">        OrderItemVo orderItemVo =new OrderItemVo();</span><br><span class="line">        orderItemVo.setOrderNo(orderItem.getOrderNo());</span><br><span class="line">        orderItemVo.setProductId(orderItem.getProductId());</span><br><span class="line">        orderItemVo.setProductName(orderItem.getProductName());</span><br><span class="line">        orderItemVo.setProductImage(orderItem.getProductImage());</span><br><span class="line">        orderItemVo .setCurrentUnitPrice(orderItem.getCurrentUnitPrice());</span><br><span class="line">        orderItemVo.setTotalPrice(orderItem.getTotalPrice());</span><br><span class="line">        orderItemVo.setQuantity(orderItem.getQuantity());</span><br><span class="line"></span><br><span class="line">        orderItemVo.setCreateTime(DateTimeUtil.dateToStr(orderItem.getCreateTime()));</span><br><span class="line"></span><br><span class="line">        return orderItemVo;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //通过组装成新的收货地址对象，以便后面的生成新的支付订单使用</span><br><span class="line">    private ShippingVo assembleShippingVo(Shipping shipping)&#123;</span><br><span class="line">       ShippingVo shippingVo =new ShippingVo();</span><br><span class="line">       shippingVo.setReceiverAddress(shipping.getReceiverAddress());</span><br><span class="line">       shippingVo.setReceiverCity(shipping.getReceiverCity());</span><br><span class="line">       shippingVo.setReceiverDistrict(shipping.getReceiverDistrict());</span><br><span class="line">       shippingVo.setReceiverMobile(shipping.getReceiverMobile());</span><br><span class="line">       shippingVo.setReceiverPhone(shipping.getReceiverPhone());</span><br><span class="line">       shippingVo.setReceiverName(shipping.getReceiverName());</span><br><span class="line">       shippingVo.setReceiverProvince(shipping.getReceiverProvince());</span><br><span class="line">       shippingVo.setReceiverZip(shipping.getReceiverZip());</span><br><span class="line">       return shippingVo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //订单生成成功，接着我们需要清空购物车</span><br><span class="line">    private void cleanCart( List&lt;Cart&gt; cartList)&#123;</span><br><span class="line">        for(Cart cart:cartList)&#123;</span><br><span class="line">            cartMapper.deleteByPrimaryKey(cart.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //订单生成成功，我们需要减少商品的库存</span><br><span class="line">    private void produceProductStock(List&lt;OrderItem&gt; orderItemList)&#123;</span><br><span class="line">        for(OrderItem orderItem:orderItemList)&#123;</span><br><span class="line">            Product product =productMapper.selectByPrimaryKey(orderItem.getProductId());</span><br><span class="line">            product.setStock(product.getStock()-orderItem.getQuantity());</span><br><span class="line">            productMapper.updateByPrimaryKeySelective(product);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //组装订单表（将前面的store_order_item表的信息进行汇总，生成store_order表）</span><br><span class="line">    private Order assembleOrder(Integer userId,Integer shippingId,BigDecimal payment)&#123;</span><br><span class="line">        //这里面有三个参数：userId用户id, shippingId收货地址id, payment订单总价</span><br><span class="line"></span><br><span class="line">        //这个是我们组装成的新的订单</span><br><span class="line">       Order order =new Order();</span><br><span class="line"></span><br><span class="line">        long order_no =this.generateOrderNo();</span><br><span class="line"></span><br><span class="line">        //这里面的字段请依据store_order进行设置</span><br><span class="line">        order.setOrderNo(order_no);</span><br><span class="line">        order.setStatus(Const.OrderStatusEnum.PAID.getCode());</span><br><span class="line">        order.setPostage(0);</span><br><span class="line">        order.setPaymentType(Const.PaymentTypeEnum.ONLINE_PAY.getCode());</span><br><span class="line">        order.setUserId(userId);</span><br><span class="line">        order.setShippingId(shippingId);</span><br><span class="line">        order.setPayment(payment);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         //发货时间：send_time</span><br><span class="line">         //交易完成时间：end_time</span><br><span class="line">         //交易关闭时间：close_time</span><br><span class="line">         // 上面的时间目前先不进行，后面会进行配置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //将新的订单插入到数据库中</span><br><span class="line">       int rowCount =  orderMapper.insert(order);</span><br><span class="line">       if(rowCount&gt;0)&#123;</span><br><span class="line">           return order;</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 订单号order_no的生成</span><br><span class="line">    //订单号的生成是非常重要的，这个设计的好坏关系到以后做分布式，高并发的情况非常有效，这里采用时间戳取余的方式</span><br><span class="line">    private long generateOrderNo()&#123;</span><br><span class="line">        long currentTime =System.currentTimeMillis();</span><br><span class="line">//        return currentTime+currentTime%10;  这种方法是可以的，但是在高并发的时候，可能是同时进行的，因此时间有可能一样,那样我们对orderNum进行唯一索引的时候就会失败</span><br><span class="line">        return currentTime+new Random().nextInt(100);  //加上一个100以内的随机数</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //用于计算订单总价</span><br><span class="line">    private BigDecimal getOrderTotalPrice(List&lt;OrderItem&gt; orderItemList)&#123;</span><br><span class="line">        //将各个子订单进行求和，获取订单总价</span><br><span class="line">        BigDecimal payment =new BigDecimal(&quot;0&quot;);</span><br><span class="line">        for(OrderItem orderItem:orderItemList)&#123;</span><br><span class="line">           payment= BigDecimalUtil.add(payment.doubleValue(),orderItem.getTotalPrice().doubleValue());  //这里默认就是0+一个订单</span><br><span class="line">        &#125;</span><br><span class="line">        return payment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //用于返回新的子订单明细（其实就是返回一个store_order_item子订单对象）</span><br><span class="line">    private ServerResponse getCartOrderItem(Integer userId,List&lt;Cart&gt; cartList)&#123;</span><br><span class="line"></span><br><span class="line">        //这个是我们组装成的新的子订单</span><br><span class="line">        List&lt;OrderItem&gt; orderItemList =Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">        if(CollectionUtils.isEmpty(cartList))&#123;</span><br><span class="line">            return ServerResponse.createByErrorMessage(&quot;购物车为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //校验购物车的数据，包括产品的状态和数量</span><br><span class="line">        for(Cart cartItem:cartList)&#123;</span><br><span class="line">            //校验产品的状态是否是在售状态</span><br><span class="line"></span><br><span class="line">            Product product =productMapper.selectByPrimaryKey(cartItem.getProductId());</span><br><span class="line">            if(Const.ProductStatusEnum.ON_SALE.getCode() != product.getStatus() )&#123;</span><br><span class="line">                return ServerResponse.createByErrorMessage(&quot;产品&quot;+product.getName()+&quot;不是在线售卖状态&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //校验产品的库存</span><br><span class="line">            if(cartItem.getQuantity()&gt;product.getStock())&#123;</span><br><span class="line">                return ServerResponse.createByErrorMessage(&quot;产品&quot;+product.getName()+&quot;库存不足&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            //开始组装成我们的订单对象(除了order_no这个字段需要我们后面设置以外，其余需要我们在这里进行组装也就是order_item表中的信息)</span><br><span class="line">            OrderItem orderItem =new OrderItem();</span><br><span class="line"></span><br><span class="line">            //order_no这个字段需要我们后面设置</span><br><span class="line"></span><br><span class="line">            orderItem.setUserId(userId);</span><br><span class="line">            orderItem.setProductId(product.getId());</span><br><span class="line">            orderItem.setProductName(product.getName());</span><br><span class="line">            orderItem.setProductImage(product.getMainImage());</span><br><span class="line">            orderItem.setCurrentUnitPrice(product.getPrice());</span><br><span class="line">            orderItem.setQuantity(cartItem.getQuantity());</span><br><span class="line">            orderItem.setTotalPrice(BigDecimalUtil.mut(product.getPrice().doubleValue(),cartItem.getQuantity()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            orderItemList.add(orderItem);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return ServerResponse.createBySuccess(orderItemList);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码很多，但是都是为了后面的调用方便而进行了封装。下面分别解释上面代码的含义（记住上面代码你必须是从下往上读，因为我们是随着开发的需要而逐渐增加代码的）<br><strong>1、</strong>首先我们是要创建订单，因此必须根据传入的用户id来去购物车(store_cart)这个数据表中查找相应的购物车对象，其实就是很多种商品，你知道的一个用户可能存在多个购物车商品，因此返回的是一个购物车list：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Cart&gt; cartList =cartMapper.selectCheckedCartByUserId(userId);</span><br></pre></td></tr></table></figure></p><p>我们需要打开CartMapper.java文件，里面新增代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Cart&gt; selectCheckedCartByUserId(Integer userId);</span><br></pre></td></tr></table></figure></p><p>然后打开CartMapper.xml文件，里面新增代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectCheckedCartByUserId&quot; parameterType=&quot;int&quot; resultMap=&quot;BaseResultMap&quot;&gt;</span><br><span class="line">   select</span><br><span class="line">   &lt;include refid=&quot;Base_Column_List&quot;/&gt;</span><br><span class="line">   from store_cart</span><br><span class="line">   where user_id =#&#123;userId&#125;</span><br><span class="line">   and checked =1</span><br><span class="line"> &lt;/select&gt;</span><br></pre></td></tr></table></figure></p><p><strong>2、</strong>然后就计算刚才那些购物车商品的总价，而这个过程比较复杂，需要创建一个getCartOrderItem函数，用于返回新的子订单明细（其实就是返回一个store_order_item子订单对象），当然在这个函数里面，你需要校验购物车的数据，包括产品的状态和库存数量。<br><strong>3、</strong>通过第二步，我们得到了所有的子订单，现在去定义一个getOrderTotalPrice函数，去计算所有的子订单的总价，也就是订单的总价，具体的代码参看上面。<br><strong>4、</strong>接着我们需要生成订单号，订单号的生成是非常重要的，这个设计的好坏关系到以后做分布式，高并发的情况非常有效，这里采用时间戳+随机函数的方式：新建一个用于生成订单号的generateOrderNo函数，我们的核心就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentTime+new Random().nextInt(100);</span><br></pre></td></tr></table></figure></p><p><strong>5、</strong>将第3步中的所有子订单进行合并，生成新的支付订单，你知道的支付订单里面包含用户信息，商品信息以及收货地址。首先我们需要判断判断订单是否为空以及子订单是否为空:我们新建一个assembleOrder函数，用于组装订单表，这里面有三个参数：userId用户id, shippingId收货地址id, payment订单总价。<br>在<code>order.setStatus(Const.OrderStatusEnum.PAID.getCode());</code>和<code>order.setPaymentType(Const.PaymentTypeEnum.ONLINE_PAY.getCode());</code>的时候，我们需要打开Const.java文件，在OrderStatusEnum这个枚举类添加codeOf方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static OrderStatusEnum codeOf(int code)&#123;</span><br><span class="line">      for(OrderStatusEnum orderStatusEnum:values())&#123;</span><br><span class="line">          if(orderStatusEnum.getCode() ==code)&#123;</span><br><span class="line">              return orderStatusEnum;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      throw new RuntimeException(&quot;没有找到对应的枚举&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>以及新建一个枚举类PaymentTypeEnum：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//支付类型（目前暂支持线上支付，后面会进行扩展）</span><br><span class="line">    public enum PaymentTypeEnum&#123;</span><br><span class="line">        ONLINE_PAY(1,&quot;在线支付&quot;)</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">        private String value;</span><br><span class="line">        private int code;</span><br><span class="line"></span><br><span class="line">        PaymentTypeEnum(int code,String value)&#123;</span><br><span class="line">            this.code =code;</span><br><span class="line">            this.value=value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getValue() &#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setValue(String value) &#123;</span><br><span class="line">            this.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getCode() &#123;</span><br><span class="line">            return code;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setCode(int code) &#123;</span><br><span class="line">            this.code = code;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public static PaymentTypeEnum codeOf(int code)&#123;</span><br><span class="line">            for(PaymentTypeEnum paymentTypeEnum:values())&#123;</span><br><span class="line">                if(paymentTypeEnum.getCode() ==code)&#123;</span><br><span class="line">                    return paymentTypeEnum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            throw new RuntimeException(&quot;没有找到对应的枚举&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里在注意一下时间字段，我们这里没有进行配置，我们后面会进行配置。</p><p><strong>6、</strong>然后就是将新的订单插入到数据库中。mybatis的批量插入(将所有的子订单进行插入,从而生成订单)，我们需要打开OrderItemMapper.java文件，里面新增代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void batchInsert(@Param(value = &quot;orderItemList&quot;) List&lt;OrderItem&gt; orderItemList);</span><br></pre></td></tr></table></figure></p><p>记住在mybatis里面使用多个参数时，需要使用Param注解。</p><p>紧接着，打开OrderItemMapper.xml文件，里面新增代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   &lt;insert id=&quot;batchInsert&quot; parameterType=&quot;list&quot;&gt;</span><br><span class="line">  insert into store_order_item (id, order_no,user_id, product_id,</span><br><span class="line">  product_name, product_image, current_unit_price,</span><br><span class="line">  quantity, total_price, create_time,</span><br><span class="line">  update_time)</span><br><span class="line">  values</span><br><span class="line">  &lt;foreach collection=&quot;orderItemList&quot; index=&quot;index&quot; item=&quot;item&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">    (</span><br><span class="line">    #&#123;item.id&#125;,#&#123;item.orderNo&#125;,#&#123;item.userId&#125;,#&#123;item.productId&#125;,#&#123;item.productName&#125;,#&#123;item.productImage&#125;,#&#123;item.currentUnitPrice&#125;,#&#123;item.quantity&#125;,#&#123;item.totalPrice&#125;,now(),now()</span><br><span class="line">    )</span><br><span class="line">  &lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure></p><p>这里面采用了foreach 进行循环遍历进行插入。<br><strong>6、</strong>订单生成以后，我们需要清空购物车和减少商品的库存。分别去定义cleanCart和produceProductStock这两个函数，去实现相关的逻辑。<br><strong>7、</strong>接下来我们要做的就是将数据以Json形式返回给前端，为了更好的实现这个功能，我们需要新建三个Vo文件，我们打开Vo这个包，新建OrderVo.java文件，里面的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line">package top.store.vo;</span><br><span class="line"></span><br><span class="line">import top.store.pojo.Shipping;</span><br><span class="line">import top.store.service.ShippingVo;</span><br><span class="line"></span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class OrderVo &#123;</span><br><span class="line"></span><br><span class="line">    private Long orderNo;</span><br><span class="line"></span><br><span class="line">    private BigDecimal payment;</span><br><span class="line"></span><br><span class="line">    private Integer paymentType;</span><br><span class="line"></span><br><span class="line">    private String paymentTypeDesc;</span><br><span class="line"></span><br><span class="line">    private Integer postage;</span><br><span class="line"></span><br><span class="line">    private Integer status;</span><br><span class="line"></span><br><span class="line">    private String statusDesc;</span><br><span class="line"></span><br><span class="line">    //各种时间，都采用String类型</span><br><span class="line"></span><br><span class="line">    private String paymentTime;</span><br><span class="line"></span><br><span class="line">    private String sendTime;</span><br><span class="line"></span><br><span class="line">    private String endTime;</span><br><span class="line"></span><br><span class="line">    private String closeTime;</span><br><span class="line"></span><br><span class="line">    private String createTime;</span><br><span class="line"></span><br><span class="line">    private String updateTime;</span><br><span class="line"></span><br><span class="line">    //子订单的明细（另外新建一个OrderItemVo用于组装需要显示的信息）</span><br><span class="line"></span><br><span class="line">    private List&lt;OrderItemVo&gt; orderItemVoList;</span><br><span class="line"></span><br><span class="line">    private String imageHost;</span><br><span class="line">    private Integer shippingId;</span><br><span class="line">    private String receiverName;</span><br><span class="line"></span><br><span class="line">    //购物车明细（另外新建一个ShippingVo用于组装需要显示的信息）</span><br><span class="line">    private ShippingVo shippingVo;</span><br><span class="line"></span><br><span class="line">    public Long getOrderNo() &#123;</span><br><span class="line">        return orderNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOrderNo(Long orderNo) &#123;</span><br><span class="line">        this.orderNo = orderNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BigDecimal getPayment() &#123;</span><br><span class="line">        return payment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPayment(BigDecimal payment) &#123;</span><br><span class="line">        this.payment = payment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getPaymentType() &#123;</span><br><span class="line">        return paymentType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPaymentType(Integer paymentType) &#123;</span><br><span class="line">        this.paymentType = paymentType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPaymentTypeDesc() &#123;</span><br><span class="line">        return paymentTypeDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPaymentTypeDesc(String paymentTypeDesc) &#123;</span><br><span class="line">        this.paymentTypeDesc = paymentTypeDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getPostage() &#123;</span><br><span class="line">        return postage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPostage(Integer postage) &#123;</span><br><span class="line">        this.postage = postage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getStatus() &#123;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setStatus(Integer status) &#123;</span><br><span class="line">        this.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getStatusDesc() &#123;</span><br><span class="line">        return statusDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setStatusDesc(String statusDesc) &#123;</span><br><span class="line">        this.statusDesc = statusDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPaymentTime() &#123;</span><br><span class="line">        return paymentTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPaymentTime(String paymentTime) &#123;</span><br><span class="line">        this.paymentTime = paymentTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSendTime() &#123;</span><br><span class="line">        return sendTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSendTime(String sendTime) &#123;</span><br><span class="line">        this.sendTime = sendTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getEndTime() &#123;</span><br><span class="line">        return endTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEndTime(String endTime) &#123;</span><br><span class="line">        this.endTime = endTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCloseTime() &#123;</span><br><span class="line">        return closeTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCloseTime(String closeTime) &#123;</span><br><span class="line">        this.closeTime = closeTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCreateTime() &#123;</span><br><span class="line">        return createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCreateTime(String createTime) &#123;</span><br><span class="line">        this.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUpdateTime() &#123;</span><br><span class="line">        return updateTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUpdateTime(String updateTime) &#123;</span><br><span class="line">        this.updateTime = updateTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;OrderItemVo&gt; getOrderItemVoList() &#123;</span><br><span class="line">        return orderItemVoList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOrderItemVoList(List&lt;OrderItemVo&gt; orderItemVoList) &#123;</span><br><span class="line">        this.orderItemVoList = orderItemVoList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getImageHost() &#123;</span><br><span class="line">        return imageHost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setImageHost(String imageHost) &#123;</span><br><span class="line">        this.imageHost = imageHost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getShippingId() &#123;</span><br><span class="line">        return shippingId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setShippingId(Integer shippingId) &#123;</span><br><span class="line">        this.shippingId = shippingId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getReceiverName() &#123;</span><br><span class="line">        return receiverName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setReceiverName(String receiverName) &#123;</span><br><span class="line">        this.receiverName = receiverName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ShippingVo getShippingVo() &#123;</span><br><span class="line">        return shippingVo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setShippingVo(ShippingVo shippingVo) &#123;</span><br><span class="line">        this.shippingVo = shippingVo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着新建OrderItemVo.java文件，里面的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">package top.store.vo;</span><br><span class="line"></span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class OrderItemVo &#123;</span><br><span class="line">    //从store_order_item表里面选择我们将要在订单中显示的字段</span><br><span class="line"></span><br><span class="line">    private Long orderNo;</span><br><span class="line"></span><br><span class="line">    private Integer productId;</span><br><span class="line"></span><br><span class="line">    private String productName;</span><br><span class="line"></span><br><span class="line">    private String productImage;</span><br><span class="line"></span><br><span class="line">    private BigDecimal currentUnitPrice;</span><br><span class="line"></span><br><span class="line">    private Integer quantity;</span><br><span class="line"></span><br><span class="line">    private BigDecimal totalPrice;</span><br><span class="line"></span><br><span class="line">    private String createTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Long getOrderNo() &#123;</span><br><span class="line">        return orderNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOrderNo(Long orderNo) &#123;</span><br><span class="line">        this.orderNo = orderNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getProductId() &#123;</span><br><span class="line">        return productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setProductId(Integer productId) &#123;</span><br><span class="line">        this.productId = productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getProductName() &#123;</span><br><span class="line">        return productName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setProductName(String productName) &#123;</span><br><span class="line">        this.productName = productName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getProductImage() &#123;</span><br><span class="line">        return productImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setProductImage(String productImage) &#123;</span><br><span class="line">        this.productImage = productImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BigDecimal getCurrentUnitPrice() &#123;</span><br><span class="line">        return currentUnitPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCurrentUnitPrice(BigDecimal currentUnitPrice) &#123;</span><br><span class="line">        this.currentUnitPrice = currentUnitPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getQuantity() &#123;</span><br><span class="line">        return quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setQuantity(Integer quantity) &#123;</span><br><span class="line">        this.quantity = quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BigDecimal getTotalPrice() &#123;</span><br><span class="line">        return totalPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTotalPrice(BigDecimal totalPrice) &#123;</span><br><span class="line">        this.totalPrice = totalPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCreateTime() &#123;</span><br><span class="line">        return createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCreateTime(String createTime) &#123;</span><br><span class="line">        this.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后新建ShippingVo.java文件，里面的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">package top.store.vo;</span><br><span class="line"></span><br><span class="line">public class ShippingVo &#123;</span><br><span class="line">    //从store_shipping表里面选择我们将要在订单中显示的字段</span><br><span class="line">    private String receiverName;</span><br><span class="line"></span><br><span class="line">    private String receiverPhone;</span><br><span class="line"></span><br><span class="line">    private String receiverMobile;</span><br><span class="line"></span><br><span class="line">    private String receiverProvince;</span><br><span class="line"></span><br><span class="line">    private String receiverCity;</span><br><span class="line"></span><br><span class="line">    private String receiverDistrict;</span><br><span class="line"></span><br><span class="line">    private String receiverAddress;</span><br><span class="line"></span><br><span class="line">    private String receiverZip;</span><br><span class="line"></span><br><span class="line">    public String getReceiverName() &#123;</span><br><span class="line">        return receiverName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setReceiverName(String receiverName) &#123;</span><br><span class="line">        this.receiverName = receiverName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getReceiverPhone() &#123;</span><br><span class="line">        return receiverPhone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setReceiverPhone(String receiverPhone) &#123;</span><br><span class="line">        this.receiverPhone = receiverPhone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getReceiverMobile() &#123;</span><br><span class="line">        return receiverMobile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setReceiverMobile(String receiverMobile) &#123;</span><br><span class="line">        this.receiverMobile = receiverMobile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getReceiverProvince() &#123;</span><br><span class="line">        return receiverProvince;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setReceiverProvince(String receiverProvince) &#123;</span><br><span class="line">        this.receiverProvince = receiverProvince;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getReceiverCity() &#123;</span><br><span class="line">        return receiverCity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setReceiverCity(String receiverCity) &#123;</span><br><span class="line">        this.receiverCity = receiverCity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getReceiverDistrict() &#123;</span><br><span class="line">        return receiverDistrict;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setReceiverDistrict(String receiverDistrict) &#123;</span><br><span class="line">        this.receiverDistrict = receiverDistrict;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getReceiverAddress() &#123;</span><br><span class="line">        return receiverAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setReceiverAddress(String receiverAddress) &#123;</span><br><span class="line">        this.receiverAddress = receiverAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getReceiverZip() &#123;</span><br><span class="line">        return receiverZip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setReceiverZip(String receiverZip) &#123;</span><br><span class="line">        this.receiverZip = receiverZip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着我们需要定义三个函数分别用于组装我们在支付订单里面的信息，为什么这么做？那是因为我们的支付订单里面包含的只是订单表，子订单表（订单明细表）和收货地址表中的部分信息，因此我们需要进行抽离封装成一个我们用在支付订单里面的信息。</p><p>这个很好理解，assembleShippingVo函数传入shipping对象进行组装；assembleOrderItemVo函数传入orderItem对象进行组装；assembleOrderVo函数传入order和orderItemList对象进行组装。</p><p>这样最后将组装成的新的支付订单对象返回给前端，就完成了我们创建订单的逻辑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本篇我们来完成订单模模块功能的开发，包括前台和后台开发，里面涉及到的知识点挺多的，需要好好理解。&lt;/p&gt;
&lt;h2 id=&quot;模
      
    
    </summary>
    
      <category term="java" scheme="http://blog.licheetools.top/categories/java/"/>
    
    
      <category term="SSM框架" scheme="http://blog.licheetools.top/tags/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="JAVA后端" scheme="http://blog.licheetools.top/tags/JAVA%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>SSM搭建二手市场交易平台（二十五）：支付宝支付回调功能开发</title>
    <link href="http://blog.licheetools.top/2018/09/03/SSM%E6%90%AD%E5%BB%BA%E4%BA%8C%E6%89%8B%E5%B8%82%E5%9C%BA%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E5%9B%9E%E8%B0%83%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91/"/>
    <id>http://blog.licheetools.top/2018/09/03/SSM搭建二手市场交易平台（二十五）：支付宝支付回调功能开发/</id>
    <published>2018-09-03T10:21:06.000Z</published>
    <updated>2019-04-15T14:21:00.941Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本篇来完成支付宝支付回调的功能，其实这个是非常简单的，但是我专门用一篇笔记来记录主要就是希望自己可以好好的进行完善。</p><h2 id="支付宝支付回调"><a href="#支付宝支付回调" class="headerlink" title="支付宝支付回调"></a>支付宝支付回调</h2><p>打开OrderController.java文件，里面新增代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line">     * 支付宝回调功能开发</span><br><span class="line">     * @author envy</span><br><span class="line">     * */</span><br><span class="line">    @RequestMapping(value = &quot;alipay_callback.do&quot;)  //这里就是具体的每个方法的url链接</span><br><span class="line">    @ResponseBody   //自动序列化json功能</span><br><span class="line">    public Object alipayCallback(HttpServletRequest request) &#123;</span><br><span class="line">        //利用guava封装的map进行参数存储，记住这个是新的经过下面的代码拼接以后的map</span><br><span class="line">        Map&lt;String,String&gt; params = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       Map requestParams= request.getParameterMap();   //将异步通知中收到的待验证所有参数都存放到map中</span><br><span class="line">        for(Iterator iter=requestParams.keySet().iterator();iter.hasNext();)&#123;</span><br><span class="line">            String name =(String)iter.next();</span><br><span class="line">            String [] values =(String [])requestParams.get(name);</span><br><span class="line"></span><br><span class="line">            String valueStr =&quot;&quot;;</span><br><span class="line">            for(int i=0;i&lt;values.length;i++)&#123;</span><br><span class="line">                //判断值的长度，若为1，则直接返回values[0]，若不是那我们则需要在各个参数值之间添加逗号用于区分</span><br><span class="line">                valueStr =(i==values.length-1)?valueStr+values[i]:valueStr+values[i]+&quot;,&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            //其实这里就是将前面的map进行处理,然后变成我们所需要的params</span><br><span class="line">            params.put(name,valueStr);</span><br><span class="line">        &#125;</span><br><span class="line">       logger.info(&quot;支付宝回调，sign:&#123;&#125;,trade_status:&#123;&#125;,参数:&#123;&#125;&quot;,params.get(&quot;sign&quot;),params.get(&quot;trade_status&quot;),params.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //接下来的代码是非常重要的，因为它需要对我们的回调结果进行验证，并且还要避免重复通知</span><br><span class="line">        params.remove(&quot;sign_type&quot;);</span><br><span class="line"></span><br><span class="line">        //注意这里其余参数的获取是不需要再次构建方法的，你是可以直接通过Configs来获得的</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean alipayRSACheckedV2 = AlipaySignature.rsaCheckV2(params, Configs.getPublicKey(),&quot;utf-8&quot;,Configs.getSignType());</span><br><span class="line"></span><br><span class="line">            if(!alipayRSACheckedV2)&#123;</span><br><span class="line">                return ServerResponse.createByErrorMessage(&quot;非法请求，验证不通过，再恶意请求将报警找网警。&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (AlipayApiException e) &#123;</span><br><span class="line">            logger.error(&quot;支付宝验证回调异常&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //商户需要验证该通知数据中的out_trade_no是否为商户系统中创建的订单号，</span><br><span class="line">        // 并判断total_amount是否确实为该订单的实际金额（即商户订单创建时的金额），</span><br><span class="line">        // 同时需要校验通知中的seller_id（或者seller_email) 是否为out_trade_no这笔单据的对应的操作方</span><br><span class="line">        // （有的时候，一个商户可能有多个seller_id/seller_email），上述有任何一个验证不通过，</span><br><span class="line">        // 则表明本次通知是异常通知，务必忽略。在上述验证通过后商户必须根据支付宝不同类型的业务通知，</span><br><span class="line">        // 正确的进行不同的业务处理，并且过滤重复的通知结果数据。在支付宝的业务通知中，</span><br><span class="line">        // 只有交易通知状态为TRADE_SUCCESS或TRADE_FINISHED时，支付宝才会认定为买家付款成功。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //进行参数验证</span><br><span class="line">        ServerResponse serverResponse =iOrderService.aliCallback(params);</span><br><span class="line">        if(serverResponse.isSuccess())&#123;</span><br><span class="line">            return Const.AlipayCallback.RESPONSE_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">        return Const.AlipayCallback.RESPONSE_FAILED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>接着打开OrderServiceImpl.java文件，里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line">     *</span><br><span class="line">     * 支付宝回调验证</span><br><span class="line">     *</span><br><span class="line">     * 验证参数 :</span><br><span class="line">     * out_trade_no:商户订单号</span><br><span class="line">     * trade_no:支付宝交易号;</span><br><span class="line">     * trade_status:交易状态</span><br><span class="line">     */</span><br><span class="line">    public ServerResponse aliCallback(Map&lt;String,String&gt; params)&#123;</span><br><span class="line">      Long orderNo = Long.parseLong(params.get(&quot;out_trade_no&quot;));</span><br><span class="line">      String tradeNo =params.get(&quot;trade_no&quot;);</span><br><span class="line">      String tradeStatus =params.get(&quot;trade_status&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      //通过商户订单号来查询订单</span><br><span class="line">        Order order =orderMapper.selectOrderByOrderNo(orderNo);</span><br><span class="line"></span><br><span class="line">        if(order ==null)&#123;</span><br><span class="line">            return ServerResponse.createByErrorMessage(&quot;非光明二手交易市场的订单，回调忽略&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断是否进行了重复调用（只有已取消和未支付这两种不会引起重复调用）</span><br><span class="line">        if(order.getStatus()&gt;= Const.OrderStatusEnum.PAID.getCode())&#123;</span><br><span class="line">            return ServerResponse.createBySuccess(&quot;支付宝重复调用&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //当没有进行重复调用的时候，我们需要通过判断来设置它的支付状态</span><br><span class="line">        if(Const.AlipayCallback.RESPONSE_SUCCESS.equals(tradeStatus))&#123;</span><br><span class="line">            //设置支付时间，从params里面获取,查看支付宝文档发现它其实是一个gmt_payment和时间工具类里面的配置一样</span><br><span class="line">            order.setPaymentTime(DateTimeUtil.strToDate(params.get(&quot;gmt_payment&quot;)));</span><br><span class="line"></span><br><span class="line">            order.setStatus(Const.OrderStatusEnum.PAID.getCode());</span><br><span class="line">            //更新订单状态</span><br><span class="line">            orderMapper.updateByPrimaryKeySelective(order);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //组装一个payInfo对象</span><br><span class="line">        /***</span><br><span class="line">         *下面这些字段都是payInfo支付信息表里面的字段</span><br><span class="line">         * user_id,  用户id</span><br><span class="line">         * order_no,  商户订单号</span><br><span class="line">         * pay_platform,  支付平台</span><br><span class="line">         * platform_number,  交易号(tradeNo)</span><br><span class="line">         *platform_status, 交易状态（tradeStatus）</span><br><span class="line">         */</span><br><span class="line">        PayInfo payInfo =new PayInfo();</span><br><span class="line">        payInfo.setId(order.getUserId());</span><br><span class="line">        payInfo.setOrderNo(order.getOrderNo());</span><br><span class="line">        payInfo.setPayPlatform(Const.PayPlatformEnum.ALIPAY.getCode());</span><br><span class="line">        payInfo.setPlatformNumber(tradeNo);</span><br><span class="line">        payInfo.setPlatformStatus(tradeStatus);</span><br><span class="line"></span><br><span class="line">        payInfoMapper.insert(payInfo);</span><br><span class="line"></span><br><span class="line">        return ServerResponse.createBySuccess();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>几点说明：</strong><br>1、看到这行<code>Order order =orderMapper.selectOrderByOrderNo(orderNo);</code>代码就说明我们需要去OrderMapper.java文件里面添加一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Order selectOrderByOrderNo(Long orderNo);</span><br></pre></td></tr></table></figure></p><p>紧接着我们需要打开OrderMapper.xml文件，里面新增代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectOrderByOrderNo&quot; parameterType=&quot;long&quot; resultMap=&quot;BaseResultMap&quot;&gt;</span><br><span class="line">  select</span><br><span class="line">  &lt;include refid=&quot;Base_Column_List&quot;/&gt;</span><br><span class="line">  from store_order</span><br><span class="line">  where order_no =#&#123;orderNo&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p><p><strong>2、</strong>在进行是否重复调用的判断时，我们需要去Const里面新增支付状态的枚举类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">//订单状态</span><br><span class="line">   public enum OrderStatusEnum&#123;</span><br><span class="line">       CANCELED(0,&quot;已取消&quot;),</span><br><span class="line">       NO_PAY(10,&quot;未支付&quot;),</span><br><span class="line">       PAID(20,&quot;已付款&quot;),</span><br><span class="line">       SHIPPED(40,&quot;已发货&quot;),</span><br><span class="line">       ORDER_SUCCESS(50,&quot;订单完成&quot;),</span><br><span class="line">       ORDER_CLOSE(60,&quot;订单关闭&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       private String value;</span><br><span class="line">       private int code;</span><br><span class="line"></span><br><span class="line">       OrderStatusEnum(int code,String value)&#123;</span><br><span class="line">           this.code =code;</span><br><span class="line">           this.value=value;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public String getValue() &#123;</span><br><span class="line">           return value;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public void setValue(String value) &#123;</span><br><span class="line">           this.value = value;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public int getCode() &#123;</span><br><span class="line">           return code;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public void setCode(int code) &#123;</span><br><span class="line">           this.code = code;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public interface AlipayCallback&#123;</span><br><span class="line">       String TRADE_STATUS_WAIT_BUYER_PAY = &quot;WAIT_BUYER_PAY&quot;;</span><br><span class="line">       String TRADE_STATUS_TRADE_SUCCESS = &quot;TRADE_SUCCESS&quot;;</span><br><span class="line"></span><br><span class="line">       String RESPONSE_SUCCESS = &quot;success&quot;;</span><br><span class="line">       String RESPONSE_FAILED = &quot;failed&quot;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   //支付平台（目前暂支持支付宝，后面会进行扩展）</span><br><span class="line">   public enum PayPlatformEnum&#123;</span><br><span class="line">       ALIPAY(1,&quot;支付宝&quot;)</span><br><span class="line">       ;</span><br><span class="line"></span><br><span class="line">       private String value;</span><br><span class="line">       private int code;</span><br><span class="line"></span><br><span class="line">       PayPlatformEnum(int code,String value)&#123;</span><br><span class="line">           this.code =code;</span><br><span class="line">           this.value=value;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public String getValue() &#123;</span><br><span class="line">           return value;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public void setValue(String value) &#123;</span><br><span class="line">           this.value = value;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public int getCode() &#123;</span><br><span class="line">           return code;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public void setCode(int code) &#123;</span><br><span class="line">           this.code = code;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>这后面的代码其实就是后面即将会使用到的订单状态和支付平台这个两个枚举类，里面设置了value和code这个两个字段，以及它的有参构造，getter和setter方法。<br><strong>3、</strong>这行代码<code>order.setPaymentTime(DateTimeUtil.strToDate(params.get(&quot;gmt_payment&quot;)));</code>是用来设置支付时间，从params里面获取,查看<a href="https://docs.open.alipay.com/194/103296/" target="_blank" rel="noopener">支付宝文档</a>发现它其实是一gmt_payment和时间工具类里面的配置一样：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9e31f32162cb75bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这是我们DateUtil的工具类里面的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//定义一下我们的日期格式</span><br><span class="line">public static final String STANDARD_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;;</span><br></pre></td></tr></table></figure><p><strong>4、</strong>然后通过我们获取到的信息，我们需要组装成一个payInfo对象，里面的数据都是我们自己设定的，经过了严格的判断。</p><p>最后打开IOrderService.java文件，添加接口抽象方法，以供controller调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerResponse aliCallback(Map&lt;String,String&gt; params);    //支付宝回调验证</span><br></pre></td></tr></table></figure></p><p>关于其他未说明的事情请参看下面的注意事项。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在对支付宝回调结果进行检验的时候，我们可以单击查看支付宝的<a href="https://docs.open.alipay.com/194/103296/" target="_blank" rel="noopener">开发文档</a>，我们拉到底部：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-94b01711bba65f1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>shift+ctrl+T调出类搜索框，搜索<code>alipaysignature</code>，接着alt+数字7（不是F7）查看该类所有方法，因为支付宝现在只提供RSA2(SHA256)密钥这种方法，因此直接查看图中所示方法<code>rsaCheckV2</code>：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c028752f4e6d7120.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-79feba20353e88cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>你发现只去除了sign，并没有移除sign_type，因此我们后面需要自己进行移除。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3f1f7c36b323ab4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>然后你在支付宝属性配置文件里面看到了<code>,RSA2-&gt;SHA256withRsa</code>因此我们需要查看CheckContent的rsa类型，我们发现<code>rsa256CheckContent</code>这个函数里面的就是采用<code>SIGN_SHA256RSA_ALGORITHMS</code>来进行验证的。还有在前面我们看到了charset这个设置字符集的字段。我们搜索<code>AlipayTradeServiceImpl.java</code>文件，我们发现了图中所示的信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-36530458522d3da5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>也就是说如果你不传入charset对应的值，那就默认使用utf-8编码，这个是非常有用的。</p><p>因此，总结一下就是我们后面会调用AlipaySignature的rsaCheckV2方法，而且该方法是含有sign_type参数的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   public static boolean rsaCheckV2(Map&lt;String, String&gt; params, String publicKey,</span><br><span class="line">           String charset,String signType) throws AlipayApiException &#123;</span><br><span class="line">String sign = params.get(&quot;sign&quot;);</span><br><span class="line">String content = getSignCheckContentV2(params);</span><br><span class="line"></span><br><span class="line">return rsaCheck(content, sign, publicKey, charset,signType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意上的publicKey是指图中的这个：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a49ade1e087112ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>你填的也就是这个：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0158e87896488d97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><code>com.alipay.demo.trade.config</code>这个包里面就提供了用于获取该zfbinfo.properies里面配置信息的方法：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0e1bab964c450707.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>现在我们需要提供给前端，轮询查询订单的支付状态，我们在二维码扫码支付完成以后，前台会调用我们这个接口，查看是否支付成功了。</p><h2 id="前台轮询查询订单状态"><a href="#前台轮询查询订单状态" class="headerlink" title="前台轮询查询订单状态"></a>前台轮询查询订单状态</h2><p>打开OrderController.java文件，里面新增代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> *  前台轮询查询订单状态</span><br><span class="line"> * @author envy</span><br><span class="line"> * */</span><br><span class="line">@RequestMapping(value = &quot;query_order_pay_status.do&quot;)  //这里就是具体的每个方法的url链接</span><br><span class="line">@ResponseBody   //自动序列化json功能</span><br><span class="line">public ServerResponse&lt;Boolean&gt; queryOrderPayStatus(HttpSession session,Long orderNo) &#123;</span><br><span class="line">    //验证用户是否登录</span><br><span class="line">    User user =(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">    //未登录需要用户强制登录</span><br><span class="line">    if(user ==null)&#123;</span><br><span class="line">        return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),ResponseCode.NEED_LOGIN.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //实现我们前台轮询查询订单状态的逻辑</span><br><span class="line">    ServerResponse serverResponse= iOrderService.queryOrderPayStatus(user.getId(),orderNo);</span><br><span class="line">    if (serverResponse.isSuccess()) &#123;</span><br><span class="line">        return ServerResponse.createBySuccess(true);</span><br><span class="line">    &#125;</span><br><span class="line">    return ServerResponse.createBySuccess(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着打开OrderServiceImpl.java文件，里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line">   *  前台轮询查询订单状态</span><br><span class="line">   * @author envy</span><br><span class="line">   * */</span><br><span class="line">  public ServerResponse queryOrderPayStatus(Integer userId, Long orderNo)&#123;</span><br><span class="line">      //查询订单是否存在</span><br><span class="line">      Order order =orderMapper.selectOrderByUserIdAndOrderNo(userId,orderNo);</span><br><span class="line">      //如果订单不存在的话</span><br><span class="line">      if(order ==null)&#123;</span><br><span class="line">          return ServerResponse.createByErrorMessage(&quot;对不起，该用户没有该订单&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      //存在的话，就判断订单的状态，此时则表明已经支付了</span><br><span class="line">      if(order.getStatus()&gt;= Const.OrderStatusEnum.PAID.getCode())&#123;</span><br><span class="line">          return ServerResponse.createBySuccess();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return ServerResponse.createByError();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>最后打开IOrderService.java文件，添加接口抽象方法，以供controller调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerResponse queryOrderPayStatus(Integer userId, Long orderNo);   //前台轮询查询订单状态</span><br></pre></td></tr></table></figure></p><p>这样我们关于支付宝的3个接口的开发就都完成了，然后就是接口测试了，很简单，大家可以参看我提供的接口文档自行进行测试，这里就不进行了。感谢你的赏阅！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本篇来完成支付宝支付回调的功能，其实这个是非常简单的，但是我专门用一篇笔记来记录主要就是希望自己可以好好的进行完善。&lt;/p&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://blog.licheetools.top/categories/java/"/>
    
    
      <category term="SSM框架" scheme="http://blog.licheetools.top/tags/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="JAVA后端" scheme="http://blog.licheetools.top/tags/JAVA%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>SSM搭建二手市场交易平台（二十四）：支付宝支付功能开发</title>
    <link href="http://blog.licheetools.top/2018/09/02/SSM%E6%90%AD%E5%BB%BA%E4%BA%8C%E6%89%8B%E5%B8%82%E5%9C%BA%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91/"/>
    <id>http://blog.licheetools.top/2018/09/02/SSM搭建二手市场交易平台（二十四）：支付宝支付功能开发/</id>
    <published>2018-09-02T05:21:06.000Z</published>
    <updated>2019-04-15T14:20:15.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>前面那些都是一些铺垫，从现在开始我们正式进入到项目的支付宝实战阶段。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先我们将自己在支付宝里配置的zfbinfo.properties文件复制到resources文件里面，然后将支付宝官方demo中提供的4个含有sdk的jar包复制到图中所示的lib包里面。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b2b0cb663a6e2fef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>你也看到了，demo中不止含有那些sdk的包，还有其他的包：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0d73a91645f34dbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这里我们就不全部拷贝了，而是通过配置文件，将包的版本信息添加到配置文件里面，然后直接从中央仓库里下载即可，其实开始的pom.xml里面就已经全部包含了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b483368943400ec3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>所以这一步你其实是可以跳过的。接着打开main包下面的java包，在里面新建一个包<code>com.alipay.demo.trade</code>，然后将demo里面的Main和DemoHbRunner这两个文件复制过去。你会发现所有文件都报红了，那是因为我们前面4个jar包没有进行导入。打开File–&gt;project Structure–&gt;Modules，然后按照图中所示进行操作：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-f346903b19e9893e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-d6a1634ca5d8b6b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>还有这个pom.xml的底部的这行代码，还有为什么将之前的jar包都放在lib文件夹下面，那是因为服务器只会到WEB-INF下面的lib文件去找jar包，而不是其他的地方，因此我们只能将其放在lib包下面。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e003bec5125048fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>然后运行一下Main函数，检测一下我们的类和包是否加载正确：（出现支付宝预下单成功的字段就代表成功了，如果没有请参考上一篇笔记进行检查）</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-644f3e83cac83c6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>好了现在正式进入到订单模块的开发，相应表的设计如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4e5cd04ea5b3eef6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="支付开发"><a href="#支付开发" class="headerlink" title="支付开发"></a>支付开发</h2><p>首先我们打开controller这个包下面的portal包，在里面新建一个OrderController.java文件，里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package top.store.controller.portal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line">import top.store.common.Const;</span><br><span class="line">import top.store.common.ResponseCode;</span><br><span class="line">import top.store.common.ServerResponse;</span><br><span class="line">import top.store.pojo.User;</span><br><span class="line">import top.store.service.IOrderService;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * @author Envy</span><br><span class="line"> * */</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/order/&quot;)</span><br><span class="line">public class OrderController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private IOrderService iOrderService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 支付宝支付功能开发</span><br><span class="line">     * @author envy</span><br><span class="line">     * */</span><br><span class="line">    @RequestMapping(value = &quot;pay.do&quot;)  //这里就是具体的每个方法的url链接</span><br><span class="line">    @ResponseBody   //自动序列化json功能</span><br><span class="line">    public ServerResponse pay(HttpSession session, Long orderNo, HttpServletRequest request)&#123;</span><br><span class="line">        //这里传入三个参数，第一个是需要用户登录，第二个则是传入订单号，第三个则是利用它来获取我们servlet的上下文，拿到我们upload的文件夹，将自动生成的二维码上传到ftp服务器上面</span><br><span class="line">        //然后我们就会返回给前端一个二维码的地址，前端将二维码进行展示，用于用户进行扫码和支付</span><br><span class="line"></span><br><span class="line">        //验证用户是否登录</span><br><span class="line">        User user =(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">        //未登录需要用户强制登录</span><br><span class="line">        if(user ==null)&#123;</span><br><span class="line">            return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),ResponseCode.NEED_LOGIN.getDesc());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //从request中获取我们的服务器上图片的地址。</span><br><span class="line">        String path = request.getSession().getServletContext().getRealPath(&quot;upload&quot;);  //这里的path后面是没有斜线的就是只有upload</span><br><span class="line"></span><br><span class="line">        return iOrderService.pay(orderNo,user.getId(),path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着打开sevcice包下面的Impl包，我们新建一个接口的实现类OrderServiceImpl.java文件，里面的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line">package top.store.service.impl;</span><br><span class="line"></span><br><span class="line">import com.alipay.api.AlipayResponse;</span><br><span class="line">import com.alipay.api.response.AlipayTradePrecreateResponse;</span><br><span class="line">import com.alipay.demo.trade.config.Configs;</span><br><span class="line">import com.alipay.demo.trade.model.ExtendParams;</span><br><span class="line">import com.alipay.demo.trade.model.GoodsDetail;</span><br><span class="line">import com.alipay.demo.trade.model.builder.AlipayTradePrecreateRequestBuilder;</span><br><span class="line">import com.alipay.demo.trade.model.result.AlipayF2FPrecreateResult;</span><br><span class="line">import com.alipay.demo.trade.service.AlipayTradeService;</span><br><span class="line">import com.alipay.demo.trade.service.impl.AlipayTradeServiceImpl;</span><br><span class="line">import com.alipay.demo.trade.utils.ZxingUtils;</span><br><span class="line">import com.google.common.collect.Lists;</span><br><span class="line">import com.google.common.collect.Maps;</span><br><span class="line">import org.apache.commons.lang3.StringUtils;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import top.store.common.ServerResponse;</span><br><span class="line">import top.store.dao.OrderItemMapper;</span><br><span class="line">import top.store.dao.OrderMapper;</span><br><span class="line">import top.store.pojo.Order;</span><br><span class="line">import top.store.pojo.OrderItem;</span><br><span class="line">import top.store.service.IOrderService;</span><br><span class="line">import top.store.util.BigDecimalUtil;</span><br><span class="line">import top.store.util.FTPUtil;</span><br><span class="line">import top.store.util.PropertiesUtil;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author Envy</span><br><span class="line"> * */</span><br><span class="line">@Service(&quot;iOrderService&quot;)</span><br><span class="line">public class OrderServiceImpl implements IOrderService &#123;</span><br><span class="line">    //输出打印日志</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(OrderServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderMapper orderMapper;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderItemMapper orderItemMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 支付宝当面付2.0服务</span><br><span class="line">    private static AlipayTradeService tradeService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public ServerResponse pay(Long orderNo,Integer userId,String path)&#123;</span><br><span class="line">        Map&lt;String, String&gt; resultMap = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">        //根据用户Id和订单号orderNo来查询订单是否存在，如果不存在</span><br><span class="line">        Order order =orderMapper.selectOrderByUserIdAndOrderNo(userId,orderNo);</span><br><span class="line">        if(order ==null)&#123;</span><br><span class="line">            return ServerResponse.createByErrorMessage(&quot;对不起，该用户没有该订单&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        resultMap.put(&quot;orderNo&quot;,String.valueOf(order.getOrderNo()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // (必填) 商户网站订单系统中唯一订单号，64个字符以内，只能包含字母、数字、下划线，</span><br><span class="line">        // 需保证商户系统端不能重复，建议通过数据库sequence生成，</span><br><span class="line">        String outTradeNo = order.getOrderNo().toString();</span><br><span class="line"></span><br><span class="line">        // (必填) 订单标题，粗略描述用户的支付目的。如“xxx品牌xxx门店消费”</span><br><span class="line">        String subject = new StringBuilder().append(&quot;光明二手商城扫码支付，订单号:&quot;).append(outTradeNo).toString();</span><br><span class="line"></span><br><span class="line">        // (必填) 订单总金额，单位为元，不能超过1亿元</span><br><span class="line">        // 如果同时传入了【打折金额】,【不可打折金额】,【订单总金额】三者,则必须满足如下条件:【订单总金额】=【打折金额】+【不可打折金额】</span><br><span class="line">        String totalAmount = order.getPayment().toString();</span><br><span class="line"></span><br><span class="line">        // (必填) 付款条码，用户支付宝钱包手机app点击“付款”产生的付款条码</span><br><span class="line">        String authCode = &quot;用户自己的支付宝付款码&quot;; // 条码示例，286648048691290423</span><br><span class="line">        // (可选，根据需要决定是否使用) 订单可打折金额，可以配合商家平台配置折扣活动，如果订单部分商品参与打折，可以将部分商品总价填写至此字段，默认全部商品可打折</span><br><span class="line">        // 如果该值未传入,但传入了【订单总金额】,【不可打折金额】 则该值默认为【订单总金额】- 【不可打折金额】</span><br><span class="line">        //        String discountableAmount = &quot;1.00&quot;; //</span><br><span class="line"></span><br><span class="line">        // (可选) 订单不可打折金额，可以配合商家平台配置折扣活动，如果酒水不参与打折，则将对应金额填写至此字段</span><br><span class="line">        // 如果该值未传入,但传入了【订单总金额】,【打折金额】,则该值默认为【订单总金额】-【打折金额】</span><br><span class="line">        String undiscountableAmount = &quot;0.0&quot;;</span><br><span class="line"></span><br><span class="line">        // 卖家支付宝账号ID，用于支持一个签约账号下支持打款到不同的收款账号，(打款到sellerId对应的支付宝账号)</span><br><span class="line">        // 如果该字段为空，则默认为与支付宝签约的商户的PID，也就是appid对应的PID</span><br><span class="line">        String sellerId = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        // 订单描述，可以对交易或商品进行一个详细地描述，比如填写&quot;购买商品3件共20.00元&quot;</span><br><span class="line">        String body = new StringBuilder().append(&quot;订单&quot;).append(outTradeNo).append(&quot;购买商品共花&quot;).append(totalAmount).append(&quot;元&quot;).toString();</span><br><span class="line"></span><br><span class="line">        // 商户操作员编号，添加此参数可以为商户操作员做销售统计</span><br><span class="line">        String operatorId = &quot;test_operator_id&quot;;</span><br><span class="line"></span><br><span class="line">        // (必填) 商户门店编号，通过门店号和商家后台可以配置精准到门店的折扣信息，详询支付宝技术支持</span><br><span class="line">        String storeId = &quot;test_store_id&quot;;</span><br><span class="line"></span><br><span class="line">        // 业务扩展参数，目前可添加由支付宝分配的系统商编号(通过setSysServiceProviderId方法)，详情请咨询支付宝技术支持</span><br><span class="line">        String providerId = &quot;2088100200300400500&quot;;</span><br><span class="line">        ExtendParams extendParams = new ExtendParams();</span><br><span class="line">        extendParams.setSysServiceProviderId(providerId);</span><br><span class="line"></span><br><span class="line">        // 支付超时，线下扫码交易定义为5分钟</span><br><span class="line">        String timeoutExpress = &quot;5m&quot;;</span><br><span class="line"></span><br><span class="line">        // 商品明细列表，需填写购买商品详细信息，</span><br><span class="line">        List&lt;GoodsDetail&gt; goodsDetailList = new ArrayList&lt;GoodsDetail&gt;();</span><br><span class="line"></span><br><span class="line">        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">        //这里是自己定义的逻辑，因为上面的goodsDetailList还没有信息，因此我们需要往里面添加信息</span><br><span class="line">        //我们根据orderId和userId来拿到这个orderItemList。然后遍历这个列表，把我们的GoodsDetail给填充上，最后添加到goodsDetailList列表中</span><br><span class="line">        List&lt;OrderItem&gt; orderItemList =orderItemMapper.getOrderItemByUserIdAndOrderNo(userId,orderNo);</span><br><span class="line">        for(OrderItem orderItem:orderItemList)&#123;</span><br><span class="line">            // 创建一个商品信息，参数含义分别为商品id（使用国标）、名称、单价（单位为分）、数量，如果需要添加商品类别，详见GoodsDetail</span><br><span class="line">            GoodsDetail goods = GoodsDetail.newInstance(orderItem.getId().toString(), orderItem.getProductName(),</span><br><span class="line">                    (BigDecimalUtil.mut(orderItem.getCurrentUnitPrice().doubleValue(),new Double(100).doubleValue())).longValue(), orderItem.getQuantity());</span><br><span class="line"></span><br><span class="line">            goodsDetailList.add(goods);</span><br><span class="line">        &#125;</span><br><span class="line">        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 创建扫码支付请求 builder，设置请求参数</span><br><span class="line">        AlipayTradePrecreateRequestBuilder builder = new AlipayTradePrecreateRequestBuilder()</span><br><span class="line">                .setSubject(subject).setTotalAmount(totalAmount).setOutTradeNo(outTradeNo)</span><br><span class="line">                .setUndiscountableAmount(undiscountableAmount).setSellerId(sellerId).setBody(body)</span><br><span class="line">                .setOperatorId(operatorId).setStoreId(storeId).setExtendParams(extendParams)</span><br><span class="line">                .setTimeoutExpress(timeoutExpress)</span><br><span class="line">                .setNotifyUrl(PropertiesUtil.getProperty(PropertiesUtil.getProperty(&quot;alipay.callback.url&quot;)))//支付宝服务器主动通知商户服务器里指定的页面 http 路径,根据需要设置</span><br><span class="line">                .setGoodsDetailList(goodsDetailList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /** 一定要在创建AlipayTradeService之前调用Configs.init()设置默认参数</span><br><span class="line">         *  Configs会读取classpath下的zfbinfo.properties文件配置信息，如果找不到该文件则确认该文件是否在classpath目录</span><br><span class="line">         */</span><br><span class="line">        Configs.init(&quot;zfbinfo.properties&quot;);</span><br><span class="line"></span><br><span class="line">        /** 使用Configs提供的默认参数</span><br><span class="line">         *  AlipayTradeService可以使用单例或者为静态成员对象，不需要反复new</span><br><span class="line">         */</span><br><span class="line">        tradeService = new AlipayTradeServiceImpl.ClientBuilder().build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        AlipayF2FPrecreateResult result = tradeService.tradePrecreate(builder);</span><br><span class="line">        switch (result.getTradeStatus()) &#123;</span><br><span class="line">            case SUCCESS:</span><br><span class="line">                logger.info(&quot;支付宝预下单成功: )&quot;);</span><br><span class="line"></span><br><span class="line">                AlipayTradePrecreateResponse response = result.getResponse();</span><br><span class="line">                dumpResponse(response);</span><br><span class="line"></span><br><span class="line">                File folder = new File(path);</span><br><span class="line">                if (!folder.exists()) &#123;</span><br><span class="line">                    folder.setWritable(true);</span><br><span class="line">                    folder.mkdirs();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 需要修改为运行机器上的路径</span><br><span class="line">                // 细节</span><br><span class="line">                String qrPath = String.format(path + &quot;/qr-%s.png&quot;, response.getOutTradeNo());  //这里后面一定要添加/</span><br><span class="line">                String qrFileName = String.format(&quot;qr-%s.png&quot;, response.getOutTradeNo());</span><br><span class="line">                ZxingUtils.getQRCodeImge(response.getQrCode(), 256, qrPath);</span><br><span class="line"></span><br><span class="line">                //目标文件夹</span><br><span class="line">                File targetFile = new File(path, qrFileName);</span><br><span class="line">                try &#123;</span><br><span class="line">                    FTPUtil.uploadFile(Lists.newArrayList(targetFile));</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    logger.error(&quot;上传二维码异常&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                logger.info(&quot;qrPath:&quot; + qrPath);</span><br><span class="line">                String qrUrl = PropertiesUtil.getProperty(&quot;ftp.server.http.prefix&quot;) + targetFile.getName();</span><br><span class="line">                resultMap.put(&quot;qrUrl&quot;, qrUrl);</span><br><span class="line">                return ServerResponse.createBySuccess(resultMap);</span><br><span class="line">            case FAILED:</span><br><span class="line">                logger.error(&quot;支付宝预下单失败!!!&quot;);</span><br><span class="line">                return ServerResponse.createByErrorMessage(&quot;支付宝预下单失败!!!&quot;);</span><br><span class="line"></span><br><span class="line">            case UNKNOWN:</span><br><span class="line">                logger.error(&quot;系统异常，预下单状态未知!!!&quot;);</span><br><span class="line">                return ServerResponse.createByErrorMessage(&quot;系统异常，预下单状态未知!!!&quot;);</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                logger.error(&quot;不支持的交易状态，交易返回异常!!!&quot;);</span><br><span class="line">                return ServerResponse.createByErrorMessage(&quot;不支持的交易状态，交易返回异常!!!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 简单打印应答</span><br><span class="line">    private void dumpResponse(AlipayResponse response) &#123;</span><br><span class="line">        if (response != null) &#123;</span><br><span class="line">            logger.info(String.format(&quot;code:%s, msg:%s&quot;, response.getCode(), response.getMsg()));</span><br><span class="line">            if (StringUtils.isNotEmpty(response.getSubCode())) &#123;</span><br><span class="line">                logger.info(String.format(&quot;subCode:%s, subMsg:%s&quot;, response.getSubCode(),</span><br><span class="line">                        response.getSubMsg()));</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(&quot;body:&quot; + response.getBody());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里面的代码是非常的多，而且都是核心代码，所以我需要进行说明：<br><strong>1、</strong>首先用户支付以后得到的是一个支付订单，订单里面有很多信息，因此我们使用map这个图来进行数据存取，key是订单号，value则是订单值。然后我们需要去数据库里面查询订单是否存在，，所以看到这行代码<code>Order order=orderMapper.selectOrderByUserIdAndOrderNo(userId,orderNo);</code>就说明我们需要打开OrderMapper.java文件，新增sql查询方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//注意在mybatis中使用多个参数时，需要使用param注解</span><br><span class="line">Order selectOrderByUserIdAndOrderNo(@Param(value = &quot;userId&quot;)Integer userId,@Param(value = &quot;OrderNo&quot;) Long OrderNo);</span><br></pre></td></tr></table></figure></p><p>接着打开OrderMapper.xml，在里面新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectOrderByUserIdAndOrderNo&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;map&quot;&gt;</span><br><span class="line">  select</span><br><span class="line">  &lt;include refid=&quot;Base_Column_List&quot;/&gt;</span><br><span class="line">  from store_order</span><br><span class="line">  where user_id =#&#123;userId&#125;</span><br><span class="line">  and order_no =#&#123;OrderNo&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p><p><strong>2、</strong>后面的那些代码就是支付宝的当面付生成二维码的核心代码，你打开Main.java文件，找到test_trade_precreate这个方法，大概是第371行代码到文件末尾。大家注意两行<code>///////</code>之间的代码，这里是自己定义的逻辑，因为上面的goodsDetailList还没有信息，因此我们需要往里面添加信息。我们根据orderId和userId来拿到这个orderItemList，然后遍历这个列表，把我们的GoodsDetail给填充上，最后添加到goodsDetailList列表中。</p><p>同样看到这行代码<code>List&lt;OrderItem&gt; orderItemList =orderItemMapper.getOrderItemByUserIdAndOrderNo(userId,orderNo);</code>就说明我们需要打开OrderItemMapper.java文件，新增sql查询方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//注意在mybatis中使用多个参数时，需要使用param注解</span><br><span class="line">List&lt;OrderItem&gt; getOrderItemByUserIdAndOrderNo(@Param(value = &quot;userId&quot;)Integer userId,@Param(value = &quot;orderNo&quot;)Long orderNo);</span><br></pre></td></tr></table></figure></p><p>接着打开OrderItemMapper.xml，在里面新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getOrderItemByUserIdAndOrderNo&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;map&quot;&gt;</span><br><span class="line">  select</span><br><span class="line">  &lt;include refid=&quot;Base_Column_List&quot;/&gt;</span><br><span class="line">  from store_order_item</span><br><span class="line">  where order_no =#&#123;orderNo&#125;</span><br><span class="line">  and user_id =#&#123;userId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p><p><strong>3、</strong>注意这行代码<code>setNotifyUrl(PropertiesUtil.getProperty(PropertiesUtil.getProperty(&quot;alipay.callback.url&quot;)))//支付宝服务器主动通知商户服务器里指定的页面http路径,根据需要设置</code>。针对这个，我们需要打开store.propertise文件，配置这个属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alipay.callback.url=http://store.licheetools.top/order/alipay_callback.do</span><br></pre></td></tr></table></figure></p><p>当然如果前面配置了这个信息，现在就可以不配置了。<br><strong>4、</strong>后面代码的意思生成的二维码如何保存到服务器上，以及存放的位置。这个<code>dumpResponse</code>函数你就可以直接拿来使用了。</p><p>最后别忘记在sevcice包下面新建一个IOrderService接口类，里面的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package top.store.service;</span><br><span class="line"></span><br><span class="line">import top.store.common.ServerResponse;</span><br><span class="line"></span><br><span class="line">public interface IOrderService &#123;</span><br><span class="line">    ServerResponse pay(Long orderNo, Integer userId, String path);   //支付宝当面付</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样关于支付宝当面付的功能开发，我们就完成了，感谢你的赏阅！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;前面那些都是一些铺垫，从现在开始我们正式进入到项目的支付宝实战阶段。&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="java" scheme="http://blog.licheetools.top/categories/java/"/>
    
    
      <category term="SSM框架" scheme="http://blog.licheetools.top/tags/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="JAVA后端" scheme="http://blog.licheetools.top/tags/JAVA%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>SSM搭建二手市场交易平台（二十三）：支付宝官方文档简要说明</title>
    <link href="http://blog.licheetools.top/2018/09/01/SSM%E6%90%AD%E5%BB%BA%E4%BA%8C%E6%89%8B%E5%B8%82%E5%9C%BA%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E/"/>
    <id>http://blog.licheetools.top/2018/09/01/SSM搭建二手市场交易平台（二十三）：支付宝官方文档简要说明/</id>
    <published>2018-09-01T05:21:06.000Z</published>
    <updated>2019-04-15T14:19:29.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本部分我们来进行支付宝官方文档简要说明，里面有些东西挺难理解的。。。</p><h2 id="沙箱环境"><a href="#沙箱环境" class="headerlink" title="沙箱环境"></a>沙箱环境</h2><p>首先点击这里进行<a href="https://openhome.alipay.com/platform/appDaily.htm?tab=tool" target="_blank" rel="noopener">注册</a>，选择个人开发即可。接着点击<a href="https://docs.open.alipay.com/54/104506/" target="_blank" rel="noopener">这里</a>下载当面付DEMO，这里选择java版。然后可以点击<a href="https://docs.open.alipay.com/54/103419/" target="_blank" rel="noopener">这里</a>参看下载文档。</p><p>然后就直接打开Demo项目，这是一个web项目，需要配置jdk和其他环境，具体如下：打开zfbinfo.properties文件，修改以下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open_api_domain = https://openapi.alipay.com/gateway.do</span><br><span class="line">mcloud_api_domain = http://mcloudmonitor.com/gateway.do</span><br><span class="line">pid = 此处请填写你的PID</span><br><span class="line">appid = 此处请填写你当面付的APPID</span><br></pre></td></tr></table></figure></p><p>分别对应这个<a href="https://openhome.alipay.com/platform/appDaily.htm?tab=info" target="_blank" rel="noopener">沙箱页面</a>的图中所示信息：<br>第一行代码对应2，第二行不用修改，第三行对应1，第四行对应3:</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0c244279f110ab44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>接下来是RSA私钥、公钥和支付宝公钥<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># RSA私钥、公钥和支付宝公钥</span><br><span class="line">private_key = 此处请填写你的商户私钥且转PKCS8格式</span><br><span class="line">public_key = 此处请填写你的商户公钥</span><br></pre></td></tr></table></figure></p><p>点击这里下载<a href="https://docs.open.alipay.com/291/105971" target="_blank" rel="noopener">生成RSA密钥工具</a>，然后按照要求生成密匙：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-cc73a1c96d719aeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>接下来是SHA256withRsa对应支付宝公钥（其中SHAwithRsa公钥已经废弃）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alipay_public_key=</span><br></pre></td></tr></table></figure></p><p>回到<a href="https://openhome.alipay.com/platform/appDaily.htm?tab=info" target="_blank" rel="noopener">沙箱环境页面</a>，点击出现的图中所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-d56db2e5cd902f25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-434334e4b54d7522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>然后把刚才上面的public_key复制进去，就会得到支付宝公钥，填到那里即可：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-12aa1bf0ae50c79c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这样我们相关的配置就弄好了，接下来就可以直接去运行main方法了（不要设置tomcat服务器）</p><p>运行结果里面会包含一张二维码链接：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2a583ccf1891e7a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>我们去百度搜索二维码生成，把链接放进去，就会显示二维码。或者点击这里<a href="https://cli.im/" target="_blank" rel="noopener">草料二维码</a>:</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-794231b076bc6b1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><strong>注意</strong>如果出现下面的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read time out</span><br><span class="line">......................</span><br><span class="line">com.alipay.demo.trade.Main test_trade_precreate</span><br><span class="line">严重: 系统异常，预下单状态未知!!!</span><br></pre></td></tr></table></figure></p><p>请查看这篇文章：<a href="https://my.oschina.net/u/3659713/blog/2992158" target="_blank" rel="noopener">支付宝沙箱demo运行出现read timed out的解决办法</a>，因此从这里开始，我java版本变成了<strong>java8</strong>，不再使用java10了，大家一定要注意。</p><p>接着你点击<a href="https://openhome.alipay.com/platform/appDaily.htm?tab=tool" target="_blank" rel="noopener">这里</a>下载沙箱安卓版：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-cf308da3125b4668.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>然后点击<a href="https://openhome.alipay.com/platform/appDaily.htm?tab=account" target="_blank" rel="noopener">这里</a>获取买家和卖家的信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e20142ce3f78b312.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>记住沙箱APP账号只能是上面的，不能使用自己真实的信息。</p><p>具体的可以参考这篇文章，这篇挺详细的：<a href="https://blog.csdn.net/DuTianTian_csdn/article/details/80777780" target="_blank" rel="noopener">支付宝沙箱环境demo测试</a>和这一篇<a href="http://blog.51cto.com/zero01/2128909" target="_blank" rel="noopener">【Java版】接入支付宝当面付功能-沙箱环境</a></p><p>然后扫描二维码，就能付款了。</p><p>注意在使用java8的时候，需要修改java10的配置：打开File–&gt;Project Structure，然后具体的配置按照图片所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-d1869905d8fab536.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b00ccb4206321854.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ef970506705fe2d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-936c4c3d3763d018.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>注意上面4个地方的配置，一个都不能少，否则就会报错，切记切记。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本部分我们来进行支付宝官方文档简要说明，里面有些东西挺难理解的。。。&lt;/p&gt;
&lt;h2 id=&quot;沙箱环境&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="java" scheme="http://blog.licheetools.top/categories/java/"/>
    
    
      <category term="SSM框架" scheme="http://blog.licheetools.top/tags/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="JAVA后端" scheme="http://blog.licheetools.top/tags/JAVA%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>SSM搭建二手市场交易平台（二十二）：支付宝支付功能对接要点介绍</title>
    <link href="http://blog.licheetools.top/2018/08/31/SSM%E6%90%AD%E5%BB%BA%E4%BA%8C%E6%89%8B%E5%B8%82%E5%9C%BA%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E5%8A%9F%E8%83%BD%E5%AF%B9%E6%8E%A5%E8%A6%81%E7%82%B9%E4%BB%8B%E7%BB%8D/"/>
    <id>http://blog.licheetools.top/2018/08/31/SSM搭建二手市场交易平台（二十二）：支付宝支付功能对接要点介绍/</id>
    <published>2018-08-31T04:21:06.000Z</published>
    <updated>2019-04-15T14:18:44.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本部分我们来完成支付宝支付功能的开发，具体包括支付宝对接，支付回调以及查询支付状态的开发，里面涉及到的知识点挺多的，需要好好理解。</p><h2 id="模块说明"><a href="#模块说明" class="headerlink" title="模块说明"></a>模块说明</h2><p>本模块主要介绍支付宝对接，支付回调以及查询支付状态这三个部分。</p><h2 id="学会技能"><a href="#学会技能" class="headerlink" title="学会技能"></a>学会技能</h2><p>在本模块中，你将会学到支付宝对接核心文档，调用支付宝支付功能官方 Demo；解析支付宝 SDK 对接源码；RSA1 和 RSA2 验证签名及加密；避免支付宝重复通知和数据校验；natapp 外网穿透和 Tomcat remote debug以及生成二维码，并持久化到图片服务器等功能。</p><h2 id="数据表的设计"><a href="#数据表的设计" class="headerlink" title="数据表的设计"></a>数据表的设计</h2><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3387e341a1b80242.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="支付宝支付功能对接要点介绍"><a href="#支付宝支付功能对接要点介绍" class="headerlink" title="支付宝支付功能对接要点介绍"></a>支付宝支付功能对接要点介绍</h2><p>1、一些重要的官方文档<br>2、沙箱调试环境（买家账号测试，商家账号测试）<br>3、支付宝扫码支付主业务流程<br>4、支付宝扫码支付流程<br>5、支付宝扫码支付重要的字段<br>6、支付宝扫码支付重要细节<br>7、支付宝扫码支付对接技巧<br>8、支付宝扫码支付官方 Demo 调试</p><h2 id="沙箱调试环境"><a href="#沙箱调试环境" class="headerlink" title="沙箱调试环境"></a>沙箱调试环境</h2><p>蚂蚁沙箱环境（Beta）：是协助开发者进行接口功能开发及主要功能联调的辅助环境，沙箱环境模拟了开放平台部分产品的主要功能和主要逻辑（参考“沙箱支持产品列表”），为保证沙箱文档，沙箱环境测试数据会进行定期数据清理，Beta 测试阶段每日的 21:00 至次日的 9:00 为维护时间，在此时间内沙箱环境部分功能可能会不可用。</p><p>为保证沙箱稳定，沙箱环境测试数据会进行定期数据清理。Beta测试阶段每周日中午12点至每周一中午12点为维护时间。在此时间内沙箱环境部分功能可能会不可用，敬请谅解。</p><h2 id="支付宝扫码支付主业务流程"><a href="#支付宝扫码支付主业务流程" class="headerlink" title="支付宝扫码支付主业务流程"></a>支付宝扫码支付主业务流程</h2><p>这里的流程其实最主要是指当面付这个模块，你可以点击<a href="https://docs.open.alipay.com/194/105072/" target="_blank" rel="noopener">这里</a>或者参看下面的图片来了解支付宝扫码支付主业务流程：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-921ba25f7110e1d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>以及条码支付，所谓的条码支付是指：支付宝给到线下传统行业的一种收款方式。商户使用扫码枪等条码识别设备扫描用户支付宝钱包上的条码/二维码，完成收款。用户仅需出示付款码，所有操作由商户端完成。</p><p>你可以点击<a href="https://docs.open.alipay.com/194/105170/" target="_blank" rel="noopener">这里</a>或者参看下面的图片来了解支付宝条码支付流程：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9f3a40283e7c7430.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="支付宝扫码支付重要的字段"><a href="#支付宝扫码支付重要的字段" class="headerlink" title="支付宝扫码支付重要的字段"></a>支付宝扫码支付重要的字段</h2><p>你可以点击<a href="https://docs.open.alipay.com/194/105170/" target="_blank" rel="noopener">这里</a>或者参看下面的图片来了解支付宝扫码支付重要的字段：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b42b95087e37c19d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>还有其他的关键字段：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-54bec8230875109b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="交易状态说明"><a href="#交易状态说明" class="headerlink" title="交易状态说明"></a>交易状态说明</h3><p>你可以点击<a href="https://docs.open.alipay.com/59/103672" target="_blank" rel="noopener">这里</a>或者参看下面的图片来了解支付宝扫码支付交易状态说明：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-66df13fef4e1da13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="通知触发条件"><a href="#通知触发条件" class="headerlink" title="通知触发条件"></a>通知触发条件</h2><p>你可以点击<a href="https://docs.open.alipay.com/59/103666/" target="_blank" rel="noopener">这里</a>或者参看下面的图片来了解支付宝扫码支付通知触发条件：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6e327f3f0d48f885.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="支付渠道说明"><a href="#支付渠道说明" class="headerlink" title="支付渠道说明"></a>支付渠道说明</h2><p>你可以点击<a href="https://docs.open.alipay.com/common/103259" target="_blank" rel="noopener">这里</a>或者参看下面的图片来了解支付宝扫码支付渠道说明：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-134ccf1044058512.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>我们后面会使用到第二个，支付宝账户，也就是余额。</p><h2 id="支付宝扫码支付的重要细节"><a href="#支付宝扫码支付的重要细节" class="headerlink" title="支付宝扫码支付的重要细节"></a>支付宝扫码支付的重要细节</h2><p>1、主动轮询和回调的区别</p><blockquote><p>我从网上找了一个比较有意思的介绍，你可以看一下：<br>轮询：过10分钟就到女朋友宿舍前面去看她有没有回来、没回来我就再去打游戏。<br>监听：我搬个凳子坐到她宿舍前、直到她回来。<br>回调：在她门口贴个条子：回来后请打电话至011 。</p></blockquote><p>2、避免单边账</p><blockquote><p>所谓“单边账”，即完成取(存)款操作后，银行与用户只有一方账面发生相应变化。</p></blockquote><p>3、同步请求的加签和验证签名</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9eb0f4cfc84eff61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2137c76c44f5720c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>4、回调的验证（签名、金额、订单号、订单状态、交易状态、商户 id）</p><p>5、过滤掉重复的通知</p><p>6、一定要验证并确保可接受的异步通知是支付宝发出的</p><p>7、回调请求返回</p><blockquote><p>程序执行完后必须打印输出“success”（不包含引号），如果商户反馈给支付宝的字符不是 success 这 7 个字符，支付宝服务器会不断重发通知，直到超过 24 小时 22 分钟，一般情况下，25 小时以内完成 8 次通知。（通知的间隔频率一般是：4m，10m，10m，1h，2h，6h，15h）</p></blockquote><h2 id="支付宝扫码支付对接技巧"><a href="#支付宝扫码支付对接技巧" class="headerlink" title="支付宝扫码支付对接技巧"></a>支付宝扫码支付对接技巧</h2><h3 id="回调的调试方法"><a href="#回调的调试方法" class="headerlink" title="回调的调试方法"></a>回调的调试方法</h3><p>1、路由器设置开放本地到外网（不推荐）</p><p>2、外网远程 debug（保持远端代码版本和本地代码一致，及时关闭开放的debug端口）</p><p>3、内网穿透（ngrok，natapp、花生壳）</p><h3 id="外网远程debug"><a href="#外网远程debug" class="headerlink" title="外网远程debug"></a>外网远程debug</h3><p>1、保持远端代码版本和本地代码版本一致</p><p>2、执行 sudo vim ${tomcat}/bin/catalina.sh 进行编辑</p><p>3、添加如下配置，其中 address 为开放远程 debug 的端口号 CATALINA_OPTS=”-server -Xdebug -Xnoagent -Djava.compile=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005”</p><p>4、把开放远程 debug 的端口加到防火墙配置中</p><p>5、及时关闭开放的 debug 端口</p><p>6、编辑 sudo vim /etc/sysconfig/iptables</p><p>7、添加如下配置 -A INPUT -p tcp -m tcp –dport 5005 -j ACCEPT</p><p>8、:wq 保存退出</p><p>9、重启防火墙 sudo service iptables restart</p><h3 id="内网穿透（ngrok、natapp、花生壳）"><a href="#内网穿透（ngrok、natapp、花生壳）" class="headerlink" title="内网穿透（ngrok、natapp、花生壳）"></a>内网穿透（ngrok、natapp、花生壳）</h3><p>1、登录 <a href="https://natapp.cn" target="_blank" rel="noopener">https://natapp.cn</a></p><p>2、注册账号、可以选择是否购买隧道还是使用免费隧道</p><p>3、设置对外开放的端口</p><p>4、下载对应的客户端，如果是 Linux 或 mac 请执行 sudo chmod a+x 赋予用户、用户组、其他用户执行权限</p><p>5、按照官网操作说明运行程序，加入 authtoken 参数</p><p>6、通过开放的外网域名进行访问测试</p><p>这样本篇关于支付宝支付功能对接要点介绍就到这里了，感谢你的赏阅！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本部分我们来完成支付宝支付功能的开发，具体包括支付宝对接，支付回调以及查询支付状态的开发，里面涉及到的知识点挺多的，需要好好
      
    
    </summary>
    
      <category term="java" scheme="http://blog.licheetools.top/categories/java/"/>
    
    
      <category term="SSM框架" scheme="http://blog.licheetools.top/tags/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="JAVA后端" scheme="http://blog.licheetools.top/tags/JAVA%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>SSM搭建二手市场交易平台（二十一）：收货地址模块开发</title>
    <link href="http://blog.licheetools.top/2018/08/30/SSM%E6%90%AD%E5%BB%BA%E4%BA%8C%E6%89%8B%E5%B8%82%E5%9C%BA%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/"/>
    <id>http://blog.licheetools.top/2018/08/30/SSM搭建二手市场交易平台（二十一）：收货地址模块开发/</id>
    <published>2018-08-30T11:21:06.000Z</published>
    <updated>2019-04-15T14:17:58.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本篇我们来完成收货地址模块功能的开发，具体包括收货地址的增删改查操作，分页列表以及地址详情等功能的开发，里面涉及到的知识点挺多的，需要好好理解。</p><h2 id="模块说明"><a href="#模块说明" class="headerlink" title="模块说明"></a>模块说明</h2><p>本模块具体包括以下几个功能：添加地址；删除地址；更新地址；地址列表；地址分页和地址详情等。</p><h2 id="学会技能"><a href="#学会技能" class="headerlink" title="学会技能"></a>学会技能</h2><p>在本模块中，你将会学到SpringMVC数据绑定中对象绑定；Mybatis 自动生成主键、配置和使用；如何避免横向越权漏洞的巩固。</p><h2 id="数据表的设计"><a href="#数据表的设计" class="headerlink" title="数据表的设计"></a>数据表的设计</h2><p><img src="https://upload-images.jianshu.io/upload_images/8964398-97a8dd7b5126731e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="收货地址增加"><a href="#收货地址增加" class="headerlink" title="收货地址增加"></a>收货地址增加</h2><p>首先我们打开controller这个包下面的portal包，在里面新建一个ShippingController.java文件，里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package top.store.controller.portal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line">import top.store.common.Const;</span><br><span class="line">import top.store.common.ResponseCode;</span><br><span class="line">import top.store.common.ServerResponse;</span><br><span class="line">import top.store.pojo.Shipping;</span><br><span class="line">import top.store.pojo.User;</span><br><span class="line">import top.store.service.IShippingService;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/shipping/&quot;)  //这是我们对整个前台商品功能配置的一个类似于namespace的东西</span><br><span class="line">public class ShippingController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private IShippingService iShippingService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 前台--收货地址的增加</span><br><span class="line">     * @author lenovo</span><br><span class="line">     * */</span><br><span class="line">    @RequestMapping(value = &quot;add.do&quot;)  //这里就是具体的每个方法的url链接</span><br><span class="line">    @ResponseBody   //自动序列化json功能</span><br><span class="line">    public ServerResponse add(HttpSession session, Shipping shipping)&#123;   //这里是SpringMVC数据绑定中对象绑定</span><br><span class="line">        //验证用户是否登录</span><br><span class="line">        User user =(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">        //未登录需要用户强制登录</span><br><span class="line">        if(user ==null)&#123;</span><br><span class="line">            return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),ResponseCode.NEED_LOGIN.getDesc());</span><br><span class="line">        &#125;</span><br><span class="line">        //实现我们前台收货地址增加的逻辑</span><br><span class="line">        return iShippingService.add(user.getId(),shipping);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着打开sevcice包，新建IShippingService.Java文件，里面新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package top.store.service;</span><br><span class="line"></span><br><span class="line">import top.store.common.ServerResponse;</span><br><span class="line">import top.store.pojo.Shipping;</span><br><span class="line"></span><br><span class="line">public interface IShippingService &#123;</span><br><span class="line">    ServerResponse add(Integer userId, Shipping shipping);    //前台--收货地址的增加</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着打开sevcice包下面的Impl包，我们新建一个接口的实现类ShippingServiceImpl.java文件，里面的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package top.store.service.impl;</span><br><span class="line"></span><br><span class="line">import com.google.common.collect.Maps;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import top.store.common.ServerResponse;</span><br><span class="line">import top.store.dao.ShippingMapper;</span><br><span class="line">import top.store.pojo.Shipping;</span><br><span class="line">import top.store.service.IShippingService;</span><br><span class="line"></span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">@Service(&quot;iShippingService&quot;)</span><br><span class="line">public class ShippingServiceImpl implements IShippingService &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ShippingMapper shippingMapper;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 前台--收货地址的增加</span><br><span class="line">     * @author lenovo</span><br><span class="line">     * */</span><br><span class="line">    public ServerResponse add(Integer userId,Shipping shipping)&#123;</span><br><span class="line">        shipping.setUserId(userId);   //shipping对象中的userId，我们直接从前台登录中的session中获取</span><br><span class="line">        int rowCount =shippingMapper.insert(shipping);   //这样我们刚才获取到的userId就能直接使用了</span><br><span class="line">        if(rowCount&gt;0)&#123;</span><br><span class="line">            //我们和前端约定，增加后返回shippingId，而且这个key就是shippingId，这样我们就能直接利用map来获取相关信息了</span><br><span class="line">            Map resultMap = Maps.newHashMap();</span><br><span class="line">            resultMap.put(&quot;shippingId&quot;,shipping.getId());</span><br><span class="line">            return ServerResponse.createBySuccess(&quot;创建新地址成功！&quot;,resultMap);</span><br><span class="line">        &#125;</span><br><span class="line">        return ServerResponse.createByErrorMessage(&quot;创建新地址失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，我们这里shipping对象中的userId，是直接从前台登录中的session中获取的。我们希望使用map来完成添加收货地址的功能，但是数据库中的<code>shippingMapper.insert(shipping);</code>里面主键id不能立即获取并使用，因此我们需要将主键赋值到自己定义的keyProperty中，这样就能立即获取了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- useGeneratedKeys=&quot;true&quot;把新增加的主键赋值到自己定义的keyProperty（id）中 --&gt;</span><br><span class="line">&lt;insert id=&quot;insert&quot; parameterType=&quot;top.store.pojo.Shipping&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</span><br><span class="line">  insert into store_shipping (id, user_id, receiver_name, </span><br><span class="line">    receiver_phone, receiver_mobile, receiver_province, </span><br><span class="line">    receiver_city, receiver_district, receiver_address, </span><br><span class="line">    receiver_zip, create_time, update_time</span><br><span class="line">    )</span><br><span class="line">  values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;userId,jdbcType=INTEGER&#125;, #&#123;receiverName,jdbcType=VARCHAR&#125;, </span><br><span class="line">    #&#123;receiverPhone,jdbcType=VARCHAR&#125;, #&#123;receiverMobile,jdbcType=VARCHAR&#125;, #&#123;receiverProvince,jdbcType=VARCHAR&#125;, </span><br><span class="line">    #&#123;receiverCity,jdbcType=VARCHAR&#125;, #&#123;receiverDistrict,jdbcType=VARCHAR&#125;, #&#123;receiverAddress,jdbcType=VARCHAR&#125;, </span><br><span class="line">    #&#123;receiverZip,jdbcType=VARCHAR&#125;, now(), now()</span><br><span class="line">    )</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line">&lt;!--useGeneratedKeys 取值范围true|false 默认值是：false。 含义：设置是否使用JDBC的getGenereatedKeys方法获取主键并赋值到keyProperty设置的领域模型属性中。--&gt;</span><br></pre></td></tr></table></figure></p><p>也就是第二行代码变成上面的样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insert&quot; parameterType=&quot;top.store.pojo.Shipping&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>这样我们收货地址增加的功能就实现了，接下来完成收货地址删除的功能。</p><h2 id="收货地址删除"><a href="#收货地址删除" class="headerlink" title="收货地址删除"></a>收货地址删除</h2><p>老规矩，打开ShippingController.java文件，里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 前台--收货地址的删除</span><br><span class="line"> * @author lenovo</span><br><span class="line"> * */</span><br><span class="line">@RequestMapping(value = &quot;del.do&quot;)  //这里就是具体的每个方法的url链接</span><br><span class="line">@ResponseBody   //自动序列化json功能</span><br><span class="line">public ServerResponse del(HttpSession session,Integer shippingId)&#123;   //这里是SpringMVC数据绑定中对象绑定</span><br><span class="line">    //验证用户是否登录</span><br><span class="line">    User user =(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">    //未登录需要用户强制登录</span><br><span class="line">    if(user ==null)&#123;</span><br><span class="line">        return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),ResponseCode.NEED_LOGIN.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line">    //实现我们前台收货地址删除的逻辑</span><br><span class="line">    return iShippingService.del(user.getId(),shippingId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着打开ShippingServiceImpl.java文件，里面新增代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    /***</span><br><span class="line">     * 前台--收货地址的删除</span><br><span class="line">     * @author lenovo</span><br><span class="line">     * */</span><br><span class="line">    public ServerResponse&lt;String&gt; del(Integer userId,Integer shippingId)&#123;</span><br><span class="line">        //注意这里会产生横向越权问题，因为这个delete语句里面没有与用户进行绑定，因此是不可以使用的</span><br><span class="line">//       int rowCount = shippingMapper.deleteByPrimaryKey(shippingId);</span><br><span class="line">        int rowCount = shippingMapper.deleteShippingByUserIdAndShippingId(userId,shippingId);</span><br><span class="line">        if(rowCount&gt;0)&#123;</span><br><span class="line">            return ServerResponse.createBySuccess(&quot;删除收货地址成功！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return ServerResponse.createByErrorMessage(&quot;删除收货地址失败&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>注意如果你使用<code>int rowCount = shippingMapper.deleteByPrimaryKey(shippingId);</code>就会产生横向越权问题，因为这个delete语句里面没有与用户进行绑定，因此是不可以使用的，你需要自己定义一个查询的方法。打开ShippingMapper.java文件，里面写入一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//注意在mybatis中使用多个参数时，需要使用param注解</span><br><span class="line">int deleteShippingByUserIdAndShippingId(@Param(value = &quot;userId&quot;)Integer userId,@Param(value = &quot;shippingId&quot;) Integer shippingId);</span><br></pre></td></tr></table></figure></p><p>接着打开ShippingMapper.xml文件，里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;delete id=&quot;deleteShippingByUserIdAndShippingId&quot;  parameterType=&quot;map&quot;&gt;</span><br><span class="line">  delete from store_shipping</span><br><span class="line">  where user_id =#&#123;userId&#125;</span><br><span class="line">  and id =#&#123;shippingId&#125;</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure></p><p>最后打开IShippingService.Java文件，里面新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerResponse&lt;String&gt; del(Integer userId,Integer shippingId);    //前台--收货地址的删除</span><br></pre></td></tr></table></figure></p><p>这样我们收货地址删除的功能就实现了，接下来完成收货地址修改的功能。</p><h2 id="收货地址修改"><a href="#收货地址修改" class="headerlink" title="收货地址修改"></a>收货地址修改</h2><p>老规矩，打开ShippingController.java文件，里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 前台--收货地址的更新</span><br><span class="line"> * @author lenovo</span><br><span class="line"> * */</span><br><span class="line">@RequestMapping(value = &quot;update.do&quot;)  //这里就是具体的每个方法的url链接</span><br><span class="line">@ResponseBody   //自动序列化json功能</span><br><span class="line">public ServerResponse update(HttpSession session,Shipping shipping)&#123;   //这里是SpringMVC数据绑定中对象绑定</span><br><span class="line">    //验证用户是否登录</span><br><span class="line">    User user =(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">    //未登录需要用户强制登录</span><br><span class="line">    if(user ==null)&#123;</span><br><span class="line">        return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),ResponseCode.NEED_LOGIN.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line">    //实现我们前台收货地址更新的逻辑</span><br><span class="line">    return iShippingService.update(user.getId(),shipping);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着打开ShippingServiceImpl.java文件，里面新增代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    /***</span><br><span class="line">     * 前台--收货地址的更新</span><br><span class="line">     * @author lenovo</span><br><span class="line">     * */</span><br><span class="line">    public ServerResponse update(Integer userId,Shipping shipping)&#123;</span><br><span class="line">        shipping.setUserId(userId);   //shipping对象中的userId，我们直接从前台登录中的session中获取</span><br><span class="line">        //注意这里会产生横向越权问题，因为这个delete语句里面没有与用户进行绑定，因此是不可以使用的</span><br><span class="line">//        int rowCount =shippingMapper.insert(shipping);   //这样我们刚才获取到的userId就能直接使用了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //自己定义的sql语句方法</span><br><span class="line">        int rowCount =shippingMapper.updateByShipping(shipping);</span><br><span class="line">        if(rowCount&gt;0)&#123;</span><br><span class="line">            //注意这里不需要将id进行返回给前端，因为前面已经获取到了</span><br><span class="line">            return ServerResponse.createBySuccess(&quot;更新新地址成功！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return ServerResponse.createByErrorMessage(&quot;更新新地址失败&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>注意如果你使用<code>int rowCount =shippingMapper.insert(shipping);</code>就会产生横向越权问题，因为这个update语句里面没有与用户进行绑定，因此是不可以使用的，你需要自己定义一个查询的方法。打开ShippingMapper.java文件，里面写入一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int updateByShipping(Shipping record);</span><br></pre></td></tr></table></figure></p><p>接着打开ShippingMapper.xml文件，里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注意这里面的userId是不可以更改的，所以一定要从set里面去掉，而且and语句最后的括号一定要去掉--&gt;</span><br><span class="line">&lt;update id=&quot;updateByShipping&quot; parameterType=&quot;top.store.pojo.Shipping&quot;&gt;</span><br><span class="line">  update store_shipping</span><br><span class="line">  set</span><br><span class="line">    receiver_name = #&#123;receiverName,jdbcType=VARCHAR&#125;,</span><br><span class="line">    receiver_phone = #&#123;receiverPhone,jdbcType=VARCHAR&#125;,</span><br><span class="line">    receiver_mobile = #&#123;receiverMobile,jdbcType=VARCHAR&#125;,</span><br><span class="line">    receiver_province = #&#123;receiverProvince,jdbcType=VARCHAR&#125;,</span><br><span class="line">    receiver_city = #&#123;receiverCity,jdbcType=VARCHAR&#125;,</span><br><span class="line">    receiver_district = #&#123;receiverDistrict,jdbcType=VARCHAR&#125;,</span><br><span class="line">    receiver_address = #&#123;receiverAddress,jdbcType=VARCHAR&#125;,</span><br><span class="line">    receiver_zip = #&#123;receiverZip,jdbcType=VARCHAR&#125;,</span><br><span class="line">    create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">    update_time = now()</span><br><span class="line">  where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  and user_id = #&#123;userId,jdbcType=INTEGER&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure></p><p>看到没有，这里的update语句和里面提供sql语句非常相似，但是记住里面的userId是不可以更改的，所以一定要从set里面去掉，而且and语句最后的括号一定要去掉。关于第一行代码的来源，大家可以自行查看原生的sql语句。</p><p>最后打开IShippingService.Java文件，里面新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerResponse update(Integer userId,Shipping shipping);   //前台--收货地址的更新</span><br></pre></td></tr></table></figure></p><p>这样我们收货地址修改的功能就实现了，接下来完成收货地址查询的功能。</p><h2 id="收货地址查询"><a href="#收货地址查询" class="headerlink" title="收货地址查询"></a>收货地址查询</h2><p>老规矩，打开ShippingController.java文件，里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 前台--收货地址的查询</span><br><span class="line"> * @author lenovo</span><br><span class="line"> * */</span><br><span class="line">@RequestMapping(value = &quot;select.do&quot;)  //这里就是具体的每个方法的url链接</span><br><span class="line">@ResponseBody   //自动序列化json功能</span><br><span class="line">public ServerResponse&lt;Shipping&gt; select(HttpSession session,Integer shippingId)&#123;   //这里是SpringMVC数据绑定中对象绑定</span><br><span class="line">    //验证用户是否登录</span><br><span class="line">    User user =(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">    //未登录需要用户强制登录</span><br><span class="line">    if(user ==null)&#123;</span><br><span class="line">        return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),ResponseCode.NEED_LOGIN.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line">    //实现我们前台收货地址查询的逻辑</span><br><span class="line">    return iShippingService.select(user.getId(),shippingId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着打开ShippingServiceImpl.java文件，里面新增代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    /***</span><br><span class="line">     * 前台--收货地址的查询</span><br><span class="line">     * @author lenovo</span><br><span class="line">     * */</span><br><span class="line">    public ServerResponse&lt;Shipping&gt; select(Integer userId,Integer shippingId)&#123;</span><br><span class="line">        //注意这里会产生横向越权问题，因为这个select语句里面没有与用户进行绑定，因此是不可以使用的</span><br><span class="line">//        int rowCount =shippingMapper.selectByPrimaryKey(shippingId);</span><br><span class="line">        Shipping shipping =shippingMapper.selectByUserIdAndShippingId(userId,shippingId);</span><br><span class="line">        if(shipping == null)&#123;</span><br><span class="line">            return ServerResponse.createByErrorMessage(&quot;无法查询到该地址&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return ServerResponse.createBySuccess(&quot;该地址查询到了！&quot;,shipping);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>注意如果你使用<code>int rowCount =shippingMapper.selectByPrimaryKey(shippingId);</code>就会产生横向越权问题，因为这个select语句里面没有与用户进行绑定，因此是不可以使用的，你需要自己定义一个查询的方法。打开ShippingMapper.java文件，里面写入一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//注意在mybatis中使用多个参数时，需要使用param注解</span><br><span class="line">Shipping selectByUserIdAndShippingId(@Param(value = &quot;userId&quot;)Integer userId,@Param(value = &quot;shippingId&quot;) Integer shippingId);</span><br></pre></td></tr></table></figure></p><p>接着打开ShippingMapper.xml文件，里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectByUserIdAndShippingId&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;map&quot;&gt;</span><br><span class="line">        SELECT</span><br><span class="line">        &lt;include refid=&quot;Base_Column_List&quot;/&gt;</span><br><span class="line">        from store_shipping</span><br><span class="line">        where id = #&#123;shippingId&#125;</span><br><span class="line">        and user_id = #&#123;userId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p><p>最后打开IShippingService.Java文件，里面新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerResponse&lt;Shipping&gt; select(Integer userId,Integer shippingId);   //前台--收货地址的查询</span><br></pre></td></tr></table></figure></p><p>这样我们收货地址查询的功能就实现了，接下来完成收货地址详情分页的功能。</p><h2 id="收货地址详情分页"><a href="#收货地址详情分页" class="headerlink" title="收货地址详情分页"></a>收货地址详情分页</h2><p>老规矩，打开ShippingController.java文件，里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 前台--收货地址的列表分页</span><br><span class="line"> * @author envy</span><br><span class="line"> * */</span><br><span class="line">@RequestMapping(value = &quot;list.do&quot;)  //这里就是具体的每个方法的url链接</span><br><span class="line">@ResponseBody   //自动序列化json功能</span><br><span class="line">public ServerResponse&lt;PageInfo&gt; list(HttpSession session, @RequestParam(value = &quot;pageNum&quot; ,defaultValue = &quot;1&quot;)int pageNum, @RequestParam(value = &quot;pageSize&quot; ,defaultValue = &quot;10&quot;)int pageSize)&#123;</span><br><span class="line">    //验证用户是否登录</span><br><span class="line">    User user =(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">    //未登录需要用户强制登录</span><br><span class="line">    if(user ==null)&#123;</span><br><span class="line">        return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),ResponseCode.NEED_LOGIN.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line">    //实现我们前台收货地址的列表分页的逻辑</span><br><span class="line">  return iShippingService.list(user.getId(),pageNum,pageSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着打开ShippingServiceImpl.java文件，里面新增代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/***</span><br><span class="line"> * 前台--收货地址的列表分页</span><br><span class="line"> * @author envy</span><br><span class="line"> * */</span><br><span class="line">public ServerResponse&lt;PageInfo&gt; list(Integer userId,int pageNum,int pageSize)&#123;</span><br><span class="line">    //开始分页</span><br><span class="line">    PageHelper.startPage(pageNum,pageSize);</span><br><span class="line">    //根据用户id来查询shipping对象</span><br><span class="line">    List&lt;Shipping&gt; shippingList =shippingMapper.selectShippingByUserId(userId);</span><br><span class="line"></span><br><span class="line">    //构造PageInfo对象</span><br><span class="line">    PageInfo pageInfo =new PageInfo(shippingList);</span><br><span class="line"></span><br><span class="line">    //返回PageInfo对象</span><br><span class="line">    return ServerResponse.createBySuccess(pageInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意如看到<code>shippingMapper.selectShippingByUserId(userId);</code>就知道应该打开ShippingMapper.java文件，里面写入一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Shipping&gt; selectShippingByUserId(Integer userId);</span><br></pre></td></tr></table></figure></p><p>接着打开ShippingMapper.xml文件，里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注意一个参数使用int或者map都是可以的--&gt;</span><br><span class="line">&lt;select id=&quot;selectShippingByUserId&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;map&quot;&gt;</span><br><span class="line">    select</span><br><span class="line">    &lt;include refid=&quot;Base_Column_List&quot;/&gt;</span><br><span class="line">    from store_shipping</span><br><span class="line">    where user_id =#&#123;userId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p><p>最后打开IShippingService.Java文件，里面新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerResponse&lt;PageInfo&gt; list(Integer userId, int pageNum, int pageSize);     //前台--收货地址的列表分页</span><br></pre></td></tr></table></figure></p><p>这样我们收货地址详情分页的功能就实现了，至此所有关于购物车的模块功能就全部实现了。接下来是模块测试，很简单，大家可以参看我提供的接口文档自行进行测试，这里就不进行了，感谢你的赏阅！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本篇我们来完成收货地址模块功能的开发，具体包括收货地址的增删改查操作，分页列表以及地址详情等功能的开发，里面涉及到的知识点挺
      
    
    </summary>
    
      <category term="java" scheme="http://blog.licheetools.top/categories/java/"/>
    
    
      <category term="SSM框架" scheme="http://blog.licheetools.top/tags/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="JAVA后端" scheme="http://blog.licheetools.top/tags/JAVA%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>SSM搭建二手市场交易平台（二十）：购物车商品的状态设置</title>
    <link href="http://blog.licheetools.top/2018/08/29/SSM%E6%90%AD%E5%BB%BA%E4%BA%8C%E6%89%8B%E5%B8%82%E5%9C%BA%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%EF%BC%9A%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%95%86%E5%93%81%E7%9A%84%E7%8A%B6%E6%80%81%E8%AE%BE%E7%BD%AE/"/>
    <id>http://blog.licheetools.top/2018/08/29/SSM搭建二手市场交易平台（二十）：购物车商品的状态设置/</id>
    <published>2018-08-29T08:21:06.000Z</published>
    <updated>2019-04-15T14:17:10.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本篇主要介绍如何实现购物车商品的全选，全反选，单选，单反选以及购物车商品数量查询等功能。</p><h2 id="购物车商品的全选"><a href="#购物车商品的全选" class="headerlink" title="购物车商品的全选"></a>购物车商品的全选</h2><p>我们打开CartController.java文件，在里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 前台购物车商品全选</span><br><span class="line"> * @author lenovo</span><br><span class="line"> * */</span><br><span class="line">@RequestMapping(value = &quot;select_all.do&quot;)  //这里就是具体的每个方法的url链接</span><br><span class="line">@ResponseBody   //自动序列化json功能</span><br><span class="line">public ServerResponse&lt;CartVo&gt; selectAll(HttpSession session)&#123;</span><br><span class="line">    //验证用户是否登录</span><br><span class="line">    User user =(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">    //未登录需要用户强制登录</span><br><span class="line">    if(user ==null)&#123;</span><br><span class="line">        return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),ResponseCode.NEED_LOGIN.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line">    //实现我们购物车商品全选的逻辑</span><br><span class="line">    return iCartService.selectOrUnSelect(user.getId(),null,Const.Cart.CHECKED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着打开CartServiceImpl.java文件，往里面添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 前台购物车商品全选或者全反选</span><br><span class="line"> * @author envy</span><br><span class="line"> * */</span><br><span class="line">public ServerResponse&lt;CartVo&gt; selectOrUnSelect(Integer userId,Integer productId,Integer checked)&#123;</span><br><span class="line">    cartMapper.checkedOrUncheckedProduct(userId,productId,checked);</span><br><span class="line">    return this.list(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意一下，之前我们最后返回的都是两行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CartVo cartVo =this.getCartVoLimit(userId);</span><br><span class="line">return ServerResponse.createBySuccess(cartVo);</span><br></pre></td></tr></table></figure></p><p>但是呢，前面我们也说过因为这两行代码已经被list进行封装了，因此现在直接调用list即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return this.list(userId);</span><br></pre></td></tr></table></figure></p><p>看到<code>cartMapper.checkedOrUncheckedProduct(userId,productId,checked);</code>这行代码，我们就知道需要去CartMapper.java文件里面新增一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//注意在mybatis中使用多个参数时，需要使用param注解</span><br><span class="line">int checkedOrUncheckedProduct(@Param(&quot;userId&quot;) Integer userId,@Param(&quot;productId&quot;)Integer productId,@Param(&quot;checked&quot;) Integer checked);</span><br></pre></td></tr></table></figure></p><p>紧接着去CartMapper.xml文件里面新增sql查询语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注意set多个值时，需要用逗号隔开--&gt;</span><br><span class="line">  &lt;update id=&quot;checkedOrUncheckedProduct&quot; parameterType=&quot;map&quot;&gt;</span><br><span class="line">    update store_cart</span><br><span class="line">    set checked  =#&#123;checked&#125;，</span><br><span class="line">    update_time =now()</span><br><span class="line">    where user_id =#&#123;userId&#125;</span><br><span class="line">&lt;if test=&quot;productId != null&quot;&gt;</span><br><span class="line">    and product_id = #&#123;productId&#125;</span><br><span class="line">  &lt;/if&gt;</span><br><span class="line">  &lt;/update&gt;</span><br></pre></td></tr></table></figure></p><p>有人可能要问了，你全选与全反选是不需要商品id的，那在这里写干嘛，的确是不需要，但是我们后面要实现的单选和单反选却是需要的，因此写在这里只是为了后面代码更好的复用。这也就是我们为什么将参数productId设置为null的原因。<br>最后打开ICartService.java文件，新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerResponse&lt;CartVo&gt; selectOrUnSelectAll(Integer userId,Integer productId,Integer checked);   //前台购物车商品全选或者全反选,或者单选，或者单反选</span><br></pre></td></tr></table></figure></p><p>接下来完成购物车商品的全反选功能，这个和全选相反，你除了需要修改控制器controller里面的代码以外，其余的代码就可以不要修改了。</p><h2 id="购物车商品的全反选"><a href="#购物车商品的全反选" class="headerlink" title="购物车商品的全反选"></a>购物车商品的全反选</h2><p>我们打开CartController.java文件，在里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 前台购物车商品全反选</span><br><span class="line"> * @author lenovo</span><br><span class="line"> * */</span><br><span class="line">@RequestMapping(value = &quot;un_select_all.do&quot;)  //这里就是具体的每个方法的url链接</span><br><span class="line">@ResponseBody   //自动序列化json功能</span><br><span class="line">public ServerResponse&lt;CartVo&gt; unSelectAll(HttpSession session)&#123;</span><br><span class="line">    //验证用户是否登录</span><br><span class="line">    User user =(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">    //未登录需要用户强制登录</span><br><span class="line">    if(user ==null)&#123;</span><br><span class="line">        return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),ResponseCode.NEED_LOGIN.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line">    //实现我们购物车商品全选的逻辑</span><br><span class="line">    return iCartService.selectOrUnSelectAll(user.getId(),null,Const.Cart.UN_CHECKED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后就可以了，是不是超级简单。</p><h2 id="购物车商品的单选"><a href="#购物车商品的单选" class="headerlink" title="购物车商品的单选"></a>购物车商品的单选</h2><p>想起我们前面做的工作了莫，这个依旧很简单，和我们购物车商品的全反选操作一样。打开CartController.java文件，在里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 前台购物车商品单选</span><br><span class="line"> * @author lenovo</span><br><span class="line"> * */</span><br><span class="line">@RequestMapping(value = &quot;select_one.do&quot;)  //这里就是具体的每个方法的url链接</span><br><span class="line">@ResponseBody   //自动序列化json功能</span><br><span class="line">public ServerResponse&lt;CartVo&gt; selectOne(HttpSession session,Integer productId)&#123;</span><br><span class="line">    //验证用户是否登录</span><br><span class="line">    User user =(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">    //未登录需要用户强制登录</span><br><span class="line">    if(user ==null)&#123;</span><br><span class="line">        return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),ResponseCode.NEED_LOGIN.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line">    //实现我们购物车商品单选的逻辑</span><br><span class="line">    return iCartService.selectOrUnSelect(user.getId(),productId,Const.Cart.CHECKED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>说了两次，那么购物车商品的单反选，你也就知道了吧！</p><h2 id="购物车商品的单反选"><a href="#购物车商品的单反选" class="headerlink" title="购物车商品的单反选"></a>购物车商品的单反选</h2><p>打开CartController.java文件，在里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 前台购物车商品单反选</span><br><span class="line"> * @author lenovo</span><br><span class="line"> * */</span><br><span class="line">@RequestMapping(value = &quot;un_select_one.do&quot;)  //这里就是具体的每个方法的url链接</span><br><span class="line">@ResponseBody   //自动序列化json功能</span><br><span class="line">public ServerResponse&lt;CartVo&gt; UnSelectOne(HttpSession session,Integer productId)&#123;</span><br><span class="line">    //验证用户是否登录</span><br><span class="line">    User user =(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">    //未登录需要用户强制登录</span><br><span class="line">    if(user ==null)&#123;</span><br><span class="line">        return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),ResponseCode.NEED_LOGIN.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line">    //实现我们购物车商品单反选的逻辑</span><br><span class="line">    return iCartService.selectOrUnSelect(user.getId(),productId,Const.Cart.UN_CHECKED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来完成购物车商品数量查询这个功能，这个也还是简单的。</p><h2 id="购物车商品数量查询"><a href="#购物车商品数量查询" class="headerlink" title="购物车商品数量查询"></a>购物车商品数量查询</h2><p>这里的购物车商品数量查询是说，当你查询当前用户的购物车里面的商品数量时,假设一个商品有 8个,那么数量就是 8，我们是不按照商品种类来算，而是按数量算的，这也是目前电商的通用做法。</p><p>我们打开CartController.java文件，在里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 前台购物车商品数量查询</span><br><span class="line"> * @author lenovo</span><br><span class="line"> * */</span><br><span class="line">@RequestMapping(value = &quot;get_cart_product_count.do&quot;)  //这里就是具体的每个方法的url链接</span><br><span class="line">@ResponseBody   //自动序列化json功能</span><br><span class="line">public ServerResponse&lt;Integer&gt; getCartProductCount(HttpSession session)&#123;</span><br><span class="line">    //验证用户是否登录</span><br><span class="line">    User user =(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">    //未登录，那么就返回0</span><br><span class="line">    if(user ==null)&#123;</span><br><span class="line">        return ServerResponse.createBySuccess(0);</span><br><span class="line">    &#125;</span><br><span class="line">    //实现我们购物车商品数量查询的逻辑</span><br><span class="line">    return iCartService.getCartProductCount(user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着打开CartServiceImpl.java文件，往里面添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 前台购物车商品数量查询</span><br><span class="line"> * @author lenovo</span><br><span class="line"> * */</span><br><span class="line">public ServerResponse&lt;Integer&gt; getCartProductCount(Integer userId)&#123;</span><br><span class="line">    if(userId ==null)&#123;</span><br><span class="line">        return ServerResponse.createBySuccess(0);</span><br><span class="line">    &#125;</span><br><span class="line">    //购物车商品数量查询</span><br><span class="line">    return ServerResponse.createBySuccess(cartMapper.selectCartProductCount(userId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到<code>cartMapper.selectCartProductCount(userId)</code>这行代码，我们就知道需要去CartMapper.java文件里面新增一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int selectCartProductCount(Integer userId);</span><br></pre></td></tr></table></figure></p><p>然后去CartMapper.xml文件里面新增sql语句：(其中select * as count 是给它起了一个别称)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectCartProductCount&quot; parameterType=&quot;int&quot; resultType=&quot;int&quot;&gt;</span><br><span class="line">  select sum(quantity) as count</span><br><span class="line">  from store_cart</span><br><span class="line">  where user_id = #&#123;userId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p><p>不过这样做有一个问题，就是我们前面返回的是一个int，假设我们这个sql语句最后返回的是0,而你知道Int类型是不能传给0给它的，因此可以将代码代码修改如下，使用<code>IFNULL(sum(quantity),0)</code>，就是说默认就是0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectCartProductCount&quot; parameterType=&quot;int&quot; resultType=&quot;int&quot;&gt;</span><br><span class="line">  select IFNULL(sum(quantity),0) as count</span><br><span class="line">  from store_cart</span><br><span class="line">  where user_id = #&#123;userId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p><p>当然你也可以使用另一种方法，就是修改CartMapper.java文件的返回类型，修改为<code>Integer</code>这一也是可以的。</p><p>然后就是关于购物车模块的接口测试了，很简单，大家可以参看我提供的接口文档自行进行测试，这里就不进行了。</p><p>这样我们本篇关于如何实现购物车商品的全选，全反选，单选，单反选以及购物车商品数量查询等功能的介绍就到此为止了，感谢你的赏阅！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本篇主要介绍如何实现购物车商品的全选，全反选，单选，单反选以及购物车商品数量查询等功能。&lt;/p&gt;
&lt;h2 id=&quot;购物车商品
      
    
    </summary>
    
      <category term="java" scheme="http://blog.licheetools.top/categories/java/"/>
    
    
      <category term="SSM框架" scheme="http://blog.licheetools.top/tags/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="JAVA后端" scheme="http://blog.licheetools.top/tags/JAVA%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>SSM搭建二手市场交易平台（十九）：购物车更新删除查询商品</title>
    <link href="http://blog.licheetools.top/2018/08/28/SSM%E6%90%AD%E5%BB%BA%E4%BA%8C%E6%89%8B%E5%B8%82%E5%9C%BA%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9A%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%9B%B4%E6%96%B0%E5%88%A0%E9%99%A4%E6%9F%A5%E8%AF%A2%E5%95%86%E5%93%81/"/>
    <id>http://blog.licheetools.top/2018/08/28/SSM搭建二手市场交易平台（十九）：购物车更新删除查询商品/</id>
    <published>2018-08-28T07:21:06.000Z</published>
    <updated>2019-04-15T14:16:15.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本篇主要介绍如何将更新、删除和查询购物车里面的商品功能进行实现。</p><h2 id="更新购物车商品"><a href="#更新购物车商品" class="headerlink" title="更新购物车商品"></a>更新购物车商品</h2><p>其实所谓的更新购物车商品就是更新商品在购物车里面的数量罢了。我们打开CartController.java文件，在里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> *  前台修改购物车里面的商品（其实就是商品的数量）</span><br><span class="line"> * @author lenovo</span><br><span class="line"> * */</span><br><span class="line">@RequestMapping(value = &quot;update.do&quot;)  //这里就是具体的每个方法的url链接</span><br><span class="line">@ResponseBody   //自动序列化json功能</span><br><span class="line">public ServerResponse&lt;CartVo&gt; update(HttpSession session, Integer productId, Integer count)&#123;</span><br><span class="line">    //验证用户是否登录</span><br><span class="line">    User user =(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">    //未登录需要用户强制登录</span><br><span class="line">    if(user ==null)&#123;</span><br><span class="line">        return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),ResponseCode.NEED_LOGIN.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //实现我们修改购物车里面的商品的逻辑</span><br><span class="line">    return iCartService.update(user.getId(),productId,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着打开CartServiceImpl.java文件，往里面添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 前台修改购物车里面的商品（其实就是商品的数量）</span><br><span class="line"> * @author lenovo</span><br><span class="line"> * */</span><br><span class="line">public ServerResponse&lt;CartVo&gt; update(Integer userId,Integer productId,Integer count)&#123;</span><br><span class="line">    //传入的参数不正确</span><br><span class="line">    if(productId ==null ||count ==null)&#123;</span><br><span class="line">        return ServerResponse.createByErrorCodeMessage(ResponseCode.ILLEGAL_ARGUMENT.getCode(),ResponseCode.ILLEGAL_ARGUMENT.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //去购物车里面更新相关的信息</span><br><span class="line">    Cart cart  =cartMapper.selectCartByUserIdAndProductId(userId,productId);</span><br><span class="line">    cart.setQuantity(count);</span><br><span class="line">    cartMapper.updateByPrimaryKeySelective(cart);</span><br><span class="line"></span><br><span class="line">    CartVo cartVo =this.getCartVoLimit(userId);</span><br><span class="line">    return ServerResponse.createBySuccess(cartVo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后打开ICartService.java文件，新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerResponse&lt;CartVo&gt; update(Integer userId,Integer productId,Integer count);    //前台修改购物车里面的商品（其实就是商品的数量）</span><br></pre></td></tr></table></figure></p><h2 id="删除购物车商品"><a href="#删除购物车商品" class="headerlink" title="删除购物车商品"></a>删除购物车商品</h2><p>我们打开CartController.java文件，在里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line">    *  前台删除购物车里面的商品</span><br><span class="line">    * @author lenovo</span><br><span class="line">    * */</span><br><span class="line">   @RequestMapping(value = &quot;delete_product.do&quot;)  //这里就是具体的每个方法的url链接</span><br><span class="line">   @ResponseBody   //自动序列化json功能</span><br><span class="line">   public ServerResponse&lt;CartVo&gt; deleteProduct(HttpSession session, String productIds)&#123;</span><br><span class="line">       //注意这里不需要传递数量，而且可以同时删除多个，因此我们和前端约定使用String类型的productIds同时多个参数以逗号进行分割</span><br><span class="line">       //验证用户是否登录</span><br><span class="line">       User user =(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">       //未登录需要用户强制登录</span><br><span class="line">       if(user ==null)&#123;</span><br><span class="line">           return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),ResponseCode.NEED_LOGIN.getDesc());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //实现我们删除购物车里面的商品的逻辑</span><br><span class="line">       return iCartService.deleteProduct(user.getId(),productIds);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>接着打开CartServiceImpl.java文件，往里面添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     *  前台删除购物车里面的商品</span><br><span class="line">     * @author lenovo</span><br><span class="line">     * */</span><br><span class="line">    public ServerResponse&lt;CartVo&gt; deleteProduct(Integer userId,String productIds)&#123;</span><br><span class="line">        //如果我们自己使用Java提供的方法，我们需要把productIds转成数组，然后再遍历数组添加到集合中</span><br><span class="line">//        String[] productStringList =productIds.split(&quot;,&quot;);</span><br><span class="line">//        List&lt;String&gt; productList =new ArrayList&lt;&gt;();</span><br><span class="line">//        for(String product :productList)&#123;</span><br><span class="line">//          productList.add(product);</span><br><span class="line">//       &#125;</span><br><span class="line"></span><br><span class="line">        //因此，这里我们直接使用guava提供的split方法，直接将其转化为列表，其中on代表以什么为分割线，后面的splitToList就代表转成什么函数</span><br><span class="line">       List&lt;String&gt; productList = Splitter.on(&quot;,&quot;).splitToList(productIds);</span><br><span class="line"></span><br><span class="line">        //判断列表是否是空，如果是空也就是不指定删除什么而去执行删除命令，会报出一个参数非法</span><br><span class="line">        if(CollectionUtils.isEmpty(productList))&#123;</span><br><span class="line">            return ServerResponse.createByErrorCodeMessage(ResponseCode.ILLEGAL_ARGUMENT.getCode(),ResponseCode.ILLEGAL_ARGUMENT.getDesc());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //不为空&lt;也就是我们需要执行删除命令了</span><br><span class="line">        cartMapper.deleteProductByUserIdAndProductIds(userId,productList);</span><br><span class="line"></span><br><span class="line">        CartVo cartVo =this.getCartVoLimit(userId);</span><br><span class="line">        return ServerResponse.createBySuccess(cartVo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里我需要说明几点：<br><strong>1、</strong>我们这里的删除是直接根据商品Id来的，但不是一个Id，我们和前端约定传入String类型的商品id，而且多个id之间通过逗号进行的分割。<br><strong>2、</strong>如果我们自己使用Java提供的方法，我们需要把productIds转成数组，然后再遍历数组添加到列表中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] productStringList =productIds.split(&quot;,&quot;);</span><br><span class="line">List&lt;String&gt; productList =new ArrayList&lt;&gt;();</span><br><span class="line">for(String product :productList)&#123;</span><br><span class="line">productList.add(product);</span><br></pre></td></tr></table></figure></p><p>如果我们直接使用guava提供的split方法，直接将其转化为列表，其中on代表以什么为分割线，后面的splitToList就代表转成什么函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; productList = Splitter.on(&quot;,&quot;).splitToList(productIds);</span><br></pre></td></tr></table></figure></p><p>上面也说了我们后台通过遍历商品id这个列表从而来进行商品的删除操作。<br><strong>3、</strong>看到<code>cartMapper.deleteProductByUserIdAndProductIds(userId,productList);</code>这行代码，我们就知道需要去CartMapper.java文件里面新增一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//注意在mybatis中使用多个参数时，需要使用param注解</span><br><span class="line">int deleteProductByUserIdAndProductIds(@Param(value = &quot;userId&quot;)Integer userId,@Param(value = &quot;productIdList&quot;)List&lt;String&gt; productIdList);</span><br></pre></td></tr></table></figure></p><p>紧接着去CartMapper.xml文件里面新增sql查询语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--删除是使用delete这个节点--&gt;</span><br><span class="line"> &lt;delete id=&quot;deleteProductByUserIdAndProductIds&quot; parameterType=&quot;map&quot;&gt;</span><br><span class="line">  delete from store_cart</span><br><span class="line">  where user_id =#&#123;userId&#125;</span><br><span class="line">  &lt;if test=&quot;productIdList != null&quot;&gt;</span><br><span class="line">    and product_id in</span><br><span class="line">    &lt;foreach collection=&quot;productIdList&quot; item=&quot;item&quot; index=&quot;index&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">      #&#123;item&#125;</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">  &lt;/if&gt;</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure></p><p>在这段代码里面，因为我们需要判断productIdList不为空，而且product_id在我们遍历的列表里面。遍历我们使用了foreach，其中collection表示你即将要遍历的对象，item表示遍历的返回对象，index表示当前迭代的次数，open表示以什么开始，separator表示分割符，close表示以什么结束。具体的可以参考写这篇文章：<a href="https://www.cnblogs.com/ysq0908/p/4695097.html" target="_blank" rel="noopener">MyBatis的foreach语句详解</a></p><p>最后打开ICartService.java文件，新增一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerResponse&lt;CartVo&gt; deleteProduct(Integer userId,String productIds);     //前台删除购物车里面的商品</span><br></pre></td></tr></table></figure></p><h2 id="查询购物车商品"><a href="#查询购物车商品" class="headerlink" title="查询购物车商品"></a>查询购物车商品</h2><p>这个功能很简单，因为我们前面增加，删除和修改最后返回的都是CartVo，为什么呢？因为它们都调用了我们这个查询的方法，因此此功能很简单。</p><p>我们打开CartController.java文件，在里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 前台查询购物车里面的商品</span><br><span class="line"> * @author lenovo</span><br><span class="line"> * */</span><br><span class="line">@RequestMapping(value = &quot;list.do&quot;)  //这里就是具体的每个方法的url链接</span><br><span class="line">@ResponseBody   //自动序列化json功能</span><br><span class="line">public ServerResponse&lt;CartVo&gt; list(HttpSession session)&#123;</span><br><span class="line">    //验证用户是否登录</span><br><span class="line">    User user =(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">    //未登录需要用户强制登录</span><br><span class="line">    if(user ==null)&#123;</span><br><span class="line">        return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),ResponseCode.NEED_LOGIN.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line">    //实现我们查询购物车里面商品的逻辑</span><br><span class="line">    return iCartService.list(user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着打开CartServiceImpl.java文件，往里面添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 前台查询购物车里面的商品</span><br><span class="line"> * @author lenovo</span><br><span class="line"> * */</span><br><span class="line">public ServerResponse&lt;CartVo&gt; list(Integer userId)&#123;</span><br><span class="line">    CartVo cartVo =this.getCartVoLimit(userId);</span><br><span class="line">    return ServerResponse.createBySuccess(cartVo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后打开ICartService.java文件，新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerResponse&lt;CartVo&gt; list(Integer userId);   //前台查询购物车里面的商品</span><br></pre></td></tr></table></figure></p><p>这样我们本篇关于更新、删除和查询购物车里面的商品功能的介绍就到此为止了，感谢你的赏阅！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本篇主要介绍如何将更新、删除和查询购物车里面的商品功能进行实现。&lt;/p&gt;
&lt;h2 id=&quot;更新购物车商品&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="java" scheme="http://blog.licheetools.top/categories/java/"/>
    
    
      <category term="SSM框架" scheme="http://blog.licheetools.top/tags/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="JAVA后端" scheme="http://blog.licheetools.top/tags/JAVA%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>SSM搭建二手市场交易平台（十八）：购物车添加商品</title>
    <link href="http://blog.licheetools.top/2018/08/27/SSM%E6%90%AD%E5%BB%BA%E4%BA%8C%E6%89%8B%E5%B8%82%E5%9C%BA%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9A%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%B7%BB%E5%8A%A0%E5%95%86%E5%93%81/"/>
    <id>http://blog.licheetools.top/2018/08/27/SSM搭建二手市场交易平台（十八）：购物车添加商品/</id>
    <published>2018-08-27T05:21:06.000Z</published>
    <updated>2019-04-15T14:15:23.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本章节我们来介绍购物车模块相关功能的开发，具体包括加入商品；更新商品数；查询商品数；移除商品；单选/取消；全选/取消和购物车列表等这几个功能。本篇主要介绍如何将商品加入到购物车，这里面会定义一些可以复用的购物车代码，还有一些功能：如字段校验，数量校验，价格的动态变化等。</p><h2 id="技能掌握"><a href="#技能掌握" class="headerlink" title="技能掌握"></a>技能掌握</h2><p>1、购物车模块的设计思想；<br>2、如何封装一个高复用的购物车核心方法；<br>3、解决浮点型商业运算中丢失精度的问题；</p><p>数据表设计：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-56a5d44e063c7ba8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="商品添加到购物车"><a href="#商品添加到购物车" class="headerlink" title="商品添加到购物车"></a>商品添加到购物车</h2><p>首先我们打开controller这个包下面的portal包，在里面新建一个CartController.java文件，里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package top.store.controller.portal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line">import top.store.common.Const;</span><br><span class="line">import top.store.common.ResponseCode;</span><br><span class="line">import top.store.common.ServerResponse;</span><br><span class="line">import top.store.pojo.User;</span><br><span class="line">import top.store.service.ICartService;</span><br><span class="line">import top.store.vo.CartVo;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/cart/&quot;)  //这是我们对整个前台商品功能配置的一个类似于namespace的东西</span><br><span class="line">public class CartController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ICartService iCartService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 前台往购物车添加商品</span><br><span class="line">     * @author lenovo</span><br><span class="line">     * */</span><br><span class="line">    @RequestMapping(value = &quot;add.do&quot;)  //这里就是具体的每个方法的url链接</span><br><span class="line">    @ResponseBody   //自动序列化json功能</span><br><span class="line">    public ServerResponse&lt;CartVo&gt; add(HttpSession session, Integer productId, Integer count)&#123;</span><br><span class="line">        //验证用户是否登录</span><br><span class="line">        User user =(User) session.getAttribute(Const.CURRENT_USER);</span><br><span class="line">        //未登录需要用户强制登录</span><br><span class="line">        if(user ==null)&#123;</span><br><span class="line">            return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),ResponseCode.NEED_LOGIN.getDesc());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //实现我们购物车添加商品的逻辑</span><br><span class="line">        return iCartService.add(user.getId(),productId,count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后打开service这个包，在里面新建ICartService接口，里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package top.store.service;</span><br><span class="line"></span><br><span class="line">import top.store.common.ServerResponse;</span><br><span class="line">import top.store.vo.CartVo;</span><br><span class="line"></span><br><span class="line">public interface ICartService &#123;</span><br><span class="line">    ServerResponse&lt;CartVo&gt; add(Integer userId, Integer productId, Integer count);   //前台购物车添加商品</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以及在Impl包里面新建一个CartServiceImpl.java文件，里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">package top.store.service.impl;</span><br><span class="line"></span><br><span class="line">import com.google.common.collect.Lists;</span><br><span class="line">import org.apache.commons.collections.CollectionUtils;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import top.store.common.Const;</span><br><span class="line">import top.store.common.ResponseCode;</span><br><span class="line">import top.store.common.ServerResponse;</span><br><span class="line">import top.store.dao.CartMapper;</span><br><span class="line">import top.store.dao.ProductMapper;</span><br><span class="line">import top.store.pojo.Cart;</span><br><span class="line">import top.store.pojo.Product;</span><br><span class="line">import top.store.service.ICartService;</span><br><span class="line">import top.store.util.BigDecimalUtil;</span><br><span class="line">import top.store.util.PropertiesUtil;</span><br><span class="line">import top.store.vo.CartProductVo;</span><br><span class="line">import top.store.vo.CartVo;</span><br><span class="line"></span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Service(&quot;iCartService&quot;)</span><br><span class="line">public class CartServiceImpl implements ICartService &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CartMapper cartMapper;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductMapper productMapper;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 前台往购物车添加商品</span><br><span class="line">     * @author lenovo</span><br><span class="line">     * */</span><br><span class="line">    //注意此处的add里面必须包含userId，因为这个必须是精确到个人进行购物车的商品添加</span><br><span class="line">    public ServerResponse&lt;CartVo&gt; add(Integer userId,Integer productId,Integer count)&#123;</span><br><span class="line">        //传入的参数不正确</span><br><span class="line">        if(productId ==null ||count ==null)&#123;</span><br><span class="line">            return ServerResponse.createByErrorCodeMessage(ResponseCode.ILLEGAL_ARGUMENT.getCode(),ResponseCode.ILLEGAL_ARGUMENT.getDesc());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //去购物车里面查询相关的信息</span><br><span class="line">        Cart cart =cartMapper.selectCartByUserIdAndProductId(userId,productId);   //自定义的sql语句</span><br><span class="line">        if(cart ==null)&#123;</span><br><span class="line">            //该产品不在这个购物车里面,因此需要新增一个这个产品的记录</span><br><span class="line">            Cart cartItem =new Cart();</span><br><span class="line">            cartItem.setQuantity(count);  //往购物车里面添加count数量的商品</span><br><span class="line">            cartItem.setChecked(Const.Cart.CHECKED);   //设置该商品被选中状态（放入购物车的产品是自动被选中的）</span><br><span class="line">            cartItem.setProductId(productId);   //设置商品id</span><br><span class="line">            cartItem.setUserId(userId);    //商品属于用户</span><br><span class="line">            cartMapper.insert(cartItem);   //将商品插入到购物车里面</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //说明该商品已经存在于购物车里.</span><br><span class="line">            //商品已存在,我们就要进行数量相加</span><br><span class="line">            count  =cart.getQuantity() +count;</span><br><span class="line">            cart.setQuantity(count);</span><br><span class="line">            cartMapper.updateByPrimaryKeySelective(cart);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //接下来是核心的功能，如数量判断，值校验，购物车里面的商品也有图片，因此需要组装一个“新的”vo对象。</span><br><span class="line">        CartVo cartVo = this.getCartVoLimit(userId);</span><br><span class="line">        return ServerResponse.createBySuccess(cartVo);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //创建一个用于实现购物车信息的函数</span><br><span class="line">    private CartVo getCartVoLimit(Integer userId)&#123;</span><br><span class="line">        CartVo cartVo =new CartVo();</span><br><span class="line">        List&lt;Cart&gt; cartList =cartMapper.selectCartByUserId(userId);  //自定义的sql语句</span><br><span class="line">        List&lt;CartProductVo&gt; cartProductVoList = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //记住这里一定要使用它的String构造器，否则会出现更大的错误</span><br><span class="line">        BigDecimal cartTotalPrice = new BigDecimal(&quot;0&quot;);</span><br><span class="line"></span><br><span class="line">        if(CollectionUtils.isNotEmpty(cartList))&#123;</span><br><span class="line">            for(Cart cartItem:cartList)&#123;</span><br><span class="line">                CartProductVo cartProductVo =new CartProductVo();</span><br><span class="line">                cartProductVo.setId(cartItem.getId());</span><br><span class="line">                cartProductVo.setUserId(cartItem.getUserId());</span><br><span class="line">                cartProductVo.setProductId(cartItem.getProductId());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                //根据购物车里面的商品Id来获取商品的信息</span><br><span class="line">                Product product =productMapper.selectByPrimaryKey(cartItem.getProductId());</span><br><span class="line">                //如果该商品存在的话，我们就使用前面的CartProductVo进行商品的组装(因为CartProductVo本身是一个对象，但是具体需要什么我们需要进行设置)</span><br><span class="line">                if(product != null)&#123;</span><br><span class="line">                    //我们这里之所以不直接从商品对象里获取信息，是因为后面有些是存在于购物车的，有些存在于商品，很容易造成混乱，因此我们这里就使用了一个组装的购物车商品对象，你需要的时候调用它就可以</span><br><span class="line">                    cartProductVo.setProductName(product.getName());</span><br><span class="line">                    cartProductVo.setProductSubtitle(product.getSubtitle());</span><br><span class="line">                    cartProductVo.setProductMainImage(product.getMainImage());</span><br><span class="line">                    cartProductVo.setProductStatus(product.getStatus());</span><br><span class="line">                    cartProductVo.setProductStock(product.getStock());</span><br><span class="line"></span><br><span class="line">                    //判断库存数量</span><br><span class="line">                    int buyLimitCount = 0;</span><br><span class="line">                    if(product.getStock() &gt;= cartItem.getQuantity())&#123;</span><br><span class="line">                        //库存充足的时候，系统会提示LIMIT_NUM_SUCCESS</span><br><span class="line">                        buyLimitCount = cartItem.getQuantity();</span><br><span class="line">                        cartProductVo.setLimitQuantity(Const.Cart.LIMIT_NUM_SUCCESS);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                        //库存不足的时候，系统提示LIMIT_NUM_FAIL</span><br><span class="line">                        buyLimitCount =product.getStock();</span><br><span class="line">                        cartProductVo.setLimitQuantity(Const.Cart.LIMIT_NUM_FAIL);</span><br><span class="line"></span><br><span class="line">                        //自动更新购物车的有效库存</span><br><span class="line">                        Cart cartForQuantity =new Cart();</span><br><span class="line">                        cartForQuantity.setId(cartItem.getId());</span><br><span class="line">                        cartForQuantity.setQuantity(buyLimitCount);</span><br><span class="line">                        cartMapper.updateByPrimaryKeySelective(cartForQuantity);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    //现在更新cartProductVo对象的其他信息</span><br><span class="line">                    cartProductVo.setQuantity(buyLimitCount);</span><br><span class="line">                    //计算该商品的总价，仅仅针对该商品</span><br><span class="line">                    //进行乘法运算:价格*数量，注意这里的单价因为是BigDecimal类型，所以需要转换成double类型，最后再利用工具类的toString调用String构造器</span><br><span class="line">                    //cartProductVo.setProductTotalPrice(BigDecimalUtil.mut(cartProductVo.getProductPrice().doubleValue(),cartProductVo.getQuantity()));  //这样会引发空指针异常</span><br><span class="line">  cartProductVo.setProductTotalPrice(BigDecimalUtil.mut(product.getPrice().doubleValue(),cartProductVo.getQuantity()));</span><br><span class="line">                    cartProductVo.setProductChecked(cartItem.getChecked());   //选中状态使用购物车自带的属性，不用商品自己设置属性</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //如果不判断是否有商品就进行添加购物车操作，会报空指针异常。(其实就是判断购物车是否是处于被选中状态)</span><br><span class="line">                if(cartItem.getChecked()  ==Const.Cart.CHECKED)&#123;</span><br><span class="line">                    //如果已经勾选,就把之前的商品价格添加到整个购物车总价中进行结算</span><br><span class="line">                    //这里面有2个参数，一个是我们在初始化的时候设置的0，另一个就是上面计算出来的ProductTotalPrice，这两个都需要进行double转化</span><br><span class="line">                    cartTotalPrice =BigDecimalUtil.add(cartTotalPrice.doubleValue(),cartProductVo.getProductTotalPrice().doubleValue());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //把我们上面设置的cartProductVo添加到cartProductVoList里面</span><br><span class="line">                cartProductVoList.add(cartProductVo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //把CartProductVo放入到我们的CartVo里面</span><br><span class="line">        cartVo.setCartTotalPrice(cartTotalPrice);</span><br><span class="line">        cartVo.setCartProductVoList(cartProductVoList);</span><br><span class="line">        cartVo.setAllChecked(this.getAllCheckedStatus(userId));</span><br><span class="line">        cartVo.setImageHost(PropertiesUtil.getProperty(&quot;ftp.server.http.prefix&quot;));   //这里需要直接从服务器中获取</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return cartVo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据用户id来判断购物车是否处于选中状态</span><br><span class="line">    public boolean getAllCheckedStatus (Integer userId)&#123;</span><br><span class="line">        if(userId ==null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果用户不为空</span><br><span class="line">        //这里sql语句结果之所以没有返回boolean是因为我们去数据库里面一般返回的都是int，所以需要进行二次判断</span><br><span class="line">        return cartMapper.selectCartProductCheckedStatusByUserId(userId) ==0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面那个是我们的核心代码，所以我依旧啰嗦几句：<br><strong>1、</strong>首先判断传入的参数是否正确：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(productId ==null ||count ==null)&#123;</span><br><span class="line">           return ServerResponse.createByErrorCodeMessage(ResponseCode.ILLEGAL_ARGUMENT.getCode(),ResponseCode.ILLEGAL_ARGUMENT.getDesc());</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p><strong>2、</strong>看到<code>Cart cart =cartMapper.selectCartByUserIdAndProductId(userId,productId);   //自定义的sql语句</code>就知道需要去dao层的CartMapper.java文件，新增一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//注意在mybatis中使用多个参数时，需要使用param注解</span><br><span class="line">Cart selectCartByUserIdAndProductId(@Param(value =&quot;userId&quot; )Integer userId,@Param(value = &quot;productId&quot;) Integer productId);</span><br></pre></td></tr></table></figure></p><p>接着打开mappers包的CartMapper.xml文件，里面新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectCartByUserIdAndProductId&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;map&quot;&gt;</span><br><span class="line">  select</span><br><span class="line">  &lt;include refid=&quot;Base_Column_List&quot;/&gt;</span><br><span class="line">  from store_cart</span><br><span class="line">  where user_id=#&#123;userId&#125;</span><br><span class="line">  and  product_id =#&#123;productId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p><p><strong>3、</strong>继续回到CartServiceImpl.java文件，我们发现该产品不在这个购物车里面,因此需要新增一个这个产品的记录，而且商品的选中是自动的，也就是需要设置一个常量。我们能打开common包下面的const文件，在里面新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Cart&#123;</span><br><span class="line">    int CHECKED = 1;//购物车选中状态</span><br><span class="line">    int UN_CHECKED = 0;//购物车中未选中状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>4、</strong>接下来是核心的功能，如数量判断，值校验，购物车里面的商品也有图片，因此需要组装一个“新的”vo对象。因此，我们需要在Vo这个包里面，新建两个java类，一个是CartProductVo，它是结合了购物车和商品的对象，因此你可以去购物车和商品对象中选择你所需要的字段，里面的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">package top.store.vo;</span><br><span class="line"></span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line">public class CartProductVo &#123;</span><br><span class="line"></span><br><span class="line">    //本vo是结合了购物车和商品的对象，因此你可以去购物车和商品对象中选择你所需要的字段</span><br><span class="line">    private Integer id;  //购物车id</span><br><span class="line">    private Integer userId;</span><br><span class="line">    private Integer productId;</span><br><span class="line">    private Integer quantity;  //购物车中商品的数量</span><br><span class="line">    private String productName;   //商品名称</span><br><span class="line">    private String productSubtitle;   //商品子标题</span><br><span class="line">    private String productMainImage;  //商品主图</span><br><span class="line">    private BigDecimal productPrice;  //商品价格</span><br><span class="line">    private Integer productStatus;   //商品状态</span><br><span class="line">    private BigDecimal productTotalPrice;  //商品总价</span><br><span class="line">    private Integer productStock;   //商品库存</span><br><span class="line">    private Integer productChecked;//商品是否勾选</span><br><span class="line"></span><br><span class="line">    private String limitQuantity;//用于限制数量的一个返回结果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getUserId() &#123;</span><br><span class="line">        return userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserId(Integer userId) &#123;</span><br><span class="line">        this.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getProductId() &#123;</span><br><span class="line">        return productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setProductId(Integer productId) &#123;</span><br><span class="line">        this.productId = productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getQuantity() &#123;</span><br><span class="line">        return quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setQuantity(Integer quantity) &#123;</span><br><span class="line">        this.quantity = quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getProductName() &#123;</span><br><span class="line">        return productName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setProductName(String productName) &#123;</span><br><span class="line">        this.productName = productName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getProductSubtitle() &#123;</span><br><span class="line">        return productSubtitle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setProductSubtitle(String productSubtitle) &#123;</span><br><span class="line">        this.productSubtitle = productSubtitle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getProductMainImage() &#123;</span><br><span class="line">        return productMainImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setProductMainImage(String productMainImage) &#123;</span><br><span class="line">        this.productMainImage = productMainImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BigDecimal getProductPrice() &#123;</span><br><span class="line">        return productPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setProductPrice(BigDecimal productPrice) &#123;</span><br><span class="line">        this.productPrice = productPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getProductStatus() &#123;</span><br><span class="line">        return productStatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setProductStatus(Integer productStatus) &#123;</span><br><span class="line">        this.productStatus = productStatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BigDecimal getProductTotalPrice() &#123;</span><br><span class="line">        return productTotalPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setProductTotalPrice(BigDecimal productTotalPrice) &#123;</span><br><span class="line">        this.productTotalPrice = productTotalPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getProductStock() &#123;</span><br><span class="line">        return productStock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setProductStock(Integer productStock) &#123;</span><br><span class="line">        this.productStock = productStock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getProductChecked() &#123;</span><br><span class="line">        return productChecked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setProductChecked(Integer productChecked) &#123;</span><br><span class="line">        this.productChecked = productChecked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getLimitQuantity() &#123;</span><br><span class="line">        return limitQuantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLimitQuantity(String limitQuantity) &#123;</span><br><span class="line">        this.limitQuantity = limitQuantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另一个文件是CartVo，里面的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package top.store.vo;</span><br><span class="line"></span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class CartVo &#123;</span><br><span class="line">    //购物车Vo对象</span><br><span class="line">    private List&lt;CartProductVo&gt; cartProductVoList;   //商品对象</span><br><span class="line">    private BigDecimal cartTotalPrice;  //购物车所有商品总价</span><br><span class="line">    private boolean allChecked;   //购物车是否处于选中状态</span><br><span class="line">    private String imageHost;  //购物车对象的主图</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public List&lt;CartProductVo&gt; getCartProductVoList() &#123;</span><br><span class="line">        return cartProductVoList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCartProductVoList(List&lt;CartProductVo&gt; cartProductVoList) &#123;</span><br><span class="line">        this.cartProductVoList = cartProductVoList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BigDecimal getCartTotalPrice() &#123;</span><br><span class="line">        return cartTotalPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCartTotalPrice(BigDecimal cartTotalPrice) &#123;</span><br><span class="line">        this.cartTotalPrice = cartTotalPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isAllChecked() &#123;</span><br><span class="line">        return allChecked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAllChecked(boolean allChecked) &#123;</span><br><span class="line">        this.allChecked = allChecked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getImageHost() &#123;</span><br><span class="line">        return imageHost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setImageHost(String imageHost) &#123;</span><br><span class="line">        this.imageHost = imageHost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>5、</strong>我们继续回到CartServiceImpl.java文件，看到这行代码<code>List&lt;Cart&gt; cartList =cartMapper.selectCartByUserId(userId);  //自定义的sql语句</code>就知道需要去dao层的CartMapper.java文件，新增一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Cart&gt; selectCartByUserId(Integer UserId);</span><br></pre></td></tr></table></figure></p><p>接着打开mappers包的CartMapper.xml文件，里面新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectCartByUserId&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">  select</span><br><span class="line">  &lt;include refid=&quot;Base_Column_List&quot;/&gt;</span><br><span class="line">  from store_cart</span><br><span class="line">  where user_id =#&#123;userId&#125;</span><br><span class="line"></span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p><p><strong>6、</strong>Java中丢失精度的问题是一个值得注意的问题，因此我们需要进行设置。float和double只能用于科学计算和工程计算，商业运算必须使用BigDecimal。通过查看BigDecimal的String构造器，我们发现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">When a &#123;@code double&#125; must be used as a source for a</span><br><span class="line">* &#123;@code BigDecimal&#125;, note that this constructor provides an</span><br><span class="line">* exact conversion; it does not give the same result as</span><br><span class="line">* converting the &#123;@code double&#125; to a &#123;@code String&#125; using the</span><br><span class="line">* &#123;@link Double#toString(double)&#125; method and then using the</span><br><span class="line">* &#123;@link #BigDecimal(String)&#125; constructor.  To get that result,</span><br><span class="line">* use the &#123;@code static&#125; &#123;@link #valueOf(double)&#125; method.</span><br></pre></td></tr></table></figure></p><p>从上面的源码中我们也发现了这一情况，因此需要使用它的String构造器。但是呢，我们的数据库中存放的都是int类型，因此我们需要创建一个用于转换类型的工具类，打开Util这个包，我们在里面新建一个BigDecimalUtil.java的文件，在里面写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package top.store.util;</span><br><span class="line"></span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line">public class BigDecimalUtil &#123;</span><br><span class="line">    //我们不能使我们的工具类在外部进行实例化，因此将构造方法私有化</span><br><span class="line">    private BigDecimalUtil()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //加法</span><br><span class="line">    public static BigDecimal add(double a1,double a2)&#123;</span><br><span class="line">        BigDecimal b1 =new BigDecimal(Double.toString(a1));</span><br><span class="line">        BigDecimal b2 =new BigDecimal(Double.toString(a2));</span><br><span class="line">        return b1.add(b2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //减法</span><br><span class="line">    public static BigDecimal sub(double a1,double a2)&#123;</span><br><span class="line">        BigDecimal b1 =new BigDecimal(Double.toString(a1));</span><br><span class="line">        BigDecimal b2 =new BigDecimal(Double.toString(a2));</span><br><span class="line">        return b1.subtract(b2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //乘法</span><br><span class="line">    public static BigDecimal mut(double a1,double a2)&#123;</span><br><span class="line">        BigDecimal b1 =new BigDecimal(Double.toString(a1));</span><br><span class="line">        BigDecimal b2 =new BigDecimal(Double.toString(a2));</span><br><span class="line">        return b1.multiply(b2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //除法，注意使用四舍五入</span><br><span class="line">    public static BigDecimal div(double a1,double a2)&#123;</span><br><span class="line">        BigDecimal b1 =new BigDecimal(Double.toString(a1));</span><br><span class="line">        BigDecimal b2 =new BigDecimal(Double.toString(a2));</span><br><span class="line">        return b1.divide(b2,2,BigDecimal.ROUND_HALF_UP);  //四舍五入模式，保留2位小数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以使用Ctrl+O（字母O）来查看该类的不同类型的构造方法,我们使用下面的构造方法，scale是指你保留的位数，roundingMode是指什么模式：ROUND_HALF_UP是四舍五入模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</span><br></pre></td></tr></table></figure></p><p>具体的可以参看这篇文章：<a href="https://www.cnblogs.com/yingchen/p/5459501.html" target="_blank" rel="noopener">BigDecimal.ROUND_HALF_XXX的各种用法</a><br><strong>7、</strong>我们这里之所以不直接从商品对象里获取信息，是因为后面有些是存在于购物车的，有些存在于商品，很容易造成混乱，因此我们这里就使用了一个组装的购物车商品对象，你需要的时候调用它就可以。<br><strong>8、</strong>在判断库存数量的时候，我们需要注意设置一个常量，用于提示前端最低库存，继续打开common包下面的const文件，在里面新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String LIMIT_NUM_FAIL = &quot;LIMIT_NUM_FAIL&quot;;</span><br><span class="line">String LIMIT_NUM_SUCCESS = &quot;LIMIT_NUM_SUCCESS&quot;;</span><br></pre></td></tr></table></figure></p><p>把之前的购物车状态代码合在一块就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Cart&#123;</span><br><span class="line">    int CHECKED = 1;//购物车选中状态</span><br><span class="line">    int UN_CHECKED = 0;//购物车中未选中状态</span><br><span class="line"></span><br><span class="line">    String LIMIT_NUM_FAIL = &quot;LIMIT_NUM_FAIL&quot;;</span><br><span class="line">    String LIMIT_NUM_SUCCESS = &quot;LIMIT_NUM_SUCCESS&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>9、</strong>然后就是<code>cartVo.setImageHost(PropertiesUtil.getProperty(&quot;ftp.server.http.prefix&quot;));   //这里需要直接从服务器中获取</code>这个很多注意事项我都在代码里面作了详细的说明。<br><strong>10、</strong>看到这行代码，你同样需要<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//如果用户不为空</span><br><span class="line">//这里sql语句结果之所以没有返回boolean是因为我们去数据库里面一般返回的都是int，所以需要进行二次判断</span><br><span class="line">return cartMapper.selectCartProductCheckedStatusByUserId(userId) ==0;</span><br></pre></td></tr></table></figure></p><p>去dao层的CartMapper.java文件，新增一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int selectCartProductCheckedStatusByUserId(Integer userId);</span><br></pre></td></tr></table></figure></p><p>接着打开mappers包的CartMapper.xml文件，里面新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  &lt;select id=&quot;selectCartProductCheckedStatusByUserId&quot; resultType=&quot;int&quot; parameterType=&quot;int&quot;&gt; &lt;!--这里就是说里面有没有选中的就意味着不是全选--&gt;</span><br><span class="line">    SELECT  count(1) from store_cart where checked = 0 and user_id = #&#123;userId&#125;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></p><h3 id="精度测试"><a href="#精度测试" class="headerlink" title="精度测试"></a>精度测试</h3><p>对了，还有前面的精度测试，我们打开test包下面的java包，里面新建一个包<code>top.licheetools.test</code>，名字随意，我这里就是这个样子，然后新建BigDecimalTest.java文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package top.licheetools.test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line">//这里因为是专门的测试包，所以不需要使用junit，也不需要加载Spring容器</span><br><span class="line">public class BigDecimalTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test1()&#123;</span><br><span class="line">        System.out.println(0.08+0.05);</span><br><span class="line">        System.out.println(2.01-0.58);</span><br><span class="line">        System.out.println(0.08*100);</span><br><span class="line">        System.out.println(6.89/100);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void test2()&#123;</span><br><span class="line">        //使用BigDecimal的Integer构造函数</span><br><span class="line">        BigDecimal b1 =new BigDecimal(0.06);</span><br><span class="line">        BigDecimal b2 =new BigDecimal(0.09);</span><br><span class="line">        System.out.println(b1.add(b2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test3()&#123;</span><br><span class="line">        //使用BigDecimal的String构造函数</span><br><span class="line">        BigDecimal b1 =new BigDecimal(&quot;0.06&quot;);</span><br><span class="line">        BigDecimal b2 =new BigDecimal(&quot;0.09&quot;);</span><br><span class="line">        System.out.println(b1.add(b2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果我这里就只附上截图：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-011f1c75b8ca614b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b8be261813fbfae1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-624dce4cccb03d30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这样我们本篇关于如何将商品加入到购物车的介绍就到此为止了，这里因为需要构造一个复用的购物车模型，所以需要很多时间，但是后面功能的实现就能直接借助它了，开发起来还是快速的，感谢你的赏阅！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本章节我们来介绍购物车模块相关功能的开发，具体包括加入商品；更新商品数；查询商品数；移除商品；单选/取消；全选/取消和购物车
      
    
    </summary>
    
      <category term="java" scheme="http://blog.licheetools.top/categories/java/"/>
    
    
      <category term="SSM框架" scheme="http://blog.licheetools.top/tags/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="JAVA后端" scheme="http://blog.licheetools.top/tags/JAVA%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
</feed>
